<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Page 4 | WY J</title>
  <meta name="author" content="Wenye Jin">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="WY J">

  
    <meta property="og:image" content>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>
</html>
 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">WY J</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>WY J<span class="blink-fast">∎</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">


		<i class="fa fa-heart blink-slow"></i>

		for(Terminated(), int x) end of coding;

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/03/11/[MATH]07_Bases/">Bases</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-03-11  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="Digital-images"><a href="#Digital-images" class="headerlink" title="Digital images"></a>Digital images</h2><p>Digital images are composed of pixels. For a grey-scale picture, every pixel is represented by a one-byte number, from 0 (for black) to 255 (for white). In a colour picture, every pixel is represented by three one-byte numbers, one each for red, green, and blue.<br>&nbsp;<br>NOTE : we are thinking of a grey-scale picture from now on.</p>
<h2 id="Generating-an-algebra-of-vectors"><a href="#Generating-an-algebra-of-vectors" class="headerlink" title="Generating an algebra of vectors"></a>Generating an algebra of vectors</h2><p>Linear combination : ∑ a(i) <em> v(i) = a1 </em> v1 + … + a(n) * v(n)<br>&nbsp;<br>the collection of all linear combinations is itself an algebra of vectors :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">∑ a(i) * v(i) + ∑ b(i) * v(i) = ∑ (a(i) + b(i)) * v(i)</span><br><span class="line"></span><br><span class="line">k * ∑ a(i) * v(i) = ∑ (a * k)(i) * v(i)</span><br></pre></td></tr></table></figure>
<h2 id="Linear-independence"><a href="#Linear-independence" class="headerlink" title="Linear independence"></a>Linear independence</h2><p>Theorem 3 : A collection v1, …, vn of vectors is linear independent if ∑ a(i) * v(i) = 0 happens only in case a1 = a2 = a3 = … = an = 0.</p>
<ul>
<li>the null vector 0 does not occur in the list v1, …, vn (because thi doesn’t generate anything)</li>
<li>none of the v(i) is a linear combination of the rest. (because this would be aredundancy)</li>
</ul>
<p>proof:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1)  Suppose the collection is not linear independent</span><br><span class="line"> </span><br><span class="line">    case 1 : null vector occurs among v1...vn</span><br><span class="line">             &gt; assume v1 = 0, so we have 1 * v1 + ∑(i = 2) 0 * v(i) = 0.</span><br><span class="line">             &gt; But not all coefficients a(n) are zero.</span><br><span class="line">             &gt; we conclude a contradiction.</span><br><span class="line">    case 2 : there is a vector which can form a linear comnbination of the rest vectors.</span><br><span class="line">             &gt; assume v1 = ∑(i = 2) a(i) * v(i), so we have 1 * v2 - ∑(i = 2) a(i) * v(i) = 0</span><br><span class="line">             &gt; similarly this contradicts the given criterion.</span><br><span class="line"></span><br><span class="line">    ------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">2)  Suppose ∑ a(i) * v(i) = 0 and a1 != 0.</span><br><span class="line"></span><br><span class="line">    case 1 : n = 1</span><br><span class="line">             &gt; so we have a1 * v1 = 0</span><br><span class="line">             &gt; as a1 != 0, so v1 is a null vector.</span><br><span class="line">             &gt; the first condition is violated.</span><br><span class="line">    case 2 : n &gt; 1</span><br><span class="line">             &gt; we write v1 as : v1 = (-a1^(-1)) * ∑(i = 2) a(i) * v(i)</span><br><span class="line">             &gt; v1 is a linear combination of the rest vectors.</span><br><span class="line">             &gt; the second condition is violated.</span><br></pre></td></tr></table></figure>
<p>if every element of an algebra V of vectors can be written as a linear combination of vector v1 … vn and if the v(i) of v1 … vn are linearly independent, then we call v1 … vn a basis of V.<br>&nbsp;<br>NOTE : for example, in an image, we convert every 8 * 8 pixels to jpeg-format.<br>&NBSP;<br>example: 4-tuples of rational numbers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ p1 \</span><br><span class="line">| p2 | = p1 * v1 + p2 * v2 + p3 * v3 + p4 * v4</span><br><span class="line">| p3 |</span><br><span class="line">\ p4 /</span><br><span class="line">             </span><br><span class="line">basis : v1 = (1, 0, 0, 0)</span><br><span class="line">        v2 = (0, 1, 0, 0)</span><br><span class="line">        v3 = (0, 0, 1, 0)</span><br><span class="line">        v4 = (0, 0, 0, 1)</span><br><span class="line">           </span><br><span class="line">they are linearly independent :</span><br><span class="line">        &gt; a1 * v1 + a2 * v2 + a3 * v3 + a4 * v4 = 0 = (0, 0, 0, 0)</span><br><span class="line">        &gt; as v(i) are not null vectors, and none of them is a LC of the rest</span><br><span class="line">        &gt; a1 = a2 = a3 = a4 = 0</span><br><span class="line">        &gt; they are linearly independent</span><br></pre></td></tr></table></figure>
<h2 id="Coordinates"><a href="#Coordinates" class="headerlink" title="Coordinates"></a>Coordinates</h2><p>vector generator by using the basis: w = ∑ a(i) <em> v(i)<br><code>a1, ..., an</code>: the coordinates of w<br>&nbsp;<br>A question     : Are the coordinates for w are uniquely determined.<br>representation : ? w = ∑ a(i) </em> v(i) = ∑ b(i) * v(i)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Assume : w = ∑ (b(i) - a(i)) * v(i) = 0   // according to theorem 3</span><br><span class="line"></span><br><span class="line">so we have b(i) - a(i) = 0 for all i</span><br><span class="line"></span><br><span class="line">then,</span><br><span class="line">b(i) = a(i)</span><br></pre></td></tr></table></figure>
<h2 id="Dimension-of-an-algebra-of-vectors"><a href="#Dimension-of-an-algebra-of-vectors" class="headerlink" title="Dimension of an algebra of vectors"></a>Dimension of an algebra of vectors</h2><p>Theorem 4 : Any two bases of an algebra of vectors have the same number of elements.</p>
<h2 id="All-bases-are-not-equal"><a href="#All-bases-are-not-equal" class="headerlink" title="All bases are not equal"></a>All bases are not equal</h2><p>example: a 2 × 2 digital (grey-scale) image, written as a four-tuple. In the standard basis, we can read off the coordinates immediately:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ 10 \        /1\        /0\        /0\        /0\</span><br><span class="line">| 10 | = 10 * |0| + 10 * |1| + 11 * |0| + 12 * |0|</span><br><span class="line">| 11 |        |0|        |0|        |1|        |0|</span><br><span class="line">\ 12 /        \0/        \0/        \0/        \1/</span><br></pre></td></tr></table></figure>
<p>the same image can be represented by a different basis.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ 10 \          /1\         / 1\         / 1\         / 1\</span><br><span class="line">| 10 | = 43/4 * |1| - 3/4 * | 1| + 1/4 * |-1| + 1/4 * |-1|</span><br><span class="line">| 11 |          |1|         |-1|         |-1|         | 1|</span><br><span class="line">\ 12 /          \1/         \-1/         \ 1/         \-1/</span><br></pre></td></tr></table></figure>
<p>convert to a jpeg-compression where we ONLY leave the bigger coordinates.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ 10   \          /1\         / 1\</span><br><span class="line">| 10   | = 43/4 * |1| - 3/4 * | 1|</span><br><span class="line">| 11.5 |          |1|         |-1|</span><br><span class="line">\ 12.5 /          \1/         \-1/</span><br></pre></td></tr></table></figure>
<h2 id="Orthogonal-and-orthonormal-bases"><a href="#Orthogonal-and-orthonormal-bases" class="headerlink" title="Orthogonal and orthonormal bases"></a>Orthogonal and orthonormal bases</h2><p>NOTE :The coordinates of an image in jpeg-format comes from orthogonality.<br>&nbsp;<br>Assume that we have a basis v1 .. vn where any two vectors are orthogonal to each other, that is :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;v(i), v(j)&gt; = 0 whenever i != j</span><br></pre></td></tr></table></figure>
<p>then coordinate of a(k) is computed :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        &lt;w, v(k)&gt;</span><br><span class="line">a(k) = ------------</span><br><span class="line">       &lt;v(k), v(k)&gt;</span><br></pre></td></tr></table></figure>
<p>proof:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;w, v(k)&gt; = &lt;∑ a(i) * v(i), v(k)&gt;</span><br><span class="line">          =  ∑ a(i) * &lt;v(i),v(k)&gt;   // law of inner product</span><br><span class="line">          = a(k) * &lt;v(k), v(k)&gt;</span><br></pre></td></tr></table></figure>
<p>positive definiteness of the inner product:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;v, v&gt;  &gt;=  0</span><br><span class="line">&lt;v, v&gt;   =  0  -&gt;  v = 0</span><br></pre></td></tr></table></figure>
<p>NOTES :</p>
<ul>
<li>If the computations are done on a computer, then we can make sure that each basis vector has length 1, so the division by &lt;v(k), v(k)&gt; is not necessary when computing the coordinates. In that case one speaks of an orthonormal basis. If computations are done on paper, then it’s better to avoid the surds and stay with the merely orthogonal basis. </li>
<li>this formula can be checked by using above example (10, 10, 11, 12).</li>
</ul>
<h2 id="Creating-an-orthogonal-basis"><a href="#Creating-an-orthogonal-basis" class="headerlink" title="Creating an orthogonal basis"></a>Creating an orthogonal basis</h2><p>if we have a positive definte inner product then we can turn any basis into an orthogonal one<br>We define a new basis w1 … wn :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w1 = v1</span><br><span class="line">          &lt;w1, v2&gt;</span><br><span class="line">w2 = v2 - -------- * w1</span><br><span class="line">          &lt;w1, w1&gt;</span><br><span class="line"></span><br><span class="line"> .</span><br><span class="line"> .</span><br><span class="line"> .</span><br><span class="line">                        &lt;wi, vn&gt;</span><br><span class="line">wn = vn - ∑(n-1; i = 1) -------- * wi</span><br><span class="line">                        &lt;wi, wi&gt;</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2019/03/11/[MATH]07_Bases/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/03/11/[MATH]12_Decidability&HaltingProblem/">Decidability and The Halting Problem</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-03-11  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="Church’s-Thesis"><a href="#Church’s-Thesis" class="headerlink" title="Church’s Thesis"></a>Church’s Thesis</h2><p>def : any decision problem on words that can be solved by an algorithm can be solved by a turing machine.<br>&nbsp;<br>other version for functions f : Σ^<em> → Σ^</em> : any functions on words that can be computed by an algorithm can be solved by a turing machine..<br>&nbsp;<br>computable : if there is a turing machine can return f(word) to a given word<br>decidable  : if there is a turing machine can return yes or no to a given argument<br>&nbsp;<br>examples : </p>
<ul>
<li>A function f : N -&gt; N is computable when there is a turing mahchine that starting from a natural number, written in binary, halts with the number f(n) in binary. By Church’s thesis, it is computable when there is some program that when given a number n, it returns f(n).</li>
<li>Ambiguity of a context free grammar is undecidable. This means there is no turing machine can return yes if the grammar over <code>{a, b, |, ::=, nowhere, _}</code> is ambiguous an no if is unambiguous. By Church’s thesis, there is no program that when given a grammar over the set of <code>{a, b, |, ::=, nowhere, _}</code> returns true if the grammar is ambiguous and false if not.<br>&nbsp;<br>NOTES :</li>
<li>natural numbers, Turing machines, Java programs and context free grammars can be encoded as words</li>
<li>words, Turing machines, Java prorgrams and context free grammars can be encoded as natural numbers.</li>
</ul>
<h2 id="Reduction-of-a-problem-to-another-problem"><a href="#Reduction-of-a-problem-to-another-problem" class="headerlink" title="Reduction of a problem to another problem"></a>Reduction of a problem to another problem</h2><p>def : when given problem P and Q, suppose that we show how to solve Q using a black box that solves P. Then is called reducing problem Q to problem P .<br>&nbsp;<br>if we have reduced Q to P, then the following satisfied :</p>
<ul>
<li>if P is decidable, Q is then decidable</li>
<li>if Q is undecidable, P is then undecidable</li>
</ul>
<h2 id="Undecidable-problems"><a href="#Undecidable-problems" class="headerlink" title="Undecidable problems"></a>Undecidable problems</h2><p>examples of undecidable problems :</p>
<ul>
<li>ambiguity of context free languages</li>
<li>equivalence of context free languages</li>
<li>the halting problem</li>
</ul>
<h2 id="The-Halting-Problem"><a href="#The-Halting-Problem" class="headerlink" title="The Halting Problem"></a>The Halting Problem</h2><p>Prove that the halting problem is undecidable :<br>assume the halting problem is decidable, so there is a program returns true if it halts and false if it does not.<br>We have a boolean method :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">haltcheck</span><span class="params">(String a, String b)</span></span></span><br></pre></td></tr></table></figure>
<p>Now we create a new method which loops forever if the <code>haltcheck()</code> method halts and halts if it loops forever.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hangcheck</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(haltcheck(a,b)) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;&#125;; it loops forever</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">//it halts</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Finally we have a program when we apply argument b to input b itself in the halt tester, it halts(return true) if it loops forever(never halts) and loops forever(return false) if it halts.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doublehang</span><span class="params">(String b)</span> </span>&#123;</span><br><span class="line">  hangcheck(b,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This raises a contradiction to our assumption. Hence the halting problem is undecidable.</p>

	
	</div>
  <a type="button" href="/2019/03/11/[MATH]12_Decidability&HaltingProblem/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/03/11/[MATH]14_N&NP/">Polynomial and non-Polynomial</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-03-11  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="Polynomial-time-algorithms"><a href="#Polynomial-time-algorithms" class="headerlink" title="Polynomial time algorithms"></a>Polynomial time algorithms</h2><p>P : a polynomial time algorithm has running time in O(n^k). A polynomial time algorithm is said to be feasible; an algorithm that’s not polynomial time is said to be infeasible.<br>&nbsp;<br>some example algorithms are :</p>
<ul>
<li>A constant time algorithm has running time in O(1).</li>
<li>A linear time algorithm has running time in O(n).</li>
<li>A quadratic time algorithm has running time in O(n2). </li>
<li>A cubic time algorithm has running time in O(n3).</li>
</ul>
<h2 id="NP-Search-problems"><a href="#NP-Search-problems" class="headerlink" title="NP Search problems"></a>NP Search problems</h2><p>A search problem is a relation from the set of words(problem instances) to the set of words(solutions).<br>&nbsp;<br>NP : an NP search problem is a search problem wehere solutions have polynomial size in n, and can be checked in a time polynomial in n. Here n is the size of the problem instance.</p>
<ul>
<li>solutions have size polynomial in n : for a problem instance of size n, all words that are solutions have size &lt;= p(n). (where p(n) is some O())</li>
<li>solutions can be checked in a time polynomial in n : given a problem instance A and a solution B, there is an alogorithm that checks whether it is &lt;= q(n). (where q(n) is some O())</li>
</ul>
<p>from these two steps, we can find a solution in exponential time. As the number of words(for example 0-9; a-z) is r, there are at most (r + 1)^p(n). And, each word can be checked in q(n) so overall we have (r + 1)^p(n) * q(n) steps to find a solution, which is exponential time.<br>&nbsp;<br>“NP = P” question : can every NP seach problem be solved in polynomial time?</p>
<p>example : sudoku (NP)</p>
<ol>
<li>solutions have size polynomial in n…</li>
<li>solutions can be checked in a time polynomial in n…</li>
<li>we can find a solution in exponential time…</li>
</ol>
<p>example : factorization (NP)</p>
<ol>
<li>solutions have size polynomial in n…</li>
<li>solutions can be checked in a time polynomial in n…</li>
<li>we can find a solution in exponential time…</li>
</ol>
<h2 id="examples-of-NP"><a href="#examples-of-NP" class="headerlink" title="examples of NP"></a>examples of NP</h2><p>problems in NP but are not known to be in P :</p>
<ul>
<li>The travelling salesman. A salesman has to plan a journey between n cities (and return to the<br>start) in a way that minimizes his total distance.</li>
<li>Optimal scheduling.</li>
<li>Path planning (used by robots).</li>
<li>Many problems on graphs.</li>
<li>Boolean satisfiability (SAT).</li>
</ul>

	
	</div>
  <a type="button" href="/2019/03/11/[MATH]14_N&NP/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/03/11/[MATH]13_Complexity/">Complexity</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-03-11  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="Preliminary-laws-of-probability"><a href="#Preliminary-laws-of-probability" class="headerlink" title="Preliminary: laws of probability"></a>Preliminary: laws of probability</h2><p>basic laws of probability :</p>
<ul>
<li>an impossible event has P = 0</li>
<li>some certain events have P = 1</li>
<li>For events that are mutually exclusive(相互排斥在同一P), P(A or B) = P(A) + P(B)</li>
<li>For events that are independent(相互独立在不同P), P(A and B) = P(A) * P(B)</li>
</ul>
<h2 id="Preliminary-important-summation"><a href="#Preliminary-important-summation" class="headerlink" title="Preliminary: important summation"></a>Preliminary: important summation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 + 1 + 2 + ... + (n - 1) = 1/2 * n * (n - 1)</span><br><span class="line">1 + 2 + 3 + ... + n       = 1/2 * n * (n + 1)</span><br><span class="line"></span><br><span class="line">1 + b + b^2 + b^3 + ... + b^(n-1) = 1/(b - 1) * (b^n - 1)</span><br><span class="line">1 + b + b^2 + b^3 + ... + b^n     = 1/(b - 1) * (b^(n+1) - 1)</span><br></pre></td></tr></table></figure>
<h2 id="Runing-time-of-a-program"><a href="#Runing-time-of-a-program" class="headerlink" title="Runing time of a program"></a>Runing time of a program</h2><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><p>We don’t usually work out the precise running time of a program; indeed we don’t usually have the information needed to do so. Instead we work out the complexity, which is a kind of rough estimate of the running time that ignores two things:</p>
<ol>
<li>small arguments</li>
<li>constant factors</li>
</ol>
<h2 id="Big-Oh"><a href="#Big-Oh" class="headerlink" title="Big-Oh"></a>Big-Oh</h2><p>def : let f(n) be the running time for an argument of size n. let g(n) be another such function. there is the case when f ∈ O(g) given natural number M and constant factor C, such that for all n &gt;= M we have f(n) &lt;= C * g(n)<br>&nbsp;<br>logical symbol : ∃M. ∃C. ∀n &gt;= M. f(n) &lt;= C × g(n)<br>rearrange the inequality : f(n)/g(n) &lt;= C<br>&nbsp;<br>NOTE : C is the upper bound when it is the maximum of f(n)/g(n).<br>&nbsp;<br>we use big-Oh to solve complexity problems :</p>
<ul>
<li>The running time of my program is 3n2 + 9n + 8. Is this in O(n2)? In O(n)? In O(n3)?</li>
<li>The running time of my program is 5n for n &lt; 1000, and 3n2 +9n+8 for n 􏰂&lt; 1000. Is this in O(n2)? In O(n)? In O(n3)?</li>
<li>The running time of my programn is 5n. Is this in O(n2)? In O(n)? In O(n3)?</li>
<li>On an argument of size n, I first run a program whose running time is in O(n2), and then run a program whose running time is in O(n3). Show that the total running time is in O(n3).</li>
</ul>
<p>NOTE : exponential growth is faster than polunomial growth.</p>
<h2 id="Polynomial-Time"><a href="#Polynomial-Time" class="headerlink" title="Polynomial Time"></a>Polynomial Time</h2><p>def : The program is polynomial time when there is k such that f ∈ O(nk). In detail, it is polynomial time when there is k and M and C such that if n 􏰂 M then f(n) 􏰁 C × nk.</p>
<h2 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity"></a>Space Complexity</h2><p>We can study the space usage of a program in a similar way. For example, suppose my program, on an argument of size n, uses 8 * n^2 + 5 bytes of memory. We then say that the space usage is in O(n^2).</p>

	
	</div>
  <a type="button" href="/2019/03/11/[MATH]13_Complexity/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/03/11/[MATH]15_TuringMachine/">Turing Machine</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-03-11  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="Reasons-to-introduce-turing-machine"><a href="#Reasons-to-introduce-turing-machine" class="headerlink" title="Reasons to introduce turing machine"></a>Reasons to introduce turing machine</h2><p>When we compute complexity of a program, we sometimes made assumption which is not precise enough. we need a model of computation that fully specifies the steps of programs.</p>
<h2 id="Turing-machine"><a href="#Turing-machine" class="headerlink" title="Turing machine"></a>Turing machine</h2><p>def : a turing machine has finitely many states(like a DFA), but it also has an exernal memory : an infinite tapes divided into cells. there is a head sitting over one cell of the tape.<br>&nbsp;<br>we specift two finite sets of a turing machine :</p>
<ol>
<li>the tape alphabet T = <code>{a, b, _}</code> where <code>_</code> is a blank character.</li>
<li>the set V of return values.</li>
</ol>
<p>for T = <code>{a,b,_}</code> and V = <code>{True, False}</code>, the instructions available are :</p>
<ul>
<li>read <code>a</code> or <code>b</code> or <code>_</code></li>
<li>write <code>a</code> or <code>b</code> or <code>-</code></li>
<li>left</li>
<li>right</li>
<li>No-op (which does nothing)</li>
<li>Return True</li>
<li>Return False</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              head</span><br><span class="line">...   [a] [_] [a] [b] [b] [ ]  ...</span><br><span class="line">           &lt;-- . --&gt;</span><br></pre></td></tr></table></figure>
<p>NOTE : if V is a singleton set then return instruction is usually just written Stop.</p>
<h2 id="Representation-of-a-turing-machine"><a href="#Representation-of-a-turing-machine" class="headerlink" title="Representation of a turing machine"></a>Representation of a turing machine</h2><p>A turing machine has :</p>
<ol>
<li>a finite state X of states</li>
<li>an initial state p ∈ X</li>
<li>a transition function δ from X to some instructions (example : read, write, left …)</li>
</ol>
<p>example : convert a into b from a given tape</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   ... aaabbbbabaaa_ ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  right ---------- [12] &lt;--------- b</span><br><span class="line">    |                              .</span><br><span class="line">    ∨                              |  </span><br><span class="line">=&gt; [5] ----------- read -----------.--- _ -&gt; [8] --&gt; Stop</span><br><span class="line">    ∧                              |</span><br><span class="line">    |                              .</span><br><span class="line">  right - [4] &lt;- write b - [3] &lt;-- a</span><br></pre></td></tr></table></figure>
<p>example : return true if the number of as is even in the given tape</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ... aaababaaabbba_ ...</span><br><span class="line"></span><br><span class="line">=&gt; [3] -- read - . ----- . --- .</span><br><span class="line">    ∧            |       |     |</span><br><span class="line">    |            b       a     _</span><br><span class="line">    |            |       |     |</span><br><span class="line">    -- right -- [2]      |    [6] - return : Even</span><br><span class="line">                 ∧  --&gt; [8]  </span><br><span class="line">                 |  |    | </span><br><span class="line">                 |  |  right</span><br><span class="line">                 |  |    |</span><br><span class="line">                 |  |    |</span><br><span class="line">              ----  |    ∨</span><br><span class="line">              |     |   [5]</span><br><span class="line">              |     |    |</span><br><span class="line">              a     b  read</span><br><span class="line">              |     |    |</span><br><span class="line">              . --- . -- . -- _ --- return : Odd</span><br></pre></td></tr></table></figure>
<p>NOTE : macros enable us to combine two programs together. for example we have even/ odd checker and program of replacing a into b. we can combine them.</p>
<p>example : reverse copy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">                       aabba_abbaa</span><br><span class="line">  </span><br><span class="line">     ------------------- &gt; [0] &lt; ------------------</span><br><span class="line">     |                      |                     |</span><br><span class="line">     |                      ∨                     |</span><br><span class="line">   write a              =&gt; [1]                 write b</span><br><span class="line">     |                      |                     |</span><br><span class="line">     |   ----&gt;[2]&lt;- a -.- read -.- b -&gt;[4]&lt;-----  |</span><br><span class="line">     |   |     |            |            |     |  |</span><br><span class="line">     |   |   right          .           right  |  |</span><br><span class="line">     |   |     |            |            |     |  |</span><br><span class="line">    [6]  |     ∨            _            ∨     | [27]</span><br><span class="line">     ∧   |    [5]           |           [8]    |  ∧ </span><br><span class="line">     |  a,b    |            ∨            |    a,b |</span><br><span class="line">     _   |    read         [3]          read   |  _</span><br><span class="line">     |   |__.__|            |            |__.__|  |</span><br><span class="line">     .         |           Stop          |        .</span><br><span class="line">     |         .                         .        |</span><br><span class="line"> .- read       |                         |       read -.</span><br><span class="line"> |   |         _                         _         |   |</span><br><span class="line"> |  [23]       |                         |       [24]  |</span><br><span class="line">a,b  ∧         ∨                         ∨         ∧  a,b</span><br><span class="line"> |   |    ----&gt;[9]                      [7]&lt;----   |   |</span><br><span class="line"> | left  |     |                         |     |  left |</span><br><span class="line"> |   |   |   right                      right  |   |   |</span><br><span class="line"> -&gt;[21]  |     |                         |     |  [22]&lt;-</span><br><span class="line">     ∧   |     ∨                         ∨     |   ∧</span><br><span class="line">     |   |    [10]                     [11]    |   |</span><br><span class="line">     _  a,b    |                         |    a,b  _</span><br><span class="line">     |   |    read                      read   |   |</span><br><span class="line">     .   |__.__|                         |__.__|   .</span><br><span class="line">     |         |                         |         |</span><br><span class="line">  -- read      .                         .        read --</span><br><span class="line">  |   |        |                         |         |    |</span><br><span class="line">  |  [16]      _                         _        [17]  |</span><br><span class="line">  |   ∧        |                         |         ∧    |</span><br><span class="line">  |   |        ∨                         ∨         |    |</span><br><span class="line">  .  left     [12]                     [13]       left  .</span><br><span class="line">  |   |        |                         |         |    |</span><br><span class="line">  |  [15] &lt;-- write a                 write b --&gt; [14]  |</span><br><span class="line">  |   ∧                                            ∧    |</span><br><span class="line"> a,b  |                                            |   a,b</span><br><span class="line">  |___|                                            |____|         // complexity : O(n^2)</span><br></pre></td></tr></table></figure>
<h2 id="More-complex-TM"><a href="#More-complex-TM" class="headerlink" title="More complex TM"></a>More complex TM</h2><ul>
<li>2-tape turing machine</li>
<li>m x n turing machine</li>
</ul>

	
	</div>
  <a type="button" href="/2019/03/11/[MATH]15_TuringMachine/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/03/11/[MATH]16_PropertiesofCode/">Properties of Code</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-03-11  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="Undecidability-by-reduction"><a href="#Undecidability-by-reduction" class="headerlink" title="Undecidability by reduction"></a>Undecidability by reduction</h2><p>def: to prove other undecidable problem we can reduce the halting problem to it.<br>Because if reducing Q to P we have</p>
<ul>
<li>if P is decidable then Q is decidable</li>
<li>if Q is undecidable then P is undecidable</li>
</ul>
<p>example: X is a undecidable property when X halts and contains more occurances of a than b<br>proof: </p>
<ol>
<li>reduce the halting problem to X.</li>
<li>for any program C of type void. let F(C) be the same code as C with an extra comment line which gives more occurances of a than b.</li>
<li>if C halts, then F(C) is X</li>
<li>if C does not halts, then F(C) is not X</li>
<li>we cannot test whether C halts, so we cannot decide whether it is X.</li>
<li>as C is undecidable, F(C) is undecidable</li>
<li>so X is undecidable</li>
</ol>
<h2 id="Semantic-and-non-semantic-properties"><a href="#Semantic-and-non-semantic-properties" class="headerlink" title="Semantic and non-semantic properties"></a>Semantic and non-semantic properties</h2><p>semantic properties: </p>
<ul>
<li>Does this software print only polite words?</li>
<li>Does this software provide good advice to all users, and excellent advice to premium users?</li>
<li>Does this software, when supplied with two positive integers, always return the highest common factor?</li>
</ul>
<p>to test whether a given property is a semantic property or not: </p>
<ul>
<li>to show not semantic, give two programs one has the property and one has not.</li>
<li>to show semantic, there is no program has different properties.</li>
</ul>
<h2 id="Rice’s-Theorem"><a href="#Rice’s-Theorem" class="headerlink" title="Rice’s Theorem"></a>Rice’s Theorem</h2><p>def: any semantic property of code that holds in some case and does not hold in some case is undecidable.</p>

	
	</div>
  <a type="button" href="/2019/03/11/[MATH]16_PropertiesofCode/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/02/20/[DataStructure]01/">Theory part</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-02-20  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="Basic-Data-Structure"><a href="#Basic-Data-Structure" class="headerlink" title="Basic Data Structure"></a>Basic Data Structure</h2><p><strong>Arrays</strong><br>An ordered collection of items : <code>a[i]</code><br><code>i</code> : the index of item.</p>
<p><strong>Loops and invariants</strong><br>General for-loop structure :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(INITIALIZATION; CONDITION; UPDATE) &#123;</span><br><span class="line">    REPEATED PROCESS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Invariant : a condition that does not change during the excution of a given program. i.e. i&lt;20 invariants enable correctness proof and verification. In particular, a loop-invariant is a condition that holds at the beginning and the end of every iteration.</p>
<p>example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mimimum(int n, float a[n]) &#123;</span><br><span class="line">    float min = a[0];</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i != n; i++) &#123;</span><br><span class="line">        if(a[i] &lt; min) min = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Initialization   : invariant is true at the beginning.</li>
<li>loop starting    : invariant preserved.</li>
<li>repeated process : invariant is true at the end.</li>
<li>loop ends        : end condition.</li>
</ol>
<p>NOTE : the example above is a kind of proof by induction.</p>
<p><strong>Lists</strong><br>2-cell Representation of a non-empty list :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; [3][]-&gt; [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]</span><br></pre></td></tr></table></figure>
<p>Primitive operators<br>1) Constructors</p>
<ul>
<li>emptyList</li>
<li>makeList(element, List) : return a list</li>
</ul>
<p>2) Selectors</p>
<ul>
<li>first(list) : return an item</li>
<li>rest(list)  : return a list</li>
</ul>
<p>3) Condition</p>
<ul>
<li>isEmpty(list)</li>
</ul>
<p>4) mutators</p>
<ul>
<li>replaceFirst(x,list)</li>
<li>replaceRest(rest,list)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">replaceFirst(x, l) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(l)) <span class="keyword">return</span> <span class="string">"Error"</span>;</span><br><span class="line">    <span class="keyword">return</span> makeList(x,rest(l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">replaceRest(r, l) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(l)) <span class="keyword">return</span> <span class="string">"Error"</span>;</span><br><span class="line">    <span class="keyword">return</span> makeList(first(l),r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Recursion</strong><br>When items are stored as linked-list, it is unlike arrays which can use loops with indices to acess each item. we shall use recursion for data structures like lists.<br>&nbsp;<br>def : the idea is to formulate procedures which involve at least one step  that invokes the procedure itself.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">last(list) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(list)) <span class="keyword">return</span> <span class="string">"cannot access the last item"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(isEmpty(rest(list))) </span><br><span class="line">        <span class="keyword">return</span> first(list);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> last(rest(list));</span><br><span class="line">&#125;  <span class="comment">// this is also called : tail recursion where recursion happens at the end.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">append(list1, list2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(list1)) </span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> makeList(first(list1), append(rest(list1),list2));</span><br><span class="line">&#125;  <span class="comment">//time.Compx = length of list1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isMember(x, list) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(list)) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(first(list) == x)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(isEmpty(rest(list)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        isMember(x,rest(list));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Stacks</strong><br>def : data structure to model a First-In-Last-Out (FILO), or Last-In-First-Out (LIFO), strategy in search.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[3][]-&gt; [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]  </span><br><span class="line"></span><br><span class="line">top we got : [3]</span><br><span class="line">pop we got : [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]</span><br><span class="line">push(9, stack) we got : [9][]-&gt; [3][]-&gt; [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]</span><br></pre></td></tr></table></figure>
<p>Primitive operators<br>1) Constructors</p>
<ul>
<li>emptyStack</li>
<li>push(element, stack) : return a stack, push item at the top</li>
</ul>
<p>2) Selectors</p>
<ul>
<li>top(stack) : return the top most element of a stack.</li>
<li>pop(stack) : return the stack without the top most element.</li>
</ul>
<p>3) Condition</p>
<ul>
<li>isEmpty(Stack)</li>
</ul>
<p><strong>Queues</strong><br>def : data structure used to model a First-In-First-Out (FIFO) strategy. Conceptually, we add to the end of a queue and take away elements from its front.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[3][]-&gt; [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]  </span><br><span class="line">top we got : [3]</span><br><span class="line">pop we got : [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]</span><br><span class="line">push(9, queue) we got : [3][]-&gt; [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][]-&gt; [9][/]</span><br></pre></td></tr></table></figure>
<p>Primitive operators<br>1) Constructors</p>
<ul>
<li>emptyQuene</li>
<li>push(element, queue) : return a queue, push the item at the tail</li>
</ul>
<p>2) Selectors</p>
<ul>
<li>top(queue) : return the top element of a queue.</li>
<li>pop(queue) : return the queue without the top most element.</li>
</ul>
<p>3) Condition</p>
<ul>
<li>isEmpty(queue)</li>
</ul>
<p>NOTE : as we can see, the only difference between a stack and a queue is the mothod of push.</p>
<p><strong>Doubly linked lists</strong><br>def : a doubly linked list is a list which has two pointers on each cell. Unlike a linked list, we think it as web pages which has each page containing previous page and next page.<br>&nbsp;<br>Primitive operators<br>1) Constructors</p>
<ul>
<li>emptyList</li>
<li>MakeListLeft(element, list) : return a new DLL containing the new element on the left</li>
<li>MakeListRight(element, list) : return a new DLL containing the new element on the right</li>
</ul>
<p>2) Selectors</p>
<ul>
<li>firstLeft(list)</li>
<li>restLeft(list)</li>
<li>firstRight(list)</li>
<li>restRight(list)</li>
</ul>
<p>3) Condition</p>
<ul>
<li>isEmpty(list)</li>
</ul>
<p>Circular doubly linked list : it is a DLL which connects the left-most element to the right-most elements with two pointers.</p>
<h2 id="Efficiency-amp-amp-Complexity"><a href="#Efficiency-amp-amp-Complexity" class="headerlink" title="Efficiency &amp;&amp; Complexity"></a>Efficiency &amp;&amp; Complexity</h2><p><strong>Time and Space complexity</strong><br>time complexity : how much the excution time is required, depending on the size of the data stucture.<br>space complexity : how much the memory space is required, depending on the size of the data structure<br>&nbsp;<br>NOTES:</p>
<ul>
<li>In general, we consider complexity of the psuedocodes or algorithms.</li>
<li>we need to make a balance between time complexity and space complexity.</li>
</ul>
<p><strong>Worst and Average case</strong><br>Average case is more important when saving time overall needs to be guaranteed.<br>Worst case is more important when we are dealing with time-critical problems such as airplane application.<br>&nbsp;<br>NOTE : the most efficient algorithm on average might have a particulaly bad worst case efficiency.</p>
<p><strong>Big-Oh notation</strong><br>def : we ONLY complexity ignoring any constant factors and small arguments. This wll just tell us the principal growth of the complexity function with problem size.<br>&nbsp;<br>Usually, we compute the complexity based on the number of loops and how often the content of those loops are being executed.<br>&nbsp;<br>The most common complexity classes :</p>
<ul>
<li>constant complexity    : O(1)</li>
<li>logarithmic complexity : O(log2(n))</li>
<li>linear complexity      : O(n)</li>
<li>quadratic complexity   : O(n^2)</li>
<li>cubic complexity       : O(n^3)</li>
<li>exponential complexity : O(2^n)</li>
</ul>
<p>It is easier to see the growth of each class of complexity by doubling the size :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f(n)            | If the size of the problem doubles then f(n) will be </span><br><span class="line">----------------|-----------------------------------------------------------</span><br><span class="line">  1             |  the same,                                 f(2n) = f(n)</span><br><span class="line">log2(log2(n))   |  almost the same,                          log2(log2(2n)) = log2 (log2 (n) + 1)</span><br><span class="line">log2(n)         |  more by 1=log2(2),                        f(2n) = f(n)+1</span><br><span class="line">  n             |  twice as big as before,                   f(2n) = 2 * f(n)</span><br><span class="line">nlog2n          |  a bit more than twice as big as before,   2nlog2 (2n) = 2(nlog2 n) + 2n</span><br><span class="line"> n^2            |  four times as big as before,              f(2n) = 4 * f(n)</span><br><span class="line"> n^3            |  eight times as big as before,             f(2n) = 8 * f(n)</span><br><span class="line"> 2^n            |  the square of what it was before,         f(2n) = (f(n))^2</span><br></pre></td></tr></table></figure>
<p>NOTE : computation - exact and approximate</p>
<h2 id="Trees-general-binary-quad-trees"><a href="#Trees-general-binary-quad-trees" class="headerlink" title="Trees - general, binary, quad trees"></a>Trees - general, binary, quad trees</h2><p><strong>General definition of trees</strong><br>def : a tree contains nodes and edges. Nodes are usually labelled by a search keys(int, String…).<br>&nbsp;<br>Terminology: </p>
<ol>
<li>root</li>
<li>parent (ancestor)</li>
<li>children (descendent)</li>
<li>siblings</li>
<li>leaves</li>
<li>path</li>
<li>height of the tree</li>
<li>size of the tree</li>
</ol>
<p>Representation: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    [8]   ......... root (parent of 3 and 11)   - level 0</span><br><span class="line">  /     \</span><br><span class="line">[3]     [11]  ..... children (of 8)             - level 1</span><br><span class="line">   \    /   \</span><br><span class="line">  [6] [9]  [14] ... leaves                      - level 2</span><br><span class="line">        </span><br><span class="line">height = 2</span><br><span class="line">size = 6</span><br></pre></td></tr></table></figure>
<p><strong>Quad-trees</strong><br>def: a quadtree is a tree in which each-leaf is labelled by a value and each non-leaf node has exactly four children.<br>&nbsp;<br>inductive definition :</p>
<ol>
<li>a root node with a value, or</li>
<li>a root node without a value but with four quad tree children : lu,ll,ru,rl</li>
</ol>
<p>NOTE: here we use “root node” because every sub-tree is itself a quadtree<br>&NBSP;<br>Presentation: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> __________________________</span><br><span class="line">|            |             |</span><br><span class="line">|            |             |</span><br><span class="line">|     0      |     10      |</span><br><span class="line">|            |             |</span><br><span class="line">|            |             |</span><br><span class="line">|------------|-------------|</span><br><span class="line">|     | 1| 3 |             |</span><br><span class="line">| 30  |--|---|             |</span><br><span class="line">|-----|------|     12      |</span><br><span class="line">| 40  |  2   |             |</span><br><span class="line">|_____|______|_____________|</span><br></pre></td></tr></table></figure>
<p>Primitive operations:<br>1) Constructors</p>
<ul>
<li>baseQT(value): return a single node with label value</li>
<li>makeQT(luqt,ruqt,llqt,rlqt): return a quadtree with four nodes</li>
</ul>
<p>2) Selectors</p>
<ul>
<li>lu(qt): return the left-upper quadtree</li>
<li>ll(qt): return the left-lower quadtree</li>
<li>ru(qt): return the right-upper quadtree</li>
<li>rl(qt): return the right-lower quadtree</li>
</ul>
<p>3) Condition</p>
<ul>
<li>isValue(qt): return true if quadtree qt is a single node</li>
</ul>
<p>Rotate a quadtree by 180 degrees: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rotate(qt)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isValue(qt))</span><br><span class="line">        <span class="keyword">return</span> qt;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> makeQT(rotate(rl(qt)), rotate(ll(qt)),</span><br><span class="line">                      rotate(ru(qt)), rotate(lu(qt)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NOTE: similar idea arises from averaging the values of qt.</p>
<p><strong>Binary trees</strong><br>def: a binary tree is a tree in which each node has at most two children.<br>&nbsp;<br>inductive def:</p>
<ol>
<li>the empty tree EmptyTree, or</li>
<li>it consists of a node and two binary trees(left subtree and right subtree)</li>
</ol>
<p>Primitive operations:<br>1) Constructors</p>
<ul>
<li>EmptyTree: return an empty tree</li>
<li>makeTree(v,l,r) : return a binary tree with a root node and two sub-trees</li>
</ul>
<p>2) derived Constructor</p>
<ul>
<li>Leaf(v) = MakeTree(v,EmptyTree,EmptyTree)</li>
</ul>
<p>3) Selectors</p>
<ul>
<li>root(t): return the value of the root node of t</li>
<li>left(t): return the left sub-tree</li>
<li>right(t): return the right sub-tree</li>
</ul>
<p>4) Condition</p>
<ul>
<li>isEmpty(t): return true if the binary tree t is the EmptyTree</li>
</ul>
<p>NOTE: This primitive operators are what expected to be covered when we created a tree class.<br>&nbsp;<br>Abstract data types : without focusing on the details of the data or the implementation, it is a general principle of how to construct and destruct the data type.</p>
<p><strong>Height of a binary tree</strong><br>Many tree-based applications, for example searching, take as many steps as the height of the tree, so minimizing the height minimizes the time needed to perform those operations.<br>&nbsp;<br>size   : s(h) = 2^(h+1) - 1<br>height : h(s) = log2(s+1) - 1 = log2(s)<br>&nbsp;<br>NOTE : height is computed as log2(n) when the tree is balanced.</p>
<p><strong>Size of a binary tree</strong><br>size of a tree :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size(t)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(t))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> + size(left(t)) + size(right(t)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h2><p>one possible implementation of a binary tree is binary search tree, which provide an efficient way of sorting data that allows particular items to be found as quickly as possible.<br>&nbsp;<br>def : BST is a binary tree that is either an emptyTree or satisfies the following :</p>
<ol>
<li>all search keys occuring in the left subtree are smaller than that of the root</li>
<li>all search keys occuring in the right subtree are larger than that of the root</li>
<li>the left and right subtrees are themselves binary search trees(1 and 2 still hold)</li>
</ol>
<p>NOTE : As to a BST, it does not matter what the root node is, we simply want to determine, if given a key, where the key is located on the tree.</p>
<p><strong>Building binary search trees</strong><br>one naturally starts with the root and then adds further new nodes as needed. we have two cases :</p>
<ul>
<li>if the given tree is empty then simply assigin the new value v to the root, and leave the left and right subtrees empty</li>
<li>if the given tree is nonempty, then a node is inserted to :<ol>
<li>the left subtree if it is smaller than the root</li>
<li>the right subtree if it is larger than the root</li>
<li>nowhere but we throw exception</li>
</ol>
</li>
</ul>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">insert(v, bst)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(bst))</span><br><span class="line">        <span class="keyword">return</span> MakeTree(v,emptyTree,emptyTree);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v &lt; root(bst))</span><br><span class="line">        <span class="keyword">return</span> MakeTree(v,insert(v,left(bst)),right(bst));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v &gt; root(bst))</span><br><span class="line">        <span class="keyword">return</span> MakeTree(v,left(bst),insert(v,right(bst)));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"violated assumption in procedure insert(v equals :)"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NOTE : this algorithm made a new tree based on bst. the original tree bst is not modified, it is merely inspected(被巡视). When we are dealing with a large database, it is more efficient to modify the given tree, rather than to construct a whole new tree.</p>
<p><strong>Searching a BST</strong><br>Algorithm in pseudocode :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">search(n, bst)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(bst))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; root(bst))</span><br><span class="line">        <span class="keyword">return</span> search(n,left(bst));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; root(bst))</span><br><span class="line">        <span class="keyword">return</span> search(n,right(bst));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>or we can use a while-loop :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">search(n,bst)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(bst) &amp;&amp; n != root(bst))&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; root(bst))</span><br><span class="line">            t = left(bst);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; root(bst))</span><br><span class="line">            t = right(bst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !isEmpty(bst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Time complexity of searching and inserting</strong><br>Searching :</p>
<ul>
<li>average case = O(log2(n))</li>
<li>worst case = O(n)</li>
</ul>
<p>Inserting :</p>
<ul>
<li>average case = O(log2(n))</li>
<li>worst case = O(n)</li>
</ul>
<p>NOTE : if BST is perfectly balanced, the worst cases are both O(log2(n))</p>
<p><strong>Deleting</strong><br>in order to perform better than O(n x log2(n)) or better than O(n), we design the following procedures :</p>
<ol>
<li>if the node in question is a leaf, just remove it</li>
<li>if only one of the node’s subtree is non-empty, move up the remaining subtree</li>
<li>if the node has two non-empty sub-trees, find the left-most leaf on the right subtree(this has the smallest key in the right sub-tree). Use this to overwrite the node we deleted. replace the left-most node by its right subtree, if this exists; otherwise just delete it.</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">delete(value v, tree t)&#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(t))</span><br><span class="line">    error(<span class="string">"error : given item is not in the given tree"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(v &lt; root(t))</span><br><span class="line">      <span class="keyword">return</span> MakeTree(root(t),delete(v,left(t)),right(t));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v &gt; root(t))</span><br><span class="line">      <span class="keyword">return</span> MakeTree(root(t),left(t),delete(v,right(t)));</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// v is the root(t)</span></span><br><span class="line">      <span class="keyword">if</span>(isEmpty(left(t)))</span><br><span class="line">        <span class="keyword">return</span> right(t);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(isEmpty(right(t)))</span><br><span class="line">        <span class="keyword">return</span> left(t);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> MakeTree(smallestNode(right(t))),left(t),removeSmallestNode(right(t));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smallestNode(tree t)&#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(left(t)))</span><br><span class="line">    <span class="keyword">return</span> root(t);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> smallestNode(left(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">removeSmallestNode(tree t)&#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(left(t)))</span><br><span class="line">    <span class="keyword">return</span> right(t);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> MakeTree(root(t),removeSmallestNode(left(t)), right(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Complexity : O(log2(n))</p>
<p><strong>Sorting using binary search tree</strong></p>
<p>print the nodes in order :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printInOrder(tree t)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(t))&#123;</span><br><span class="line">    printInOrder(left(t));</span><br><span class="line">    print(root(t));</span><br><span class="line">    printInOrder(right(t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if there is a collection of items stored in an array with size n, they can be printed in sorted order :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sort(T[] a)&#123;</span><br><span class="line">  t = emptyTree;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">    t = insert(a[i],t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printInOrder(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Balancing BST</strong><br>Reason : more balance the tree is, less time taken to search/insert/delete the tree<br>Tree balance : for each level, the tree is completely filled with as many nodes as possible.<br>Tree rotation : to rebalance the tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     [D]               [B]</span><br><span class="line">    /   \    ----&gt;    /   \</span><br><span class="line">  [B]   [E]  &lt;----  [A]   [D]</span><br><span class="line">  / \                     / \</span><br><span class="line">[A] [C]                 [C] [E]</span><br></pre></td></tr></table></figure>
<p><strong>Exercises</strong><br>Ex1. Qns 6.  (To build all possible trees among {1,2,3,4}<br>Ex2 ,Qns 3 &amp; 4, check whether is a BST or tree</p>
<h2 id="Binary-Heap-Trees-and-Priority-queues"><a href="#Binary-Heap-Trees-and-Priority-queues" class="headerlink" title="Binary Heap Trees and Priority queues"></a>Binary Heap Trees and Priority queues</h2><p>Completeness : A binary tree is complete if every level, except possibly the last, is completely filled, and all the leaves on the last level are placed as far to the left as possible.<br>&nbsp;<br>dif : unlike BST, a binary heap tree is a binary tree with each node labelled by a priority number(the higher number is labelled, the higher priority the node is). So, the root is the biggest number and it holds for left and right heap subtrees. The left and right subtrees are interchangable in binary heap trees.<br>&nbsp;<br>def : a binary heap tree is a complete binary tree which is either empty or satisfies the following :</p>
<ol>
<li>the priority of the root is higher than or equal to that of its children</li>
<li>the left and right subtrees of the root are heap trees themselves</li>
</ol>
<p><strong>Basic operations</strong><br>to construct a heap tree we need :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MAX = <span class="number">100</span>      <span class="comment">// Maximum number of nodes allowed</span></span><br><span class="line"><span class="keyword">int</span> heap[MAX + <span class="number">1</span>]  <span class="comment">// Store priority values of nodes + empty of heap tree;  </span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>          <span class="comment">// Largest position that has been filled so far</span></span><br></pre></td></tr></table></figure>
<p>for heap trees to be a useful representation of priority queues, we need</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">insert(<span class="keyword">int</span> p, array heap, <span class="keyword">int</span> n)</span><br><span class="line">delete(<span class="keyword">int</span> i, array heap, <span class="keyword">int</span> n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(array heap, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heapEmpty(heap,n))</span><br><span class="line">      error(<span class="string">"heap is empty"</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> heap[<span class="number">1</span>];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">heapEmpty</span><span class="params">(array heap, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span>;  <span class="comment">// we use n = 0 to represent an empty heap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastLeaf</span><span class="params">(array heap, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heapEmpty(heap,n))</span><br><span class="line">      <span class="keyword">return</span> error(<span class="string">"heap is empty"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> heap[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Inserting a new heap tree node</strong><br>Procedure :</p>
<ol>
<li>insert the new node into the last position n+1</li>
<li>bubble up the node to the right position by comparing priority with parent node</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">insert(<span class="keyword">int</span> p, array heap, <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == MAX)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"error: heap is full"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      heap[++n] = p;           <span class="comment">// O(1)</span></span><br><span class="line">      bubbleUp(n, heap, n);    <span class="comment">// O(log2(n))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bubbleUp(<span class="keyword">int</span> i, array p, <span class="keyword">int</span> n)&#123;</span><br><span class="line">  <span class="keyword">if</span>(isRoot(i)) <span class="comment">// i has the highest priority</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(heap[i] &gt; heap[parent(i)])&#123;</span><br><span class="line">    swap heap[i] and heap[parent(i)]</span><br><span class="line">    bubbleUp(parent(i),heap,n); </span><br><span class="line">    <span class="comment">// the parent of parent of i is now being the parent of i</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worst case &amp; average case of time Complexity = O(log2(n))</p>
<p><strong>Deleting a heap tree node</strong><br>Procedure :</p>
<ol>
<li>replace the node we want to delete by the last node</li>
<li>bubble up or bubble down the node to achive the correct priority order</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="keyword">int</span> i, array p, <span class="keyword">int</span> n)&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; i)</span><br><span class="line">    error(<span class="string">"empty tree, unable to delete"</span>);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    heap[i] = heap[n];</span><br><span class="line">    bubbleUp(i,heap,n-<span class="number">1</span>);</span><br><span class="line">    bubbleDown(i,heap,n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bubbleDown(<span class="keyword">int</span> i, array heap, <span class="keyword">int</span> n)&#123;</span><br><span class="line">  <span class="keyword">if</span>(left(i) &gt; n)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(right &gt; n)  <span class="comment">// left(i) &lt;= n; only one children</span></span><br><span class="line">    <span class="keyword">if</span>(heap[i] &lt; heap[left(i)])</span><br><span class="line">      swap heap[i] and heap[left(i)];</span><br><span class="line">  <span class="keyword">else</span>                <span class="comment">// two children</span></span><br><span class="line">    <span class="keyword">if</span>(heap[left(i)] &gt; heap[right(i)] &amp;&amp; heap[i] &lt; heap[left(i)])</span><br><span class="line">      swap heap[i] and heap[left(i)]</span><br><span class="line">      bubbleDown(left(i),heap,n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(heap[i] &lt; heap[right])</span><br><span class="line">      swap heap[i] and heap[right(i)]</span><br><span class="line">      bubbleDown(right(i),heap,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worst case &amp; average case of time Complexity = O(log2(n))</p>
<p><strong>Building a new heap tree</strong><br>Sometimes we have a set of items that we wish to heapify. One obvious possibility would be to insert the n items one by one into a heap tree, starting from an empty tree, using the O(log2 n) ‘bubble up’ based insert algorithm discussed earlier. That would clearly have overall time complexity of O(nlog2 n).<br>It turns out, however, that rearranging an array of items into heap tree form can be done more efficiently using “bubble down”. It potentially bubbles down [n/2] items. So the complexity at most is (n/2)log2(n) = nlog2(n).<br>&nbsp;<br>Precisely :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C(h) =  Σ(for each level i) 2^i * (h - i) = 2^h * Σ (h - i)/2^(h-i)</span><br><span class="line">C(h) = 2^h * Σ j/2^j = 2^h * 2 = 2^(h+1) = n</span><br></pre></td></tr></table></figure>
<p>hence, the complexity of heapify is actually O(n), by using bubble down.</p>
<p><strong>Merging binary heap trees</strong><br>Method 1 :<br>Move all the items from the smaller heap tree one at a time into the larger heap tree using the standard insert algorithm. This will involve moving O(n) items, and each of them will need to be bubbled up at cost O(log2 n), giving an overall time complexity of O(nlog2 n).<br>Method 2 :<br>Repeatedly move the last items from one heap tree to the other using the standard insert algorithm, until the new binary tree makeTree(0,t,s) is complete. Then move the last item of the new tree to replace the dummy root “0”, and bubble down that new root. How this is best done will depend on the sizes of the two trees, so this algorithm is not totally straightforward. On average, around half the items in the last level of one tree will need moving and bubbling, so that will be O(n) moves, each with a cost of O(log2 n), again giving an overall time complexity of O(nlog2 n). However, the actual number of operations required will, on average, be a lot less than the previous approach, by something like a factor of four, so this approach is more efficient.<br>Method 3 :<br>Simply concatenate the array forms of the heap trees s and t and use the standard heapify algorithm to convert that array into a new binary heap tree. The heapify algorithm has time complexity O(n), and the concatenation need be no more than that, so this approach has O(n) overall time complexity, making it in the best general approach of all three.<br>&nbsp;<br>NOTE : to decide which one we use, it depends on the sizes of two heap trees. </p>
<p><strong>Binomial heaps</strong><br>def : a binomial heap is more efficient than BHT when inserting and merging.<br>&nbsp;<br>inductive def : a binomial tree is defined recursively as follows :</p>
<ol>
<li>a binomial tree of order 0 is a single node</li>
<li>a binomial tree of order k has a root node with children that are roots of binomial trees of orders k-1, k-2, …, 2, 1, 0 (in that order)</li>
</ol>
<p>Representation :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k    0     1       2             3</span><br><span class="line">    [ ]   [ ]     [ ]         [     ]</span><br><span class="line">           |      / |        /  /   |</span><br><span class="line">          [ ]   [ ] [ ]    [ ] [ ] [ ]</span><br><span class="line">                           / |   |</span><br><span class="line">                        [ ] [ ] [ ]</span><br></pre></td></tr></table></figure>
<p>height : k<br>size   : 2^k</p>
<p>A binomial heap is constructed as a collection of binomial trees with a particular structure and node ordering properties :</p>
<ol>
<li>there can only be zero or one binomial tree of each order</li>
<li>each constituent binomial tree must satisfy the priority ordering property i.e. each node must have priority less than or equal to its parent</li>
</ol>
<p>merging : time complexity = O(log2(n))<br>inserting : time complexity = O(1)<br>heapify : O(n)<br>deleting : time complexity = O(log2(n))</p>
<h2 id="Sorting-strategies-Sorting-algotithem-stability"><a href="#Sorting-strategies-Sorting-algotithem-stability" class="headerlink" title="Sorting strategies, Sorting algotithem stability"></a>Sorting strategies, Sorting algotithem stability</h2><p><strong>General definitions and theoretical limits</strong><br>Comparison-based :</p>
<ul>
<li>enumeration sorting</li>
<li>exchange sorting </li>
<li>selection sorting </li>
<li>insertion sorting</li>
<li>divide and conquer</li>
<li>comparison-based </li>
</ul>
<p>lower bound for comparison-based algorithms : O(nlog2(n))<br>&nbsp;<br>Noncomparison-based</p>
<p><strong>BubbleSort, insertion sort, selection Sort</strong><br>BubbleSort : exchange sorting</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt; n ; i++ )</span><br><span class="line">  <span class="keyword">for</span> ( j = n-<span class="number">1</span> ; j &gt;= i ; j-- ) <span class="comment">// dif with insertion sort</span></span><br><span class="line">    <span class="keyword">if</span> ( a[j] &lt; a[j-<span class="number">1</span>] )</span><br><span class="line">       swap a[j] and a[j-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>time complexity :</p>
<ul>
<li>worst case : O(n^2)</li>
<li>average case : O(n^2)</li>
</ul>
<p>InsertionSort : insertion sorting</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt; n ; i++ ) &#123;</span><br><span class="line">  <span class="keyword">for</span>( j = i ; j &gt; <span class="number">0</span> ; j-- )    <span class="comment">// dif with bubble sort</span></span><br><span class="line">    <span class="keyword">if</span> ( a[j] &lt; a[j-<span class="number">1</span>] )</span><br><span class="line">       swap a[j] and a[j-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time complexity :</p>
<ul>
<li>worst case : O(n^2)</li>
<li>average case : O(n^2)</li>
</ul>
<p>SelectionSort : selection sorting</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; n-<span class="number">1</span> ; i++ ) &#123; </span><br><span class="line"></span><br><span class="line"> k = i</span><br><span class="line"> <span class="keyword">for</span> ( j = i+<span class="number">1</span> ; j &lt; n ; j++ )</span><br><span class="line">    <span class="keyword">if</span> ( a[j] &lt; a[k] )</span><br><span class="line">      k = j</span><br><span class="line">      swap a[i] and a[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time complexity :</p>
<ul>
<li>worst case : O(n^2)</li>
<li>average case : O(n^2)</li>
</ul>
<p>Comparison between bubble, insertion, selection sortings:</p>
<ol>
<li>bubble sorts does a lot of swaps</li>
<li>if there is a few items are misplaced, insertionSort performs very quick</li>
<li>in general selectionSort is better than insertionSort is better than bubbleSort</li>
</ol>
<p>Stability between bubble, insertion, selection sortings: (when considering identical keys [2,1] [2,2])</p>
<ul>
<li>bubbleSort is stable</li>
<li>InsertionSort is stable</li>
<li>SelectionSort is unstable</li>
</ul>
<p><strong>TreeSort, HeapSort</strong><br>TreeSort procedure :</p>
<ol>
<li>build an empty BST, insert each a[i] into it</li>
<li>use a method to fill nodes into an array in order</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">treeSort(array a)&#123;</span><br><span class="line">  t = emptyTree;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">    t = insert(a[i],t);    <span class="comment">// log2(n)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fillArray(t,a,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fillArray(tree t, array a, <span class="keyword">int</span> j)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(t))&#123;</span><br><span class="line">    j = fillArray(left(t),a,j);</span><br><span class="line">    a[j++] = root(t);</span><br><span class="line">    j = fillArray(right(t),a,j);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time complexity :</p>
<ul>
<li>worst case : O(n^2) when the array given is sorted</li>
<li>average case : O(nlog2(n))</li>
</ul>
<p>HeapSort procedure :</p>
<ol>
<li>heapify the array into a BHT.</li>
<li>swap the largest root node and the smallest leaf node for each iteration.(bubble down)</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">heapSort(array a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">  heapify(a,n)</span><br><span class="line">    <span class="keyword">for</span>( j = n ; j &gt; <span class="number">1</span> ; j-- ) &#123;</span><br><span class="line">      swap a[<span class="number">1</span>] and a[j]</span><br><span class="line">      bubbleDown(<span class="number">1</span>,a,j-<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time complexity :</p>
<ul>
<li>worst case : O(nlog2(n))</li>
<li>average case : O(nlog2(n))</li>
<li>best case : O(n)</li>
</ul>
<p>HeapSort is not stable as it can change the order of identical keys.</p>
<p><strong>Devide and conquer sorting</strong><br>Quicksort procedure :</p>
<ol>
<li></li>
<li></li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>time Complexity : </p>
<ul>
<li>worst case O(n^2)</li>
<li>average case O(nlog(n))</li>
<li>best case O(n)</li>
</ul>
<p>Mergesort procedure :</p>
<ol>
<li>2.</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>time Complexity : </p>
<ul>
<li>worst case O(nlog(n))</li>
<li>average case O(nlog(n))</li>
</ul>
<p>quickSort代码: <a href="https://blog.51cto.com/flyingcat2013/1281614" target="_blank" rel="noopener">https://blog.51cto.com/flyingcat2013/1281614</a><br>mergeSort代码: <a href="https://blog.csdn.net/javyzheng/article/details/12377585" target="_blank" rel="noopener">https://blog.csdn.net/javyzheng/article/details/12377585</a></p>
<p><strong>Non-comparision : Radix sort</strong></p>
<p><strong>Comparisons</strong></p>
<h2 id="Hash-Tables"><a href="#Hash-Tables" class="headerlink" title="Hash Tables"></a>Hash Tables</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h(KEY) -&gt; position</span><br><span class="line">[K0][K1][K2][K3][K4][K5][K6][K7]</span><br></pre></td></tr></table></figure>
<p>&nbsp; if two keys goes to the same position, it is called <code>collision</code>(散列冲突)</p>
<p>Collision likelihoods and load factors for hash tables<br><code>q(n)= 364·363···(366 - n) / 365^(n-1) = 1 - p(n)</code><br>&nbsp; - prob(not colli 3) = (364*363)/365^2 = 1 - prob(colli)</p>
<p>strategies to deal with collisions<br>&nbsp; Buckets: build a two dimension array<br>&nbsp; Direct chaining: build a linked list<br>&nbsp; open addressing: linear probing &amp; double hashing</p>
<p><code>linear probing</code>: 线性探查法<br>&nbsp; <strong>def:</strong> if there is a collision, reduce index by 1 and insert. As a ring.<br>&nbsp; time.Compx = O(1)</p>
<p><code>double hashing</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( (k/<span class="number">11</span>)%<span class="number">11</span> !=<span class="number">0</span> ) &#123;</span><br><span class="line">    h2(n) = (k/<span class="number">11</span>)%<span class="number">11</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    h2(n) = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp; try every <em>h2(n) steps</em> to the left until a empty location is found<br>&nbsp; time.Compx = o(1)</p>
<h2 id="Graphs"><a href="#Graphs" class="headerlink" title="Graphs"></a>Graphs</h2><p>1.Array-based implementation<br>2.Mixed implementation<br>3.Pointer-based implementation</p>
<p>Relations between graphs</p>
<p>Planarity<br>K5 K3,3<br>&nbsp; planar and non-planar graph</p>
<p>Traversals</p>
<p><strong>Dijkstra’s algorithm:</strong> shortest path from one specific node to all other nodes<br>version I : use <em>boolean array</em> tight<br>version II : <em>priority queue</em> of tight</p>
<p><strong>Floyd’s algorithm:</strong> shortest path between each pair of nodes</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store initial estimates and predecessors.</span></span><br><span class="line">   <span class="keyword">for</span> ( each vertex s ) &#123;</span><br><span class="line">       <span class="keyword">for</span> ( each vertex z ) &#123;</span><br><span class="line">           distance[s][z] = weight[s][z]</span><br><span class="line">           predecessor[s][z] = s</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Improve them by considering all possible shortcuts u.</span></span><br><span class="line">   <span class="keyword">for</span> ( each vertex u ) &#123;</span><br><span class="line">       <span class="keyword">for</span> ( each vertex s ) &#123;</span><br><span class="line">           <span class="keyword">for</span> ( each vertex z ) &#123;</span><br><span class="line">               <span class="keyword">if</span> ( distance[s][u]+distance[u][z] &lt; distance[s][z] ) &#123;</span><br><span class="line">                  distance[s][z] = distance[s][u]+distance[u][z]</span><br><span class="line">                  predecessor[s][z] = predecessor[u][z]</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Greedy algorithms:<br>an algorithm is greedy if it makes its decision based only on what is based on ‘local considerations’ without considering overall result</p>
<p>Minimal spanning trees(最小生成树)<br>prim’s algorithm: A greedy <strong>vertex-based</strong> approach<br>Kruskal’s algorithm: A greedy <strong>edge-based</strong> approach.</p>

	
	</div>
  <a type="button" href="/2019/02/20/[DataStructure]01/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/02/20/[DataStructure]02/">Programming part</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-02-20  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>I will provide source code on github.</p>
<h2 id="GIT-testing-Set-up-eclipse"><a href="#GIT-testing-Set-up-eclipse" class="headerlink" title="GIT, testing, Set up eclipse"></a>GIT, testing, Set up eclipse</h2><p>log<br>testing<br>junit<br>debug<br>javaDoc<br><a href="http://www.runoob.com/eclipse/eclipse-debug-configuration.html" target="_blank" rel="noopener">http://www.runoob.com/eclipse/eclipse-debug-configuration.html</a>  </p>
<h2 id="Assignments"><a href="#Assignments" class="headerlink" title="Assignments"></a>Assignments</h2><p>ass1:<br>ass2: <em>Stack &amp; Queue</em><br>ass3: <em>Binary Tree</em><br>ass4: <em>Merge Sort</em><br>ass5: <em>Graph</em></p>

	
	</div>
  <a type="button" href="/2019/02/20/[DataStructure]02/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/02/19/[AI]12_lejos/">Lejos-based programming</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-02-19  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>This part of the module is fully based on LEGO EV3. To be more precise, we are using lejos API to acheive some functionalities on a robot. I have uploaded source code of some contents to my github.</p>
<h2 id="Robot-sensors"><a href="#Robot-sensors" class="headerlink" title="Robot sensors"></a>Robot sensors</h2><p><strong>Color sensor</strong><br>def: sensor used to determine color.<br>.ColorIDMode<br>.ColorRGBMode<br>.AmbientMode</p>
<p><strong>Ir_Sensor</strong><br>Low precision</p>
<p><strong>Ultra_sonic_Sensor</strong><br>High precision</p>
<p><strong>Touch_Sensor</strong><br>def: sensor used to detect pressure. if pressed, return 1 else 0.</p>
<h2 id="Robot-Motors"><a href="#Robot-Motors" class="headerlink" title="Robot Motors"></a>Robot Motors</h2><p><strong>Large Motors</strong><br>def: api used to control left and right wheels.</p>
<p><strong>pilot</strong><br>def : api used to control robot to move. Compared to Motor api, this has great advantage when we control the robot turning.</p>
<h2 id="Arbitrator"><a href="#Arbitrator" class="headerlink" title="Arbitrator"></a>Arbitrator</h2><p>Behavior</p>
<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><p><strong>Waypoint</strong><br>def: </p>
<p><strong>Heading</strong><br>def: </p>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><ul>
<li>Topology map</li>
<li>metric map</li>
<li>cell-based map</li>
<li>occupancy grids: 0-empty; 1-occupied</li>
</ul>
<h2 id="Robot-wifi-connection"><a href="#Robot-wifi-connection" class="headerlink" title="Robot wifi connection"></a>Robot wifi connection</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> host A                 host B</span><br><span class="line">    |                     |</span><br><span class="line">server socket &lt;-------&gt; socket</span><br><span class="line">            |        </span><br><span class="line">          port1234</span><br><span class="line">  (server: robot)         (client: PC)</span><br></pre></td></tr></table></figure>
<h2 id="Communication-between-Server-and-Client"><a href="#Communication-between-Server-and-Client" class="headerlink" title="Communication between Server and Client"></a>Communication between Server and Client</h2><p>Server: robot as the server sending infomation to Eclipse console.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">import lejos.hardware.Battery;</span><br><span class="line"></span><br><span class="line">public class EV3Server &#123;</span><br><span class="line">    public static final int port = 1234;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket server = new ServerSocket(port);</span><br><span class="line">        System.out.println(&quot;Awaiting client..&quot;);</span><br><span class="line">        Socket client = server.accept();</span><br><span class="line">        System.out.println(&quot;CONNECTED&quot;);</span><br><span class="line">        OutputStream out = client.getOutputStream();</span><br><span class="line">        DataOutputStream dOut = new DataOutputStream(out);</span><br><span class="line">        dOut.writeUTF(&quot;Battery: &quot; + Battery.getVoltage());</span><br><span class="line">        dOut.flush();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client: PC as the client receiving infomation from EV3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line"></span><br><span class="line">public class PCClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String ip = &quot;10.0.1.1&quot;; // BT</span><br><span class="line">        if(args.length &gt; 0)ip = args[0];</span><br><span class="line">        Socket sock = new Socket(ip, EV3Server.port);</span><br><span class="line">        System.out.println(&quot;Connected&quot;);</span><br><span class="line">        InputStream in = sock.getInputStream();</span><br><span class="line">        DataInputStream dIn = new DataInputStream(in);</span><br><span class="line">        String str = dIn.readUTF();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        sock.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2019/02/19/[AI]12_lejos/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2019/02/19/[Logic]01_propositionalLogic/">Classical Logic - Propositional logic</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2019-02-19  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h2><p><strong>proposition</strong><br>def: a sentence which states a fact which can be true or false.<br>&nbsp;<br>Atomic propositions(atoms): </p>
<ul>
<li>propositions that cannot be broken into smaller parts</li>
<li>they are usually represented by symbols(P, Q, R…)</li>
</ul>
<p><strong>argument</strong><br>def: argument is a collection of propositions<br>&nbsp;<br>an argument can have 0 and more premises and 1 conclusion.<br>&nbsp;<br>Validity: an argument is valid iff its premises are true and its conclusion is true.</p>
<p><strong>Languages</strong><br>Semantics: the meaning of a formula in the language<br>Syntax: rules defining allowable formulas(sentences) in the language<br>&nbsp;<br>formula:  </p>
<ul>
<li>Atomic formula   : if P is an atomic proposition, then P is a formula</li>
<li>Compound formula : if P and Q are formulas then so are ¬P, P ∧ Q, P ∨ Q and P -&gt; Q</li>
</ul>
<p>these are all called well-formed formulas.</p>
<p><strong>Connectives</strong><br>conjunction ∧ : and<br>disjunction ∨ : or<br>negation    ¬ : not<br>implication -&gt; : implies<br>&nbsp;<br>Avoid ambiguity using parentheses <code>()</code> : (P ∧ Q) ∨ R<br>&nbsp;<br>Precedence of connectives: (¬) &gt; (∧) &gt; (∨) &gt; (-&gt;)</p>
<p><strong>Parse trees</strong><br>def: we can use a tree to represent the syntactic structure of a sentence. For propositional logic, leaf nodes are atomic propositions and no-leaf nodes are connectives.<br>&nbsp;<br>Terminology: </p>
<ul>
<li>scope of a connective : connective itself and what it connects i.e. P -&gt; Q</li>
<li>main connective: the connective which connects the whole furmula</li>
</ul>
<p>scope = sub-tree<br>main connectice: root node</p>
<p><strong>Formal language</strong><br>Given an argument: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if John is at home, then his TV is on.</span><br><span class="line">His TV is not on.</span><br><span class="line">Therefore John is not at home.</span><br></pre></td></tr></table></figure>
<p>Collect atomic propositions: </p>
<ol>
<li>H = “John is at home”</li>
<li>O = “John’s TV is on”</li>
</ol>
<p>Argument in propositional logic: </p>
<ol>
<li>premise 1 : H -&gt; O</li>
<li>premise 2 : ¬O</li>
<li>conclusion : ¬H</li>
</ol>
<p>Written in sequent: H -&gt; O, ¬O : ¬H<br>&nbsp;<br>If the argument is valid we write : H -&gt; O, ¬O ⊢ ¬H</p>
<p>NOTE: When collecting atomic propositions, we only collect original symbol without any connectives. for example ‘his TV is not on’ we collect ‘his TV is on’. And for ‘Therefore John is not at home’ and ‘John is at home’ we only collect ‘John is at home’.</p>
<h2 id="Natural-Deduction"><a href="#Natural-Deduction" class="headerlink" title="Natural Deduction"></a>Natural Deduction</h2><p>def: In natural deduction, we use syntactic (rather than semantic) proof method<br>&nbsp;<br>Procedure: </p>
<ol>
<li>start with premises (we can assume these are true)</li>
<li>repeatedly apply inference rules (which preserve truth)</li>
<li>until we have inferred(推理) the conclusion</li>
</ol>
<p><strong>∧-introduction</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A   B</span><br><span class="line">-----  ∧ -introduction</span><br><span class="line">A ∧ B</span><br></pre></td></tr></table></figure>
<p><strong>∧-elimination</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A ∧ B </span><br><span class="line">-----  ∧ -elimination</span><br><span class="line">  A</span><br><span class="line"></span><br><span class="line">A ∧ B </span><br><span class="line">-----  ∧ -elimination</span><br><span class="line">  B</span><br></pre></td></tr></table></figure>
<p><strong>→-introduction</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ⊢ B </span><br><span class="line">-----  → -introduction</span><br><span class="line">A → B</span><br></pre></td></tr></table></figure>
<p><strong>→-elimination (modus ponens)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A → B  A </span><br><span class="line">--------  → -elimination</span><br><span class="line">    B</span><br></pre></td></tr></table></figure>
<p><strong>¬-introduction</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ⊢ ⊥ </span><br><span class="line">-----  ¬ -introduction</span><br><span class="line"> ¬A</span><br></pre></td></tr></table></figure>
<p><strong>¬¬-elimination</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">¬¬A </span><br><span class="line">---  ¬¬ -elimination</span><br><span class="line"> A</span><br></pre></td></tr></table></figure>
<p><strong>∨-introduction</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line">-----  ∨ -introduction</span><br><span class="line">A ∨ B</span><br><span class="line"></span><br><span class="line">  A</span><br><span class="line">-----  ∨ -introduction</span><br><span class="line">B ∨ A</span><br></pre></td></tr></table></figure>
<p><strong>∨-elimination</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ∨ B  A ⊢ C  B ⊢ C </span><br><span class="line">--------------------  ∨ -elimination</span><br><span class="line">         C</span><br></pre></td></tr></table></figure>
<h2 id="Semantics-truth-table"><a href="#Semantics-truth-table" class="headerlink" title="Semantics, truth table"></a>Semantics, truth table</h2><p><strong>Semantics of propositional logic</strong><br>An interpretation for a formula is a function I assigning a truth value to its atomic propositions.<br>&nbsp;<br>Semantics of a propositional logic formula φ is a truth value for each interpretation.<br>I ⊨ φ : I satisfies φ, where φ is true for interpretation I</p>
<p><strong>Truth table : semantic proof method</strong><br>Semantics of conjunction: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P     Q    P ∧ Q</span><br><span class="line"></span><br><span class="line">T     T      T</span><br><span class="line">T     F      F</span><br><span class="line">F     T      F</span><br><span class="line">F     F      F</span><br></pre></td></tr></table></figure>
<p>Semantics of disjunction: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P     Q    P ∨ Q</span><br><span class="line">T     T      T</span><br><span class="line">T     F      T</span><br><span class="line">F     T      T</span><br><span class="line">F     F      F</span><br></pre></td></tr></table></figure>
<p>Semantics of negation: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P    ¬P</span><br><span class="line">T     F</span><br><span class="line">F     T</span><br></pre></td></tr></table></figure>
<p>Semantics of implication: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P     Q     P → Q</span><br><span class="line">T     T       T</span><br><span class="line">T     F       F</span><br><span class="line">F     T       T</span><br><span class="line">F     F       T</span><br></pre></td></tr></table></figure>
<p>We can construct a truth table for any propostional formula.<br>example: given formula (P -&gt; Q) ∧ Q</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P   Q   |  P -&gt; Q    ¬Q     (P -&gt; Q) ∧ Q</span><br><span class="line">--------|-------------------------------</span><br><span class="line">T   T   |   T        F          F</span><br><span class="line">T   F   |   F        T          F</span><br><span class="line">F   T   |   T        F          F</span><br><span class="line">F   F   |   T        T          T</span><br></pre></td></tr></table></figure>
<p><strong>Semantic Notations</strong><br>A formula φ is</p>
<ul>
<li>Satisfiable   : iff there exists one interpretation I ⊨ φ</li>
<li>Falsifiable   : iff there exists an interpretation that makes φ false</li>
<li>Unsatisfiable : iff there is no interpretation that make I ⊨ φ</li>
<li>Valid         : iff for all interpretation that I ⊨ φ</li>
</ul>
<p>NOTE: We are talking about formulas which can be both premises and conclusions<br>&nbsp;<br>Tautology (赘述): iff it is valid i.e. P∨¬P, P→P, ¬(P∧¬P)<br>Contradiction: iff it unsatisfiable<br>Contingent (一组): iff it is both satisfiable and falsifiable i.e. P, P∧Q<br>&nbsp;<br>A formula is unsatisfiable if its negation is valid :<br>example: ¬(P ∧ ¬P)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P   ¬P  |  (P ∧ ¬P)   ¬(P ∧ ¬P)</span><br><span class="line">--------|----------------------</span><br><span class="line">T   F   |     F          T         </span><br><span class="line">F   T   |     F          T</span><br></pre></td></tr></table></figure>
<p><strong>Validity of argument</strong><br>Informally : whenever the premises are true, then so is the conclusion<br>Formally : the argument P1, .., Pn ⊨ C is valid iff every interpretation that satisfies all of the premises P1, .., Pn also satisfies the conclusion (I ⊨ Pn are true and I ⊨ C is true)</p>
<p>Steps: </p>
<ol>
<li>construct a truth table for premise(s) and conclusion.</li>
<li>when we found one that all premises are true and so is conclusion, it is valid.</li>
<li>when we found one that all premises are true and conclusion is false, it is invalid.</li>
</ol>
<p><strong>Comparison between truth table &amp; natural deduction</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true table                |   natural deduction</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">simple easy to automate   |   difficult to automate</span><br><span class="line">size is exponential       |   problem can be solved in a decent size</span><br><span class="line">invalidity can be checked |   no way to check validity</span><br><span class="line">                          |   can be adopted to predicate calculus</span><br></pre></td></tr></table></figure>
<h2 id="Proof-strategies-I"><a href="#Proof-strategies-I" class="headerlink" title="Proof strategies I"></a>Proof strategies I</h2><p><strong>Proof bt contradiction</strong><br>we can build on ¬-introduction to prove non-negated propositions.<br>&nbsp;<br>Procedure: </p>
<ol>
<li>determine what we want to prove</li>
<li>hypothesize the negation of the conclusion C</li>
<li>until we infer to ¬¬ of C</li>
<li>using ¬¬-elimination to prove C</li>
</ol>
<p><strong>Inference rules</strong><br>Strategies: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Inference rule         Premises          Concl.        Annotation numbers           Dependencies</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">∧-intro x,y             A, B              A∧B        Premises are at lines x, y        Dx ∪ Dy</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">∧-elim x                 A∧B               A         Premise is at line x              Dx</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">∨-intro x                 A               A∨B        Premise is at line x              Dx</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">∨-elim x,y1,z1,y2,z2    A∨B, A⊢C, B⊢C      C         Disjunction is at line x,       (Dx ∪ Dz1 ∪ Dz2)</span><br><span class="line">                                                     sub-proofs are lines             \ (Dy1 ∪ Dy2)</span><br><span class="line">                                                     y1-z1 and y2-z2             </span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">→-intro y,z             A⊢B               A→B        Sub-proof is lines y-z           Dz \ Dy</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">→-elim x,y              A→B, A             B         Premises are at lines x, y       Dx ∪ Dy</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">¬-intro y,z              A⊢⊥              ¬A         Sub-proof is lines y-z           Dz \ Dy</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">¬¬-elim x                ¬¬A               A          Premise is at line x             Dx</span><br></pre></td></tr></table></figure>
<p>Hints: </p>
<ol>
<li>negation introduction can prove anything as we can hypothesize something negated, if there is a contradiction can be found, then we can prove the thing we want.</li>
<li>if the conclusion is negated, try to use ¬-introduction.</li>
</ol>
<p><strong>Rules of thumb</strong></p>
<ol>
<li>If the main connective in the CONCLUSION is an implication, use implication introduction</li>
<li>If the main connective in any of the PREMISES is a disjunction, try to use disjunction elimination</li>
<li>Otherwise, try negation introduction / proof by contradiction</li>
</ol>
<p><strong>Semantic and syntactic validity</strong><br>We have seen two methods to show validity of an argument: </p>
<ul>
<li>truth table construction [semantic validity]</li>
<li>natural deduction proofs [syntax validity]</li>
</ul>
<p>Semantic validity A1, …, An ⊨ B : an argument is valid iff whenever the premises are true, and so is the conclusion (As are true so is B)<br>&nbsp;<br>Syntactic validity A1, …, An ⊢ B : an argument is valid iff the conclusion can be derived from the premises by using inference rules (B can be proved by As)</p>
<p>NOTE: if there is no premise for an argument, we automatically think the truth values are true for each interpretation of the empty premise. so to check validity of : C we only need to check truth values of C for each interpretation.</p>
<p><strong>Disproving</strong><br>arguments disproving: </p>
<ol>
<li>give a counter-example</li>
<li>this means I(premises) is true and so is I(conclusion)</li>
<li>if all true then is valid </li>
<li>if premises are true and conclusion is false then is invalid.</li>
</ol>
<p><strong>Derived rules and reiterate</strong><br>proof decomposed into parts</p>
<ul>
<li>auxiliary arguments/derived inference rules (“lemmas”)</li>
<li>proved separately</li>
<li>inserted with sequent introduction</li>
</ul>
<p>in some case we may need to use a premise again, we can apply Reiterate<br>&nbsp;<br>Useful derived rules:<br>1) Sequent introduction (LEM) : P ∨ ¬P</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--------</span><br><span class="line">| ¬(P∨¬P)     hypo            &#123;1&#125;</span><br><span class="line">|  ------</span><br><span class="line">|  |  P       hypo            &#123;2&#125;</span><br><span class="line">|  |  P∨¬P    ∨-intro 2       &#123;2&#125;</span><br><span class="line">|  |  ⊥       ∧-intro 3,1    &#123;1,2&#125;</span><br><span class="line">|  ------</span><br><span class="line">|  ¬P         ¬-intro 2,4     &#123;1&#125;</span><br><span class="line">|  P∨¬P       ∨-intro 5       &#123;1&#125;</span><br><span class="line">|  ⊥          ∧-intro 6,1     &#123;&#125;</span><br><span class="line">--------</span><br><span class="line"> ¬¬(P∨¬P)     ¬-intro 1,7     &#123;&#125;</span><br><span class="line"> P∨¬P         ¬¬-elim 8       &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Soundness and Completeness</strong><br>Soundness: any syntactically valid argument is semantically valid<br>A1, …,An ⊢B implies A1, …,An ⊨B<br>&nbsp;<br>NOTE: this means if we can prove an argument then it is valid<br>&nbsp;<br>Completeness: any semantically valid argument is syntactically valid<br>A1, …,An ⊨ B implies A1, …,An ⊢ B<br>&nbsp;<br>NOTE: this means we can construct a proof of any valid argument<br>&nbsp;<br>Natural deduction is sound and complete : we can prove any valid argument.</p>
<h2 id="Equivalencies"><a href="#Equivalencies" class="headerlink" title="Equivalencies"></a>Equivalencies</h2><p>Some formulas are equivalent, written A ≡ B. The equivalence relationship is called semantically equivalent(or, provably equivalent).<br>&nbsp;<br>def: A ≡ B iff the truth values of A and B are the same for all interpretations<br>(A ≡ B iff A ⊨ B and B ⊨ A)</p>
<p><strong>Useful equivalence</strong><br>Commutativity: ∧ and ∨ are commutative </p>
<ul>
<li>A∧B ≡ B∧A</li>
<li>A∨B ≡ B∨A</li>
</ul>
<p>Associativity: ∧ and ∨ are associative </p>
<ul>
<li>A∧(B∧C) ≡ (A∧B)∧C</li>
<li>A∨(B∨C) ≡ (A∨B)∨C</li>
</ul>
<p>Idempotency: ∧ and ∨ are idempotent </p>
<ul>
<li>A∧A ≡ A</li>
<li>A∨A ≡ A</li>
</ul>
<p>Distributivity: ∧ distributes over ∨ (and vice versa) </p>
<ul>
<li>A∧(B∨C) ≡ (A∧B)∨(A∧C)</li>
<li>A∨(B∧C) ≡ (A∨B)∧(A∨C)</li>
</ul>
<p>De Morgan’s laws</p>
<ul>
<li>¬(A∧B) ≡ ¬A∨¬B </li>
<li>A∧B    ≡ ¬(¬A∨¬B) </li>
<li>¬(A∨B) ≡ ¬A∧¬B </li>
<li>A∨B    ≡ ¬(¬A∧¬B)</li>
</ul>
<p>Double negation </p>
<ul>
<li>¬¬A ≡ A</li>
</ul>
<p>Implication</p>
<ul>
<li>A→B ≡ ¬A∨B</li>
</ul>
<p>We can also define other new connectives</p>
<ul>
<li>A <-> B ≡ (A→B)∧(B→A) (bi-implication) </-></li>
<li>A (+) B ≡ (A∧¬B)∨(¬A∧B) (exclusive or)</li>
</ul>
<p><strong>Proving equivalences</strong><br>As given some useful equivalence relations above, we can prove equivalences by working forwards/backwards with a single proof or replacing subformulas with equivalent ones.<br>&nbsp;<br>example: (P ∧ Q) -&gt; S ≡ P -&gt; (Q -&gt; S)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(P ∧ Q) → S ≡ P → (Q → S)</span><br><span class="line">            ≡ ¬ (P ∧ Q) ∨ S    // implication</span><br><span class="line">            ≡ (¬ p ∨ ¬ q)∨ s   // de morgan&apos;s</span><br><span class="line">            ≡ ¬ p ∨ (¬ q ∨ s)  // distributivity</span><br><span class="line">            ≡ ¬ p ∨ (q → s)    // implication</span><br><span class="line">            ≡ p → (q → s)      // implication</span><br></pre></td></tr></table></figure>
<p>we can prove and disprove equivalences i.e. (P→Q)∧¬Q ≡ ¬P<br>&nbsp;<br>NOTE : equivalence is useful to check the (in)validity of argument.<br>&nbsp;<br>Redundancy : when applying equivalence equations, if we remove too many connectives it leads to lots of nesting and complex formulas. (so we introduce normal form)</p>
<h2 id="Normal-form"><a href="#Normal-form" class="headerlink" title="Normal form"></a>Normal form</h2><p>literal: a literal is an atomic proposition or its negation i.e. P or ¬P<br>&nbsp;<br>DNF(disjunction normal form): a form of A1 ∨ A2 ∨ …∨ An where each clause(分句) Ai is a conjunction of one or more literals<br>i.e. (¬P ∧ Q) ∨ (¬P ∧ R) ∨ (¬P ∧ ¬R ∧ ¬Q)<br>&nbsp;<br>CNF(conjunction normal form): a form of A1 ∧ A2 ∧ …∧ An where each clause Ai is a disjunction of one or more literals<br>i.e. (R ∨ ¬Q ∨ ¬P) ∧ (Q ∨ ¬R)<br>&nbsp;<br>Often, we write CNF into clausal normal form as a set of sets of literals</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;R, ¬Q, ¬P&#125;, &#123;Q, ¬R&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Conversion to normal form</strong><br>Procedure: </p>
<ol>
<li>eliminate -&gt; connectives</li>
<li>move all negations so they only occur in literals</li>
<li>use distributive laws until the formula is in normal form</li>
</ol>
<p><strong>Using CNF</strong><br>to make a CNF formula true, we need at least onw literal in each clause to be true. Often, we will check satisfiability of a CNF formula. i.e. (R ∨ ¬Q ∨ ¬P) ∧ (Q ∨ ¬R)<br>&nbsp;<br>Simplifications of Clausal normal form :<br>if a clause contains a literal and its negation, the clause can be removed from the CNF as truth always hold </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;R,¬Q,¬R&#125;,&#123;Q,¬P,R&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>if a clause is a subset of another clause, then the other clause can be removed from the CNF as truth is determined by the sub-clause </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;R,Q,¬P&#125;,&#123;Q,¬P&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Special cases: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;P&#125;, &#123;&#125;&#125; is false as the empty disjunction is false</span><br><span class="line">&#123; &#125; this is true as the empty conjunction is true</span><br><span class="line">&#123;&#123;Q&#125;, &#123;¬Q&#125;, &#123;P&#125;&#125; is false as Q and ¬Q is contradiction</span><br></pre></td></tr></table></figure>
<p>empty clauses are written as a square 口.<br>&nbsp;<br>NOTE: </p>
<ul>
<li>empty disjunction is false</li>
<li>empty conjunction is true</li>
</ul>
<h2 id="Resolution-归结原理"><a href="#Resolution-归结原理" class="headerlink" title="Resolution(归结原理)"></a>Resolution(归结原理)</h2><p>def: Unlike natural deduction, resolution has only 1 inference rule :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;A&#125; ∨ X1     &#123;¬A&#125; ∨ X2   </span><br><span class="line">----------------------- Resolution</span><br><span class="line">       X1 ∨ X2</span><br></pre></td></tr></table></figure>
<p>NOTE: {A} ∨ X1 and {¬A} ∨ X2 are two clauses/ premises in CNF form<br>&nbsp;<br>Special cases: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  A     ¬A ∨ B   </span><br><span class="line">--------------- Resolution  // -&gt; -elimination</span><br><span class="line">       B</span><br><span class="line"></span><br><span class="line"> A    ¬A   </span><br><span class="line">--------- Resolution  // contradiction introduction</span><br><span class="line">    ⊥</span><br></pre></td></tr></table></figure>
<p>NOTE: </p>
<ul>
<li>premises and conclusion are all disjunctions. </li>
<li>this works because A ∨ ¬A is always true.</li>
</ul>
<p><strong>Resolution refutation</strong><br>A formula φ is valid iff ¬φ is unsatisfiable. we can prove φ by proving ¬φ is a contradiction<br>&nbsp;<br>to prove validity of a formula: </p>
<ol>
<li>negate the formula φ</li>
<li>convert to CNF/ clausal normal form</li>
<li>resolve a pair of clauses repeatly until :<ul>
<li>we find an empty clause 口 (after we solve A and ¬A we got empty clause) : then φ is valid</li>
<li>we find there are no more new pairs to resolve or find it true (P ∨ ¬P): then φ is invalid</li>
</ul>
</li>
</ol>
<p>NOTE: it is sound and complete</p>
<p><strong>Satisfiability</strong><br>Checking validity via satisfiability</p>
<ul>
<li>formula φ is valid iff ¬φ is unsatisfiable </li>
<li>formula φ is invalid iff ¬φ is satisfiable </li>
</ul>
<p>we can then, use these to show whether a argument is valid or not.</p>
<p><strong>Proving arguments’ validity</strong><br>Procedure: </p>
<ol>
<li>A1, …, An ⊢ C is valid iff (A1 ∧ …∧ An) -&gt; C is valid</li>
<li>¬((A1 ∧ …∧ An) -&gt; C) ≡ A1 ∧…∧ An ∧ ¬C</li>
<li>convert to clausal normal form</li>
<li>apply resolution inference rule repeatly</li>
</ol>
<p><strong>SAT solver</strong><br>“TheScienceofBruteForce”,MarijnJ.H.Heule,OliverKullmann  – <a href="https://cacm.acm.org/magazines/2017/8/219606-the-science-of-brute-force/fulltext" target="_blank" rel="noopener">https://cacm.acm.org/magazines/2017/8/219606-the-science-of-brute-force/fulltext</a> – state-of-the-artSATandautomatedmathematicalproofs  <br>Z3: a theorem prover, including both SAT/SMT solvers – <a href="https://rise4fun.com/z3/tutorial" target="_blank" rel="noopener">https://rise4fun.com/z3/tutorial</a> </p>

	
	</div>
  <a type="button" href="/2019/02/19/[Logic]01_propositionalLogic/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
     <a href="/page/3/" type="button" class="btn btn-default"><i class="fa fa-arrow-circle-o-left"></i> Prev</a>
      

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/5/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Git-分布式版本控制器/">Git(分布式版本控制器)<span>2</span></a></li>
		
			<li><a href="/categories/Hardware-计算机硬件/">Hardware(计算机硬件)<span>2</span></a></li>
		
			<li><a href="/categories/Terminal-终端/">Terminal 终端<span>1</span></a></li>
		
			<li><a href="/categories/Year1-Artificial-Intelligence/">Year1/ Artificial Intelligence<span>12</span></a></li>
		
			<li><a href="/categories/Year1-Data-Structure/">Year1/ Data Structure<span>2</span></a></li>
		
			<li><a href="/categories/Year1-Java/">Year1/ Java<span>4</span></a></li>
		
			<li><a href="/categories/Year1-Logic-and-Computation/">Year1/ Logic and Computation<span>3</span></a></li>
		
			<li><a href="/categories/Year1-Mathematics-Fundation-of-Computer-Science/">Year1/ Mathematics Fundation of Computer Science<span>16</span></a></li>
		
		</ul>
	</div>

		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2019/06/18/[Hardware]01_pre/"><i class="fa fa-file-o"></i>如何理解计算机?</a>
      </li>
    
      <li>
        <a href="/2019/06/18/[Hardware]02_cpu/"><i class="fa fa-file-o"></i>CPU</a>
      </li>
    
      <li>
        <a href="/2019/06/18/Unix-commands/"><i class="fa fa-file-o"></i>MacOS/ basic commands</a>
      </li>
    
      <li>
        <a href="/2019/06/17/Git_1/"><i class="fa fa-file-o"></i>Intro - 什么是git?</a>
      </li>
    
      <li>
        <a href="/2019/06/17/Git_2/"><i class="fa fa-file-o"></i>Intro - git原理</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-envelope"></i><a href="mailto:jwyhhh123@gmail.com" title="send me Email" target="_blank" ]);">Email</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://github.com/jwyhhh123" title="My Github account." target="_blank" ]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2019 Wenye Jin
  
      | with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> based on <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  
  <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'ZP2ZSuHgipSZfRyU8uTR','2.0.0');
  </script>



  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
