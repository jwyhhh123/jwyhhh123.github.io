<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Part II:Programming part Introductionparadox(悖论): “what i am saying is wrong”&amp;nbsp;a formal system:  sound(true then cannot be false) complete(true or false can be determined) computable(be computed b">
<meta property="og:type" content="article">
<meta property="og:title" content="Computation">
<meta property="og:url" content="https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/index.html">
<meta property="og:site_name" content="WY J">
<meta property="og:description" content="Part II:Programming part Introductionparadox(悖论): “what i am saying is wrong”&amp;nbsp;a formal system:  sound(true then cannot be false) complete(true or false can be determined) computable(be computed b">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-02T19:53:58.054Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Computation">
<meta name="twitter:description" content="Part II:Programming part Introductionparadox(悖论): “what i am saying is wrong”&amp;nbsp;a formal system:  sound(true then cannot be false) complete(true or false can be determined) computable(be computed b">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Computation</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/index.md">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/02/19/Logic_part1/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&text=Computation"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&title=Computation"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&is_video=false&description=Computation"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Computation&body=Check out this article: https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&title=Computation"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&title=Computation"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&title=Computation"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&title=Computation"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&name=Computation&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-II"><span class="toc-number">1.</span> <span class="toc-text">Part II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming-part-Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">:Programming part Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Computer-Proof-Checking"><span class="toc-number">1.2.</span> <span class="toc-text">Computer Proof Checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types"><span class="toc-number">1.3.</span> <span class="toc-text">Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-amp-pattern-matching（模式匹配）"><span class="toc-number">1.4.</span> <span class="toc-text">Functions &amp; pattern matching（模式匹配）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-checking"><span class="toc-number">1.5.</span> <span class="toc-text">Type checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-inference-推理"><span class="toc-number">1.6.</span> <span class="toc-text">Type inference(推理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CH-correspondence-cont’d"><span class="toc-number">1.7.</span> <span class="toc-text">CH correspondence - cont’d</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inductive-types"><span class="toc-number">1.8.</span> <span class="toc-text">Inductive types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fold-reduce"><span class="toc-number">1.9.</span> <span class="toc-text">Fold(reduce)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#More-on-types"><span class="toc-number">1.10.</span> <span class="toc-text">More on types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Induction"><span class="toc-number">1.11.</span> <span class="toc-text">Induction</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Computation
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">WY J</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-02-19T00:05:02.000Z" itemprop="datePublished">2019-02-19</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Logic-and-Computation/">Logic and Computation</a>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h1><h2 id="Programming-part-Introduction"><a href="#Programming-part-Introduction" class="headerlink" title=":Programming part Introduction"></a>:Programming part Introduction</h2><p>paradox(悖论): “what i am saying is wrong”<br>&nbsp;<br>a formal system:</p>
<ul>
<li>sound(true then cannot be false)</li>
<li>complete(true or false can be determined)</li>
<li>computable(be computed by machine)</li>
</ul>
<h2 id="Computer-Proof-Checking"><a href="#Computer-Proof-Checking" class="headerlink" title="Computer Proof Checking"></a>Computer Proof Checking</h2><p><strong>Inference rules</strong><br>and-elimination:</p>
<ul>
<li>andEl : {P Q : Prop}   -&gt; P and Q -&gt; P</li>
<li>andEr : {P Q : Prop}   -&gt; P and Q -&gt; Q</li>
</ul>
<p>and-introduction:</p>
<ul>
<li>andI : {P Q : Prop}   -&gt; P -&gt; Q -&gt; P and Q</li>
</ul>
<p>or-introduction</p>
<ul>
<li>orIl : {P Q : Prop}   -&gt; p -&gt; P or Q</li>
<li>orIr : {P Q : Prop}   -&gt; Q -&gt; P or Q</li>
</ul>
<p>or-elimination</p>
<ul>
<li>orE : {P Q R : Prop}   -&gt; P or Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R</li>
</ul>
<p>falsity-elimination</p>
<ul>
<li>ENQ : {P : Prop}   -&gt; Falsity -&gt; P</li>
</ul>
<p>double-negation-elimination</p>
<ul>
<li>DNE : {P : Prop}  -&gt; (not (not P)) -&gt; P</li>
</ul>
<p>Modus ponens</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mp: &#123;P Q : Prop&#125;  -&gt; (P -&gt; Q) -&gt; P -&gt; Q</span><br><span class="line">mp  &#123;P&#125; &#123;Q&#125;          f           p  = q where</span><br><span class="line"> q: Q        </span><br><span class="line"> q = f p</span><br></pre></td></tr></table></figure>
<p>Implication introduction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">comp : &#123;A B C : Prop&#125; -&gt; (f : A -&gt; B) -&gt; (g : B -&gt; C) -&gt; (A -&gt; C) </span><br><span class="line">comp &#123;A&#125; &#123;B&#125; &#123;C&#125; f g = h where</span><br><span class="line">  h : A -&gt; C</span><br><span class="line">  h a = c where</span><br><span class="line">    b : B</span><br><span class="line">    b = f a</span><br><span class="line">    c : C</span><br><span class="line">    c = g b</span><br></pre></td></tr></table></figure>
<p>NOTE : except the last proposition, f and g are all hypothesis(premises).<br>&nbsp;<br><strong>Proof checking examples</strong><br>Or-elimination :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ore : &#123;P Q R S&#125; -&gt; p or (Q and R) -&gt; S -&gt; (S and P) or Q</span><br><span class="line">ore &#123;P&#125; &#123;Q&#125; &#123;R&#125; &#123;S&#125; x s = y where</span><br><span class="line">  a : P -&gt; (S and P) or Q</span><br><span class="line">  a p = orIl andI p s</span><br><span class="line">  b : Q and R -&gt; (S and P) or Q</span><br><span class="line">  b m = n where</span><br><span class="line">    q : Q</span><br><span class="line">    q = andEl m</span><br><span class="line">    n : (S and P) or Q</span><br><span class="line">    n = orIr q</span><br><span class="line">  y : (S and P) or Q</span><br><span class="line">  y = orE x a b</span><br></pre></td></tr></table></figure>
<p><strong>Negation</strong><br>we write (not A) as : A -&gt; Falsity</p>
<p>Double negation introduction:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DNI : &#123;A : Prop&#125; : A -&gt; (A -&gt; Falsity) -&gt; Falsity</span><br><span class="line">DNI &#123;A&#125; a f = x where</span><br><span class="line">  x : Falsity</span><br><span class="line">  x = f a</span><br></pre></td></tr></table></figure>
<p>Triple negation elimination</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TNE : &#123;A : Prop&#125; -&gt; (f : (not (not A)) -&gt; Falsity) -&gt; (a : A) -&gt; Falsity</span><br><span class="line">TNE &#123;A&#125; f a = x where</span><br><span class="line">  y : not (not A)</span><br><span class="line">  y = DNI a</span><br><span class="line">  x : Falsity</span><br><span class="line">  x = f y</span><br></pre></td></tr></table></figure>
<p><strong>Proof terms</strong><br>def : fully-inlined(完全内联的) proofs with no auxiliary(辅助的) definitions<br>&nbsp;<br>NOTE: all the definitions above can be inlined by removing auxiliary clauses.</p>
<p><strong>Law of Excluded Middle</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE goal where</span><br><span class="line">  goal : (P or (P -&gt; Falsity) -&gt; Falsity) -&gt; Falsity</span><br><span class="line">  goal z = z u where</span><br><span class="line">    v : P -&gt; Falsity</span><br><span class="line">    v x = z w where</span><br><span class="line">      w : P or (P -&gt; Falsity)</span><br><span class="line">      w = orIl x </span><br><span class="line">    u : P or ( P -&gt; Falsity)</span><br><span class="line">    u = orIr v</span><br></pre></td></tr></table></figure>
<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p><strong>Introduce functions</strong><br>Some functions written in Agda:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f : Nat -&gt; Nat</span><br><span class="line">f x = 3 * x +7</span><br><span class="line"></span><br><span class="line">g : Nat -&gt; Nat</span><br><span class="line">g x = 4 * x * x + 9 * x + 10</span><br><span class="line"></span><br><span class="line">m : Nat</span><br><span class="line">m = max (f 9) (g 6)</span><br></pre></td></tr></table></figure>
<p>NOTE: by using a programming language, we read <code>p : A</code> as a program <code>p</code> has type A, and <code>f : A -&gt; B</code> as <code>f</code> is a function converting A to B.</p>
<p><strong>Basic types or enums</strong><br>Void type :<br>no constructor so this type cannot be instantiated</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data Void : Set where</span><br></pre></td></tr></table></figure>
<p><code>data</code>  : introduces the definition<br><code>Void</code>  : the name of the type<br><code>Set</code>   : it is a type<br><code>where</code> : introduces the constructors</p>
<p>Empty type :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data unit : Set where</span><br><span class="line">  empty : unit</span><br></pre></td></tr></table></figure>
<p>Boolean type :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data Boolean : Set where</span><br><span class="line">  true false : Boolean</span><br></pre></td></tr></table></figure>
<p>Similarly, we can define our own types :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data Weekdays : Set where</span><br><span class="line">  Monday Tuesday Wednesday Thursday Friday : Weekdays</span><br></pre></td></tr></table></figure>
<p><strong>Composite(复合的) types</strong><br>def : we can put two existing data types together to form a new data type.<br>&nbsp;<br>Product (tuple) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data Prod (X Y : Set) : Set where</span><br><span class="line">  pair : X -&gt; Y -&gt; Prod X Y</span><br></pre></td></tr></table></figure>
<p><code>data</code>        : we are defining a data type<br><code>Prod</code>        : the name of the data type<br><code>(A B : Set)</code> : A and B are other data types<br><code>: Set</code>       : we are defining a type indeed<br><code>where</code>       : definitions to follow<br><code>pair</code>        : the name of the constructor<br><code>X -&gt; Y -&gt; Prod X Y</code> : the type of the constructor. given <code>X</code> and <code>Y</code> and return their product <code>Prod X Y</code>. </p>
<p>Sum (union) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Sum (A B : Set) : Set where</span><br><span class="line">  left  : A -&gt; Sum A B</span><br><span class="line">  right : B -&gt; Sum A B</span><br></pre></td></tr></table></figure>
<p>NOTE: <code>Sum</code> and <code>Prod</code> are usually called algrebraic types.<br>&nbsp;<br>Similarly, we can define our own composite types :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data Triple (A B C : Set) : Set where</span><br><span class="line">  triple : A -&gt; B -&gt; C -&gt; Triple A B C</span><br><span class="line"></span><br><span class="line">data Sum (A B C : Set) : Set where</span><br><span class="line">  left : A -&gt; Sum A B C</span><br><span class="line">  middle : B -&gt; Sum A B C</span><br><span class="line">  right : C -&gt; Sum A B C</span><br></pre></td></tr></table></figure>
<p><strong>The differences between Sum and Prod</strong><br>If type <code>A</code> has <code>m</code> elements and type <code>B</code> has <code>n</code> elements, then:</p>
<p><code>Sum A B</code> have  m + n elements;<br><code>Prod A B</code> have  m x n elements;<br>&nbsp;<br>can we define any element of <code>Prod A Void</code> for some <code>A</code>?     null; because void cannot be instantiated<br>can we define any element of <code>Sum A Void</code> for some <code>A</code>?   A; because right can be instantiated</p>
<h2 id="Functions-amp-pattern-matching（模式匹配）"><a href="#Functions-amp-pattern-matching（模式匹配）" class="headerlink" title="Functions &amp; pattern matching（模式匹配）"></a>Functions &amp; pattern matching（模式匹配）</h2><p>def: As we have constructed some data types, we want to access the data inside a type in functional languages, so we introduce destructors. These destructors are built into function definitions via a mechanism known as pattern-matching.<br>&nbsp;<br>NOTE : we can define some operators by using this machanism.</p>
<p><strong>Pattern matching enumerations</strong><br>The pattern matching machanism will check all cases are covered. If we lost some cases Agda will throw an error.<br>&nbsp;<br>pattern matching <code>and</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and : Boolean -&gt; Boolean -&gt; Boolean</span><br><span class="line">and true  true  = true</span><br><span class="line">and true  false = false</span><br><span class="line">and false true  = false</span><br><span class="line">and false false = false</span><br></pre></td></tr></table></figure>
<p>In order to avoid missing cases, we can simplify to :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and : Boolean -&gt; Boolean -&gt; Boolean</span><br><span class="line">and true true = true</span><br><span class="line">and x y = false</span><br></pre></td></tr></table></figure>
<p>as we can see the remaining cases are all concluded to false, the truth values can be assigned to x and y. And from top to bottom, each case is covered.<br>&nbsp;<br>If a case is not actually used, we can assign <code>_</code>. for example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and : Boolean -&gt; Boolean -&gt; Boolean</span><br><span class="line">and true true = true</span><br><span class="line">and _ _ = false                  ... if the remaining cases are unused...</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">pattern matched type can be used to define other functions relating to it :</span><br></pre></td></tr></table></figure>
<p>nand : Boolean -&gt; Boolean -&gt; Boolean<br>nand true true = false<br>nand x y = true</p>
<p>negate : Boolean -&gt; Boolean<br>negate x = nand x x<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">where the second Boolean is a result of nand (Boolean -&gt; Boolean).</span><br><span class="line"></span><br><span class="line">**Pattern matching prod**</span><br><span class="line">Sightly different, the function we pattern match here is composite, namely polymorphic(working for more than one types). So we need to specify that types we are using :</span><br></pre></td></tr></table></figure></p>
<p>proj1 : {A B : Set} -&gt; Prod A B -&gt; A<br>proj1 (pair a _) = a                    … b is unused …</p>
<p>proj2 : {A B : Set} -&gt; Prod A B -&gt; B<br>proj2 (pair _ b) = b                    … a is unused …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NOTE : here we have seperate pattern matching functions. As type of A and type of B are elements in `Prod`, whenever we are given an element of that type we match it against `pair a b`.</span><br><span class="line"></span><br><span class="line">**Pattern matching sum**</span><br><span class="line">Important to remember, we need to pattern match all cases appearing in each single type. Example below, as `sum Unit Unit` has as many proof terms as Boolean, so we have :</span><br></pre></td></tr></table></figure></p>
<p>f : Sum Unit Unit -&gt; Boolean<br>f (left x)  = true<br>f (right y) = false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from the opposite we have :</span><br></pre></td></tr></table></figure></p>
<p>g : Boolean -&gt; Sum Unit Unit<br>g true  = left empty<br>g false = right empty<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Example : since `A + A = 2 * A`, we can convert between `Sum A A` and `Prod Boolean A`</span><br></pre></td></tr></table></figure></p>
<p>h : {A : Set} -&gt; Sum A A -&gt; Prod Boolean A<br>h (left a)  = pair true a<br>h (right a) = pair false a</p>
<p>i : {A : Set} -&gt; Prod Boolean A -&gt; Sum A A<br>i (pair true a) = left a<br>i (pair false a) = right a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**A special case**</span><br><span class="line">We can pattern match `Void` using () :</span><br></pre></td></tr></table></figure></p>
<p>impossible : {A : Set} -&gt; void -&gt; A<br>impossible ()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Convert between `Sum A Void` and `A`.</span><br></pre></td></tr></table></figure></p>
<p>to : {A : Set} -&gt; Sum A Void -&gt; A<br>to left a = a</p>
<p>from : {A : Set} -&gt; A -&gt; Sum A Void<br>from a = left a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Convert between `Prod A Void` and `Void`</span><br></pre></td></tr></table></figure></p>
<p>to : {A : Set} -&gt; Prod A Void -&gt; Void<br>to pair a _ = a</p>
<p>from : {A : Set} -&gt; Void -&gt; Prod A Void<br>from ()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**Generally**</span><br><span class="line">Note that arbitrary types can be created using the language of type definition, and they are always destructed via pattern matching :</span><br></pre></td></tr></table></figure></p>
<p>data Foo (A : Set) : Set where<br> foo1 : Foo A<br> foo2 : A -&gt; A -&gt; Foo A<br> foo3 : A -&gt; A -&gt; Foo A</p>
<p>ff : {A : Set} -&gt; Foo A -&gt; Foo A<br>ff foo1 = foo1<br>ff (foo2 x y) = foo3 y x<br>ff (foo3 x _) = foo2 x x<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Type Isomorphisms</span><br><span class="line">**A note on syntax**</span><br><span class="line">if we look the examples below, the only difference is in the proj2 we remove &#123;A&#125; and &#123;B&#125;. This is because we did not use them in the definition.</span><br></pre></td></tr></table></figure></p>
<p>proj1 : {A B : Set} -&gt; Prod A B -&gt; A<br>proj1 {A} {B} (pair a b) = a</p>
<p>proj2 : {A B : Set} -&gt; Prod A B -&gt; A<br>proj2 (pair a b) = a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Another example : modus ponens</span><br></pre></td></tr></table></figure></p>
<p>mp : {A B : Set} -&gt; (A -&gt; B) -&gt; A -&gt; B<br>mp {A} {B} f a = b where<br>  b : B                         …we used B here…<br>  b = f a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if we inline the definition and remove optional arguments we have :</span><br></pre></td></tr></table></figure></p>
<p>mp : {A B : Set} -&gt; (A -&gt; B) -&gt; A -&gt; B<br>mp f a = f b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**Type isomorphism**</span><br><span class="line">def : The existence of invertible functions `f : A -&gt; B`, and `g : B -&gt; A` means that the two types are isomorphic (&quot;same shape&quot;), written `A ~ B`. Isomorphism is a very important mathematical and programming concept, indicating that data can be converted between the f and g without loss of precision.</span><br><span class="line">&amp;nbsp;</span><br><span class="line">Type isomorphisms are consistent in semi-ring :</span><br></pre></td></tr></table></figure></p>
<pre><code>A + (B + C) ~ (A + B) + C
      A + B ~ B + A
      A + B ~ A
A * (B * C) ~ (A * B) * C
      A * B ~ B * A
      A * 1 ~ A
A * (B + C) ~ A * B + A * C
(A + B) * C ~ A * C + B * C
      A * 0 ~ 0 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Example: Show that `A + (B + C) ~ (A + B) + C`.</span><br></pre></td></tr></table></figure>
<p>q1-to : {A B C : Set} -&gt; Sum A (Sum B C) -&gt; Sum (Sum A B) C<br>q1-to (left a) = left (left a)<br>q1-to (right (left b)) = left (right b)<br>q1-to (right (right c)) = right c</p>
<p>q1-from : {A B C : Set} -&gt; Sum (Sum A B) C -&gt; Sum A (Sum B C)<br>q1-from (left (left a)) = left a<br>q1-from (left (right b)) = right (left b)<br>q1-from (right c) = right (right c)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">To check that these are inverse, we want to show q1-to (q1-from x) = x and q1-from (q1-to x) = x :</span><br></pre></td></tr></table></figure></p>
<p>q1-to (q1-from (left (left a))) = q1-to (left a) = left (left a)<br>q1-to (q1-from (left (right b))) = q1-to (right (left b)) = left (right b)<br>q1-to (q1-from (right c)) = q1-to (right (right c)) = right c</p>
<p>q1-from (q1-to (left a)) = q1-from (left (left a)) = left a<br>q1-from (q1-to (right (left b))) = q1-from (left (right b)) = right (lef b)<br>q1-from (q1-to (right (right c))) = q1-from (right c) = right (right c)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HOTE : When checking isomorphism, we need to check EACH pattern matched case.</span><br><span class="line"></span><br><span class="line">**Not isomorphic**</span><br><span class="line">There are conversion functions `f : A -&gt; B`, `g : B -&gt; A` that they are NOT isomorphic.</span><br><span class="line">&amp;nbsp;</span><br><span class="line">example : `Boolean` and `Unit`</span><br></pre></td></tr></table></figure></p>
<p>to : Boolean -&gt; Unit<br>to _ = empty</p>
<p>from : Unit -&gt; Boolean<br>from empty = true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">This is often when two types have different number of elements. This case, Boolean has 2 elements and Unit has only 1.</span><br><span class="line"></span><br><span class="line">## Curry-Howard Correspondence</span><br><span class="line">def : the correspondence between logic and types. This correspondence is, in a mathematical sense, an isomorphism.</span><br><span class="line">&amp;nbsp;</span><br><span class="line">Propositions correspond to types:</span><br><span class="line">Falsity ~ Void</span><br><span class="line">Truth   ~ Unit</span><br><span class="line">A and B ~ Prod A B</span><br><span class="line">A or B  ~ Sum A B</span><br><span class="line"></span><br><span class="line">Postulates should be implementable as functions :</span><br></pre></td></tr></table></figure></p>
<p>  andEl  : {P Q : Prop}   -&gt; P and Q -&gt; P<br>  andEr  : {P Q : Prop}   -&gt; P and Q -&gt; Q<br>  andI   : {P Q : Prop}   -&gt; P -&gt; Q -&gt; P and Q<br>  orE    : {P Q R : Prop} -&gt; P or Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R<br>  orIl   : {P Q : Prop}   -&gt; P -&gt; P or Q<br>  orIr   : {P Q : Prop}   -&gt; Q -&gt; Q or P<br>  EFQ    : {P : Prop}     -&gt; Falsity -&gt; P<br>  DNE    : {P : Prop}     -&gt; (not (not P)) -&gt; P<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Due to the isomorphism between types and propositions, we can implement postulates as functions with these types :</span><br></pre></td></tr></table></figure></p>
<p>andEl’ : {P Q : Set} -&gt; Prod P Q -&gt; P<br>andEl’ (pair p _) = p</p>
<p>andEr’ : {P Q : Set} -&gt; Prod P Q -&gt; Q<br>andEr’ (pair _ q) = q</p>
<p>andI’ : {P Q : Set} -&gt; P -&gt; Q -&gt; Prod P Q<br>andI’ p q = pair p q</p>
<p>orE’ : {P Q R : Set} -&gt; Sum P Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R<br>orE’ (left p)  f g = f p<br>orE’ (right q) f g = g q</p>
<p>orIl’ : {P Q : Set} -&gt; P -&gt; Sum P Q<br>orIl’ p = left p</p>
<p>orIr’ : {P Q : Set} -&gt; Q -&gt; Sum P Q<br>orIr’ q = right q</p>
<p>EFQ’ : {P : Set} -&gt; Void -&gt; P<br>EFQ’ ()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">We left Double negation elimination out as this cannot be implemented by Curry-Howard Correspondence :</span><br></pre></td></tr></table></figure></p>
<p>DNE’ : {P : Prop} -&gt; ((P -&gt; Void) -&gt; Void) -&gt; P<br>DNE’ x = ?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If we could implement `DNE`, then we can derive an implementation of Law of Excluded Middle :</span><br></pre></td></tr></table></figure></p>
<p>LEM : {P : Set } -&gt; Sum P (P -&gt; Void)<br>LEM = DNE’ goal where<br>  goal z = z (orIr v) where<br>     v x = z (orIl x)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The reason is as we think P as &quot;termination checker&quot; and P -&gt; Void as &quot;non-termination checker&quot; in a turing machine, the function LEM can compute the solution to the Halting problem.</span><br><span class="line">&amp;nbsp;</span><br><span class="line">NOTE :  CH correspondence provides an idea to construct logic without DNE, LEM which is named as constructive logic. Constructive logic means the logic of computation.</span><br><span class="line"></span><br><span class="line">**Proof relevance**</span><br><span class="line">Constructive logic takes the concept of proof as essential. In contrast, classical logic (constructive logic + DNE) takes the concept of truth as essential. To guid your intuition it is best not to think of a constructive-logic proposition `A` as true but, if there is a `p` such that `p : A` you should think of it as _proved by `p`_. </span><br><span class="line"></span><br><span class="line">In constructive logic, this helps us distinguish between propositions (as types) more carefully. </span><br><span class="line"></span><br><span class="line">We know that &quot;true or true is equivalent to true&quot;. This is the case clasically and constructively. We can prove that by constructing the function-proof-term of the corresponding types:</span><br></pre></td></tr></table></figure></p>
<p>suu-u : Sum Unit Unit -&gt; Unit<br>suu-u (left empty) = empty<br>suu-u (right empty) = empty </p>
<p>u-suu : Unit -&gt; Sum Unit Unit<br>u-suu empty = left empty<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">However, these functions do not set up an isomorphism; `u-suu` is obviously not a bijection, since `Sum Unit Unit` has 2 elements and `Unit` only 1. Indeed, it is not the case that (using the algebraic notation) `1 + 1 ~ 1`.</span><br><span class="line"></span><br><span class="line">This means that proofs matter. Proofs are relevant. `Unit` and `Sum Unit Unit` are both provable, but the former has essentially one proof(-term), and the latter two proof(-term)s. </span><br><span class="line"></span><br><span class="line">**Summary**</span><br><span class="line">In conclusion, there is an important correspondence between algebra, logic, types and sets</span><br></pre></td></tr></table></figure></p>
<pre><code>Algebra     Logic     Types           Sets
----------------------------------------------------------
  0           ⊥       Void             ∅
  1           ⊤       Unit            {∙}
a x b       A ∧ B     Prod       A×B={(a,b)∣a∈A,b∈B}
a + b       A ∨ B     Sum        A⊎B={(a,0),(b,1)∣a∈A,b∈B}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Lambda calculus(λ演算)</span><br><span class="line">**def:** due to CH correspondence, proofs (of implication) correspond to functions. we use Lambda calculus to formalise the concept of computability by using a simple notion of functions.</span><br><span class="line">&amp;nbsp;</span><br><span class="line">lambda calculus consists of :</span><br><span class="line">1. variables x, y ...</span><br><span class="line">2. function definition `\x -&gt; F`</span><br><span class="line">3. function application `f x`</span><br><span class="line"></span><br><span class="line">`x`: variable binding</span><br><span class="line">`F`: another lambda term formed by variables, function application, and function definition</span><br><span class="line">&amp;nbsp;</span><br><span class="line">NOTE : </span><br><span class="line">- functions in lambda calculus are called terms. </span><br><span class="line">- \x y z are variables in order. variables are substituted in order.</span><br><span class="line"></span><br><span class="line">examples:</span><br></pre></td></tr></table></figure>
<p>\x -&gt; x + 1<br>\x -&gt; \y -&gt; x + y<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">the second can be written more compactly(紧凑地) as:</span><br><span class="line"></span><br><span class="line">```        </span><br><span class="line">\x y -&gt; x + y</span><br><span class="line"></span><br><span class="line">(\x y -&gt; x + y) 7 8</span><br><span class="line">  = (\y -&gt; 7 + y) 8     ...x = 7 and x is replaced and removed from variables list</span><br><span class="line">  = 7 + 8</span><br><span class="line">  = 15</span><br></pre></td></tr></table></figure></p>
<p>examples : bringing the result of a function to another function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(\x -&gt; x + 1) ((\y -&gt; y + 1) 2) </span><br><span class="line">  = (\x -&gt; x + 1) (2 + 1)</span><br><span class="line">  = (\x -&gt; x + 1) 3</span><br><span class="line">  = 3 + 1</span><br><span class="line">  = 4</span><br></pre></td></tr></table></figure>
<p>“higher-order” functions:</p>
<ul>
<li>takes one or more functions as arguments (i.e. procedural parameters),</li>
<li>returns a function as its result.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\f x -&gt; f (f x)) (\y -&gt; y + 1)</span><br><span class="line">  = \x -&gt; (\y -&gt; y + 1)((\y -&gt; y + 1) x)</span><br><span class="line">  = \x -&gt; (\y -&gt; y + 1)(x + 1)</span><br><span class="line">  = \x -&gt; (x + 1) + 1</span><br><span class="line">  = \x -&gt; x + 2</span><br></pre></td></tr></table></figure>
<p><strong>Proof terms</strong><br>We can inline a function to get the proof term by using lambda calculus.<br>&nbsp;<br>example LEM :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE g where</span><br><span class="line">  g : ((P or (P -&gt; Falsity)) -&gt; Falsity) -&gt; Falsity</span><br><span class="line">  g z = z orIr x where</span><br><span class="line">    x : P -&gt; Falsity </span><br><span class="line">    x p = z orIl p</span><br></pre></td></tr></table></figure>
<p>inline clause x : as we take a variable called p, we can define the function of x : \p -&gt; z (orIr p)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE g where</span><br><span class="line">  g : ((P or (P -&gt; Falsity)) -&gt; Falsity) -&gt; Falsity</span><br><span class="line">  g z = z (orIr (\p -&gt; (z orIl p)))</span><br></pre></td></tr></table></figure>
<p>inline clause g : similar</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE (\z -&gt; (z orIr (\p -&gt; (z orIl p))))</span><br></pre></td></tr></table></figure>
<p>We can write proof as lambda terms, for example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q1 : &#123;Q R S : Prop&#125; -&gt; R -&gt; (not Q -&gt; S) -&gt; (Q and R -&gt; not R) -&gt; S</span><br><span class="line">q1 r f g = f (\q -&gt; g ((andI q r) r))</span><br></pre></td></tr></table></figure>
<p><strong>Church encodings(编码)</strong><br>with the help of lambda calculus, we can encode a lot of mathematical expressions into lambda calculus.<br>&nbsp;<br>Encoding boolean :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true = \a b -&gt; a           ...it takes two variables and choose the first...</span><br><span class="line">false = \a b -&gt; b          ...it takes two variables and choose the second...</span><br><span class="line">and = \p q -&gt; p q p   </span><br><span class="line">or = \p q -&gt; p p q</span><br></pre></td></tr></table></figure>
<p>then, an example : true and false = false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and true false </span><br><span class="line">  = (\p q -&gt; p q p) true false</span><br><span class="line">  = (\q -&gt; true q true) false</span><br><span class="line">  = true false true</span><br><span class="line">  = (\a b -&gt; a) false true     ...chooose the first variable...</span><br><span class="line">  = false</span><br></pre></td></tr></table></figure>
<p>Encoding negation :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not = \p a b -&gt; p b a</span><br></pre></td></tr></table></figure>
<p>test this : true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">not true</span><br><span class="line">  = (\p a b -&gt; p b a) true</span><br><span class="line">  = \a b -&gt; true b a</span><br><span class="line">  = \a b -&gt; (\a b -&gt; a) b a      ...choose the first variable...</span><br><span class="line">  = \a b -&gt; b</span><br><span class="line">  = false</span><br></pre></td></tr></table></figure>
<p>NOTE : compared to <code>and</code>, difference here is we check argument(true) first.<br>&nbsp;<br>Encoding integers : NOT COVERED.<br>&nbsp;<br>Encoding recursion :<br>1) Omega</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Omega = (\x -&gt; x x) (\x -&gt; x x)</span><br></pre></td></tr></table></figure>
<p>2) Y combinator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = \f -&gt; (\x -&gt; f(x x)) (\x -&gt; f(x x))</span><br></pre></td></tr></table></figure>
<p>where we have two identical functions. the second function substitutes each x in the first function then it produces the two new identical functions again. if we process this recursively we get f(f(f …)).<br>&nbsp;<br>For any function <code>g</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Y g = (\x -&gt; g(x x)) (\x -&gt; g(x x))</span><br><span class="line">  = g(((\x -&gt; g(x x)))((\x -&gt; g(x x))))</span><br><span class="line">  = g(Y g)</span><br><span class="line">  ...</span><br><span class="line">  = g (g (Y g))</span><br><span class="line">  ...</span><br><span class="line">  = g (g (g (Y g)))</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>rsc : <a href="https://www.youtube.com/watch?v=eis11j_iGMs" target="_blank" rel="noopener">https://www.youtube.com/watch?v=eis11j_iGMs</a></p>
<p><strong>Summary</strong><br>The Curry-Howard Correspondence between propositional logic and lambda calculus does not quite work because :</p>
<ul>
<li>DNE is left out as it can be introduced to compute LEM which solves the Halting Problem/ instead we introduce constructive logic)</li>
<li>some lambda terms are inconsistent : we have <code>A -&gt; Void</code> which in propositional logic means <code>A -&gt; Falsity</code></li>
</ul>
<h2 id="Type-checking"><a href="#Type-checking" class="headerlink" title="Type checking"></a>Type checking</h2><p>We will ONLY give rules for types within {Void, Unit, A -&gt; B, type variables}.</p>
<p>each type is determined by inference rules in the style of natural deduction sequents : <code>Γ ⊢ t : A</code><br>where :<br><code>Γ</code> is a list of elements of the form <code>x:A</code> where <code>x</code> is a variable and <code>A</code> is a type<br><code>t</code> is a lambda calculus term<br><code>A</code> is a type.</p>
<p><strong>rules:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A -&gt; B   Γ ⊢ u : A</span><br><span class="line">---------------------------[App]</span><br><span class="line">       Γ ⊢ t u : B</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    Γ, x:A ⊢ t : B</span><br><span class="line">----------------------[Abs]</span><br><span class="line"> Γ ⊢ \x -&gt; t : A -&gt; B</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">----------------[Axi]</span><br><span class="line"> Γ, x:A ⊢ x : A</span><br></pre></td></tr></table></figure>
<p>example: check <code>⊢ \x y z -&gt; y (x z) : (A -&gt; B) -&gt; (B -&gt; C) -&gt; (A -&gt; C)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                        ------------------------------[Axi] ----------------------------[Axi]</span><br><span class="line">                                                     Γ ⊢ x : A-&gt;B                Γ ⊢ Z : A</span><br><span class="line">----------------------------------[Axi] ----------------------------------------------------------------[App]</span><br><span class="line">    Γ ⊢ y : (B -&gt; C)                           Γ ⊢ x z : B</span><br><span class="line">----------------------------------------------------------------------[App]</span><br><span class="line">x:A-&gt;B, y:B-&gt;C, z:A ⊢ y (x z) : C</span><br><span class="line">-----------------------------------------------------[Abs x 3]</span><br><span class="line">⊢ \x y z -&gt; y (x z) : (A -&gt; B) -&gt; (B -&gt; C) -&gt; (A -&gt; C)</span><br></pre></td></tr></table></figure>
<h2 id="Type-inference-推理"><a href="#Type-inference-推理" class="headerlink" title="Type inference(推理)"></a>Type inference(推理)</h2><p><strong>Basic type inference</strong><br>Procedure :<br>1) Construct the type derivation tree for the term using variables instead of types.<br>2) Add constraints as follows: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A   Γ ⊢ u : B</span><br><span class="line">---------------------------[A = B -&gt; C]</span><br><span class="line">Γ ⊢ t u : C</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ, x:A ⊢ t : B</span><br><span class="line">----------------[C = A -&gt; B]</span><br><span class="line">Γ ⊢ \x -&gt; t : C</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------[B = A]</span><br><span class="line">Γ, x:A ⊢ x : B</span><br></pre></td></tr></table></figure>
<p>3) Apply unification algorithm :</p>
<ol>
<li>Change all equations <code>t = x</code> where <code>t</code> is not a variable and <code>x</code> is a variable to <code>x = t</code>.</li>
<li>Remove all equations <code>x = x</code> where <code>x</code> is a variable.</li>
<li>Select an equation <code>u = v</code> where neither is a variable and apply <em>type reduction</em>.<br>If type reduction is impossible, <em>fail</em>.</li>
<li>Select an equation <code>x = t</code> where <code>x</code>, where <code>t ≠ x</code>. If <code>x ∈ t</code> then <em>fail</em> else apply <em>variable elimination</em>. </li>
<li>Repeat until <em>solved</em>.  </li>
</ol>
<p>type reduction : any equation of the form <code>t1 -&gt; t2 = t1&#39; -&gt; t2</code> is broken into <code>t1 = t1&#39;, t2 = t2&#39;</code><br>type elimination : If <code>x = u</code> is an equation where <code>x</code> is a variable and <code>t</code> any type (could be just a variable) the substitution <code>x / u</code> is applied to all other equations.<br>&nbsp;<br>4) a set of equations is solved if :</p>
<ul>
<li>all equations have form x = t with x a variable</li>
<li>every variable on the left occurs only in that place</li>
</ul>
<p>Example : Infer the type (if possible) of <code>\f x -&gt; x (f x)</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                               ———————————————————— [H = B]   ———————————————————— [I = D]</span><br><span class="line">                               f : B, x : D ⊢ f : H           f : B, x : D ⊢ x : I</span><br><span class="line">———————————————————— [F = D]   ——————————————————————————————————————————————————— [H = I → G]</span><br><span class="line">f : B, x : D ⊢ x : F           f : B, x : D ⊢ f x : G</span><br><span class="line">————————————————————————————————————————————————————— [F = G → E]</span><br><span class="line">f : B, x : D ⊢ x (f x) : E</span><br><span class="line">—————————————————————————— [C = D → E]</span><br><span class="line">f : B ⊢ \ x → x (f x) : C</span><br><span class="line">————————————————————————— [A = B → C]</span><br><span class="line">⊢ \ f x → x (f x) : A</span><br></pre></td></tr></table></figure>
<p>We collect the equations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → C</span><br><span class="line">C = D → E</span><br><span class="line">F = G → E</span><br><span class="line">F = D</span><br><span class="line">H = I → G</span><br><span class="line">H = B</span><br><span class="line">I = D</span><br></pre></td></tr></table></figure>
<p>Now apply the type inference algorithm.  We select the second line <code>C = D → E</code> and substitute it in the others, obtaining:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → (D → E)</span><br><span class="line">C = D → E</span><br><span class="line">F = G → E</span><br><span class="line">F = D</span><br><span class="line">H = I → G</span><br><span class="line">H = B</span><br><span class="line">I = D</span><br></pre></td></tr></table></figure>
<p>Now we select the third equation <code>F = G → E</code> and substitute it in the others, obtaining</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → (D → E)</span><br><span class="line">C = D → E</span><br><span class="line">F = G → E</span><br><span class="line">G → E = D</span><br><span class="line">H = I → G</span><br><span class="line">H = B</span><br><span class="line">I = D</span><br></pre></td></tr></table></figure>
<p>We flip the fourth equation, giving us:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → (D → E)</span><br><span class="line">C = D → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = I → G</span><br><span class="line">H = B</span><br><span class="line">I = D</span><br></pre></td></tr></table></figure>
<p>We select the fourth equation:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → ((G → E) → E)</span><br><span class="line">C = (G → E) → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = I → G</span><br><span class="line">H = B</span><br><span class="line">I = G → E</span><br></pre></td></tr></table></figure>
<p>The fifth:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → ((G → E) → E)</span><br><span class="line">C = (G → E) → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = I → G</span><br><span class="line">I → G = B</span><br><span class="line">I = G → E</span><br></pre></td></tr></table></figure>
<p>Flip the sixth:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → ((G → E) → E)</span><br><span class="line">C = (G → E) → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = I → G</span><br><span class="line">B = I → G</span><br><span class="line">I = G → E</span><br></pre></td></tr></table></figure>
<p>Substitute the sixth in all the others:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = (I → G) → ((G → E) → E)</span><br><span class="line">C = (G → E) → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = I → G</span><br><span class="line">B = I → G</span><br><span class="line">I = G → E</span><br></pre></td></tr></table></figure>
<p>The seventh:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = ((G → E) → G) → ((G → E) → E)</span><br><span class="line">C = (G → E) → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = (G → E) → G</span><br><span class="line">B = (G → E) → G</span><br><span class="line">I = G → E</span><br></pre></td></tr></table></figure>
<p>from now all equations have been solved as :<br>checked: all equations have form <code>x = t</code> with <code>x</code> a variable<br>checked: every variable on the left occurs only in that place.</p>
<p><strong>Typing non-termination</strong><br>Just like DNE violates the Curry-Howard correspondence from the logical side, so do terms like <code>omega</code> and <code>Y</code> violate it from the functional side. The programming language Agda, which is based on the CH correspondence, bans such terms, which lead to errors. </p>
<p>Terms such as <code>Y</code> and <code>omega</code> are non-terminating because somewhere in them you will find sub-terms <code>\x -&gt; x x</code>. Such terms cannot type check:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----------[D = B] ------------[E = B]</span><br><span class="line">x:B ⊢ x : D        x:B ⊢ x : E</span><br><span class="line">-------------------------------[D = C -&gt; E]</span><br><span class="line">x:B ⊢ x x : C</span><br><span class="line">-----------------[A = B -&gt; C]</span><br><span class="line">⊢ (\x -&gt; x x) : A</span><br></pre></td></tr></table></figure>
<p>The constraints </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D = B</span><br><span class="line">E = B</span><br><span class="line">D = C -&gt; E</span><br><span class="line">A = B -&gt; C</span><br></pre></td></tr></table></figure>
<p>after the eliminination of <code>D</code> and <code>E</code> it becomes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = C -&gt; B</span><br><span class="line">A = B -&gt; C</span><br></pre></td></tr></table></figure>
<p>Which <em>fails</em> as variable <code>B</code> occurs on both sides of an equation.<br>The same failure of type inference occurs in attempting to type the <code>Y</code> combinator. </p>
<h2 id="CH-correspondence-cont’d"><a href="#CH-correspondence-cont’d" class="headerlink" title="CH correspondence - cont’d"></a>CH correspondence - cont’d</h2><p><strong>More complicate isomorphisms</strong><br>Currying iso: <code>a^(b^(c)) = a^(b x c)</code> corresponds to <code>C -&gt; B -&gt; A ~ (Prod C B) -&gt; A</code><br>&nbsp;<br>We have conversion function :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cur : &#123;A B C : Set&#125; -&gt; ((Prod C B) -&gt; A) -&gt; (C -&gt; B -&gt; A)</span><br><span class="line">cur f = \c b -&gt; f (pair c b)</span><br><span class="line"></span><br><span class="line">uncur : &#123;A B C : Set&#125; -&gt; (C -&gt; B -&gt; A) -&gt; ((Prod C B) -&gt; A)</span><br><span class="line">uncur f = \ &#123; (pair c b) -&gt; f c b &#125;</span><br></pre></td></tr></table></figure>
<p>Similarly, we can define the function explicitly :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cur : &#123;A B C : Set&#125; -&gt; ((Prod C B) -&gt; A) -&gt; C -&gt; B -&gt; A</span><br><span class="line">cur f c b = f (pair c b)</span><br><span class="line"></span><br><span class="line">uncur : &#123;A B C : Set&#125; -&gt; (C -&gt; B -&gt; A) -&gt; (Prod C B) -&gt; A</span><br><span class="line">uncur f (pair c b) = f c b</span><br></pre></td></tr></table></figure>
<p>Often we may use lambda calculus to help us check isomorphism :<br>example : <code>Prod (B -&gt; A) (C -&gt; A) ~ Sum B C -&gt; A</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">to : &#123;A B : Set&#125; -&gt; Prod (B -&gt; A) (C -&gt; A) -&gt; Sum B C -&gt; A</span><br><span class="line">to (pair f g) left b = f b</span><br><span class="line">to (pair f g) right c = f c</span><br><span class="line"></span><br><span class="line">from : &#123;A B : Set&#125; -&gt; (Sum B C -&gt; A) -&gt; Prod (B -&gt; A) (C -&gt; A)</span><br><span class="line">from fg = pair (\b -&gt; fg (left b) (\c -&gt; fg (right c))</span><br></pre></td></tr></table></figure>
<p>they are isomorphic as they are inverse to each other:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">to (from fg) (left b) = to (pair (\b -&gt; fg (left b)) (\c -&gt; fg (right c))) (left b)</span><br><span class="line">                      = (\b -&gt; fg (left b)) b</span><br><span class="line">                      = fg (left b)</span><br><span class="line"></span><br><span class="line">to (from fg) (right c) = to (pair (\b -&gt; fg (left b)) (\c -&gt; fg (right c))) (rigth c)</span><br><span class="line">                       = (\c -&gt; fg (right c)) c</span><br><span class="line">                       = fg (right c)</span><br><span class="line"></span><br><span class="line">from (to (pair f g)) = pair (\b -&gt; (to pair f g) (left b)) (\c -&gt; (to pair f g) (right c))</span><br><span class="line">                     = pair (\b -&gt; f b) (\c -&gt; g c)</span><br><span class="line">                     = pair f g</span><br></pre></td></tr></table></figure>
<p><strong>Propositions as types</strong><br>we can now extend the STLC with Product and Sum :<br>&nbsp;<br>Product Elimination Left:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Prod A B</span><br><span class="line">----------------</span><br><span class="line">Γ ⊢ proj1 t : A</span><br></pre></td></tr></table></figure>
<p>Product Elimination Right:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Prod A B</span><br><span class="line">-----------------</span><br><span class="line">Γ ⊢ proj2 t : B</span><br></pre></td></tr></table></figure>
<p>Product Introduction:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A   Γ ⊢ u : B</span><br><span class="line">-----------------------</span><br><span class="line">Γ ⊢ andI t u : Prod A B</span><br></pre></td></tr></table></figure>
<p>Sum Elimination:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Sum A B   Γ ⊢ u : A -&gt; C   Γ ⊢ v : B -&gt; C</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">Γ ⊢  orE t u v : Sum A B -&gt; (A -&gt; C) -&gt; (B -&gt; C) -&gt; C</span><br><span class="line"></span><br><span class="line"> pattern match (left a) = f a</span><br><span class="line">               (right b) = g b</span><br></pre></td></tr></table></figure>
<p>Sum Introduction Left:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A</span><br><span class="line">---------------------</span><br><span class="line">Γ ⊢ orIl t : Sum A B</span><br></pre></td></tr></table></figure>
<p>Sum Introduction Right:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : B</span><br><span class="line">--------------------</span><br><span class="line">Γ ⊢ orIr t : Sum A B</span><br></pre></td></tr></table></figure>
<p>Ex Falso Quodlibet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-------------------</span><br><span class="line">Γ ⊢ EFQ : Void -&gt; A</span><br></pre></td></tr></table></figure>
<h2 id="Inductive-types"><a href="#Inductive-types" class="headerlink" title="Inductive types"></a>Inductive types</h2><p>def : beyond finite types, we can define infinite types by using recursive definition.<br>&nbsp;<br><strong>Natural numbers</strong><br>According to peano’s theorem, we can define natural numbers :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Nat : Set where</span><br><span class="line">  zero : Nat</span><br><span class="line">  suc  : Nat -&gt; Nat</span><br></pre></td></tr></table></figure>
<p>Syntax :<br><code>data</code> is a keyword indicating a type definition<br><code>Nat</code> is the identifier we choose for the type<br><code>Set</code> is the built-in identifier for types<br><code>where</code> is introducing the definitions, which need to be indented<br><code>zero</code> is the name of one of the <strong>constructors</strong><br><code>suc</code> is a <strong>constructor</strong> that takes a <code>Nat</code> as an argument and produces another <code>Nat</code>.<br>&nbsp;<br>Basic functions : pattern matching on Nat’s<br>1) zero test :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is-zero : Nat -&gt; Boolean</span><br><span class="line">is-zero  zero = true</span><br><span class="line">is-zero  _    = false</span><br></pre></td></tr></table></figure>
<p>2) Doubling :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbl : Nat -&gt; Nat</span><br><span class="line">dbl zero = zero</span><br><span class="line">dbl (suc n) = suc (suc (dbl n))</span><br></pre></td></tr></table></figure>
<p>3) Addition :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">add zero n = n</span><br><span class="line">add (suc m) n = suc (add m n)</span><br></pre></td></tr></table></figure>
<p>4) Minus : if m &lt; n then return zero</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">minus : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">minus (suc m) (suc n) = minus m n</span><br><span class="line">minus m _ = m</span><br></pre></td></tr></table></figure>
<p>5) Multiplication as addition i.e. 3 x 4 = 3 + 3 + 3 + 3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">multi m zero = m</span><br><span class="line">multi m (suc n) = add m (multi m n)</span><br></pre></td></tr></table></figure>
<p>6) Halving : (taking 1/2 as 0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half : Nat -&gt; Nat</span><br><span class="line">half zero = zero</span><br><span class="line">half (suc zero) =zero</span><br><span class="line">half (suc (suc n)) = suc (half n)</span><br></pre></td></tr></table></figure>
<p>Structural recursion: if arg is getting smaller, it is allowed to find the answer</p>
<p><strong>Lists</strong><br>List is a polymorphic type so we need to specify the elements in List is a type :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data : List (A : Set) : Set where</span><br><span class="line">  nil  : List A</span><br><span class="line">  cons : A -&gt; List A -&gt; List A</span><br></pre></td></tr></table></figure>
<p><code>nil</code>: empty list constructor<br><code>cons</code>: constructor that takes an element of <code>A</code> (called head) and a list (called tail).<br>&nbsp;<br>Also we can have a list of lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = cons 0 nil          ... [0]</span><br><span class="line">y = cons 1 x            ... [1, 0]</span><br><span class="line">z = cons x (cons y nil) ... [[1, 0], [0]]</span><br></pre></td></tr></table></figure>
<p>1) Empty-check:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">empty : &#123;A : Set&#125; -&gt; List A -&gt; Boolean</span><br><span class="line">empty nil = true</span><br><span class="line">empty _   = false</span><br></pre></td></tr></table></figure>
<p>2) length of a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len : &#123;A : Set&#125; -&gt; List A -&gt; Nat</span><br><span class="line">len nil         = zero</span><br><span class="line">len (cons _ xs) = suc (len xs)</span><br></pre></td></tr></table></figure>
<p>3) Sum of elements in a List :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum : list Nat -&gt; Nat</span><br><span class="line">sum nil = zero</span><br><span class="line">sum (cons x xs) = add x (sum xs)</span><br><span class="line"></span><br><span class="line">add : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">add zero n = n</span><br><span class="line">add (suc m) n = suc (add m n)</span><br></pre></td></tr></table></figure>
<p>4) Appending two lists :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">append : &#123;A : Set&#125; -&gt; List A -&gt; List A -&gt; List A</span><br><span class="line">append nil ys = ys</span><br><span class="line">append (cons x xs) ys = cons x (append xs ys)</span><br></pre></td></tr></table></figure>
<p>5) Maximum element in a List :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">maxl : List Nat -&gt; Nat</span><br><span class="line">maxl nil = zero</span><br><span class="line">maxl (cons x xs) = max x (maxl xs)</span><br><span class="line"></span><br><span class="line">max : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">max m zero = m</span><br><span class="line">max zero n = n</span><br><span class="line">max (suc m) (suc n) = suc (max m n)</span><br></pre></td></tr></table></figure>
<p>6) Reversing a list :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rev : &#123;A : Set&#125; -&gt; List A -&gt; List A </span><br><span class="line">rev nil = nil</span><br><span class="line">rev (cons x xs) = append (rev xs) (cons x nil)</span><br></pre></td></tr></table></figure>
<p>7) Filtering a list: return a list leaves out some elements<br>method 1 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons x xs) = if (is-zero x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-zeros xs</span><br><span class="line"></span><br><span class="line">if : &#123;A : Set&#125; -&gt; Boolean -&gt; A -&gt; A -&gt; A</span><br><span class="line">if true  x  _ = x</span><br><span class="line">if false _ y = y</span><br><span class="line"></span><br><span class="line">is-zero : Nat -&gt; Bool</span><br></pre></td></tr></table></figure>
<p>method 2 : deep pattern-matching :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons zero xs) = filter-zeros xs</span><br><span class="line">filter-zeros (cons (suc n) xs) = cons (suc n) (filter-zeros xs)</span><br></pre></td></tr></table></figure>
<p>suppose that we have a function <code>is-even : Nat -&gt; Boolean</code> to test for even-ness or <code>is-prime : Nat -&gt; Boolean</code> to test for primality. Filtering for some given property has very similar shape:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons x xs) = if (is-zero x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-zeros xs</span><br><span class="line"></span><br><span class="line">filter-evens : List Nat -&gt; List Nat</span><br><span class="line">filter-evens nil = nil</span><br><span class="line">filter-evens (cons x xs) = if (is-even x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-evens xs</span><br><span class="line"></span><br><span class="line">filter-primes : List Nat -&gt; List Nat</span><br><span class="line">filter-primes nil = nil</span><br><span class="line">filter-primes (cons x xs) = if (is-prime x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-primes xs</span><br></pre></td></tr></table></figure>
<p>This means that we can define a generic filter function for any property (predicate) expressed by a function <code>p : A -&gt; Boolean</code> where <code>A</code> is the type of list elements:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filter : &#123;A : Set&#125; -&gt; List A -&gt; List A</span><br><span class="line">filter nil = nil</span><br><span class="line">filter (cons x xs) = if (p x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter xs</span><br><span class="line"></span><br><span class="line">if : &#123;A : Set&#125; -&gt; Boolean -&gt; A -&gt; A -&gt; A</span><br><span class="line">if true x _ = x</span><br><span class="line">if false _ y = y</span><br><span class="line"></span><br><span class="line">p : &#123;A : Set&#125; -&gt; A -&gt; Boolean</span><br></pre></td></tr></table></figure>
<p>8) Interleaving : merge two Lists</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intlv : &#123;A : Set&#125; -&gt; Prod (List A) (List A) -&gt; List A</span><br></pre></td></tr></table></figure>
<p>According to Currying isomorphism, we have </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intlv : &#123;A : Set&#125; -&gt; List A -&gt; List A -&gt; List A</span><br><span class="line">intlv xs nil = xs</span><br><span class="line">intlv nil ys = ys</span><br><span class="line">intlv (cons x xs) (cons y ys) = cons x (cons y (intlv xs ys))</span><br></pre></td></tr></table></figure>
<p>9) Zip : merge two Lists using List (Prod A B); If one of the lists is longer than the other the extra elements are ignored.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zip : &#123;A B : Set&#125; -&gt; List A -&gt; List B -&gt; List (Prod A B)</span><br><span class="line">zip (cons a as) (cons b bs) = cons (pair a b) (zip as bs)</span><br><span class="line">zip _ _ = nil</span><br></pre></td></tr></table></figure>
<h2 id="Fold-reduce"><a href="#Fold-reduce" class="headerlink" title="Fold(reduce)"></a>Fold(reduce)</h2><p>def: it is a recursive function that abstracts the structural recursion pattern itself. we take a function to compute elements in a list. for example add numbers from 0 to 10.</p>
<p>Fold-right:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foldr : &#123;A B : Set&#125; -&gt; (A -&gt; B -&gt; B) -&gt; B -&gt; List A -&gt; B</span><br><span class="line">foldr f y0 nil = y0 </span><br><span class="line">foldr f y0 (cons x xs) = f x y where</span><br><span class="line">  y = foldr f y0 xs</span><br></pre></td></tr></table></figure>
<p>Fold-left:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foldl : &#123;A B : Set&#125; -&gt; (B -&gt; A -&gt; B) -&gt; B -&gt; List A -&gt; B</span><br><span class="line">foldl f y0 nil         = y0</span><br><span class="line">foldl f y0 (cons x xs) = foldl f y0&apos; xs where</span><br><span class="line">  y0&apos; = f y0 x</span><br></pre></td></tr></table></figure>
<p><code>y0</code> a special value for the empty list<br>&nbsp;<br>example : right recursion</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foldr sum 0 xs </span><br><span class="line">   = sum 0 (foldr sum 0 [1, 2, 3])</span><br><span class="line">   = sum 0 (sum 1 (foldr sum 0 [2, 3]))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (foldr sum 0 [3])))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (sum 3 (foldr sum 0 nil))))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (sum 3 0)))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 3))</span><br><span class="line">   = sum 0 (sum 1 5)</span><br><span class="line">   = sum 0 6</span><br><span class="line">   = 6</span><br></pre></td></tr></table></figure>
<p>example : left recursion</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foldl sum 0 xs</span><br><span class="line">  = foldl sum (sum 0 0) [1, 2, 3]</span><br><span class="line">  = foldl sum (sum (sum 0 0) 1) [2, 3]</span><br><span class="line">  = foldl sum (sum (sum (sum 0 0) 1) 2) [3]</span><br><span class="line">  = foldl sum (sum (sum (sum (sum 0 0) 1) 2) 3) nil </span><br><span class="line">  = sum (sum (sum (sum 0 0) 1) 2) 3</span><br><span class="line">  = sum (sum (sum 0 1) 2) 3</span><br><span class="line">  = sum (sum 1 2) 3</span><br><span class="line">  = sum 3 3</span><br><span class="line">  = 6</span><br></pre></td></tr></table></figure>
<p><strong>Map</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map : &#123;A B : Set&#125; -&gt; (A -&gt; B) -&gt; List A -&gt; List B</span><br><span class="line">map f nil = nil</span><br><span class="line">map f (cons x xs) = cons (f x) (map f xs)</span><br></pre></td></tr></table></figure>
<p>This function applies <code>f : A -&gt; B</code> to each element of <code>List A</code> to create a <code>List B</code>. </p>
<p>map-reduce</p>
<h2 id="More-on-types"><a href="#More-on-types" class="headerlink" title="More on types"></a>More on types</h2><p><strong>Dealing with errors</strong><br>Sometimes when we iterate to the tail of a List, we may not simply assign it to zero, but we want it be an error value. In general when we want to assign a value to a specific element in a data type, we can define :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Option (A : Set) : Set where</span><br><span class="line">  none : Option A</span><br><span class="line">  some : A -&gt; Option A</span><br></pre></td></tr></table></figure>
<p><code>none</code> adds a special error value<br><code>some</code> injects <code>A</code> into the wrapper <code>Option</code></p>
<p>return the head of a list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head : &#123;A : Set&#125; -&gt; List A-&gt; Option A</span><br><span class="line">head (cons x _) = some x</span><br><span class="line">head nil        = none</span><br></pre></td></tr></table></figure>
<p>return nth element</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nth : &#123;A : Set&#125; -&gt; Nat -&gt; List A -&gt; Option A</span><br><span class="line">nth _ nil = none</span><br><span class="line">nth zero (cons x _) = some x</span><br><span class="line">nth (suc n) (cons _ xs) = nth n xs</span><br></pre></td></tr></table></figure>
<p>return the sum of 2nd and 3rd in a list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum23 : List Nat -&gt; Option Nat</span><br><span class="line">sum23 xs = add&apos; x2 x3 where</span><br><span class="line">  x2 = nth two xs</span><br><span class="line">  x3 = nth three xs</span><br><span class="line"></span><br><span class="line">add&apos; : Option Nat -&gt; Option Nat -&gt; Option Nat</span><br><span class="line">add&apos; (some m) (some n) = some (add m n)</span><br><span class="line">add&apos; _ _ = none</span><br></pre></td></tr></table></figure>
<p><strong>Trees</strong><br>Binary tree with data stored at leaves</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data BTreeL (A : Set) : Set where</span><br><span class="line">  leaf : A -&gt; BTreeL A</span><br><span class="line">  node : BTreeL A -&gt; BTreeL A -&gt; BTreeL A</span><br></pre></td></tr></table></figure>
<p>Representation :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   BTreeL</span><br><span class="line">   /    \</span><br><span class="line"> ls     rs</span><br><span class="line"> / \    / \</span><br><span class="line">l   r  l   r</span><br></pre></td></tr></table></figure>
<p><strong>S-expreesions</strong><br>def : S-expression is used in serialisation of arbitrary data structure. It representes nested paranthetical expressions whose atomic values are (usually) strings.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Sexp (A : Set) : Set where</span><br><span class="line">  atom : A -&gt; Sexp A</span><br><span class="line">  list : List (Sexp A) -&gt; Sexp A</span><br></pre></td></tr></table></figure>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">open import Agda.Builtin.String</span><br><span class="line"></span><br><span class="line">a-this = atom &quot;this&quot;</span><br><span class="line">a-is   = atom &quot;is&quot;</span><br><span class="line">a-an   = atom &quot;an&quot;</span><br><span class="line">a-s    = atom &quot;s&quot;</span><br><span class="line">a-exp  = atom &quot;expression&quot;</span><br><span class="line"></span><br><span class="line">l-is-an = list (cons a-is (cons a-an nil))</span><br><span class="line">l-s-exp = list (cons a-s (cons a-exp nil))</span><br><span class="line">l-ex    = list (cons a-this (cons l-is-an (cons l-s-exp nil)))</span><br></pre></td></tr></table></figure>
<h2 id="Induction"><a href="#Induction" class="headerlink" title="Induction"></a>Induction</h2><p>induction proof :</p>
<ol>
<li>Basis of induction : if P(0) holds</li>
<li>Inductive step : hypothesize P(n), if P(n) -&gt; P(suc n) holds then</li>
<li>Conclusion : P(n) holds</li>
</ol>
<p>NOTE : we will prove informally using induction above.</p>
<p><strong>Induction on Nat</strong><br>procedure : prove ∀ n ∈ Nat. P(n) holds</p>
<ol>
<li>Base case : P(zero)</li>
<li>Inductive case : Hypothesize P(n), prove P(suc n)</li>
</ol>
<p><strong>Induction on list</strong><br>Procedure : prove ∀ es ∈ List. P(es) holds</p>
<ol>
<li>Base case : P(nil)</li>
<li>Inductive case : Hypothesize P(xs), prove P(cons x xs)</li>
</ol>
<p><strong>Isomorphism by induction</strong><br>Furthermore, when we are trying to show isomorphism between something and a List, we need to prove from each direction by induction.<br>&nbsp;<br><code>Nat ~ List Unit</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">f : Nat → List Unit</span><br><span class="line">f zero = nil</span><br><span class="line">f (suc n) = cons empty (f n)</span><br><span class="line"></span><br><span class="line">g : List Unit → Nat</span><br><span class="line">g nil = zero</span><br><span class="line">g (cons e es) = suc (g es)</span><br><span class="line"></span><br><span class="line">-- Induction required!</span><br><span class="line"></span><br><span class="line">-- Prove: ∀ n ∈ Nat. g (f n) ≡ n</span><br><span class="line">-- Base case: Prove (g (f zero) ≡ zero)</span><br><span class="line">--                    g (f zero) ≡ zero</span><br><span class="line">--                    g nil ≡ zero            (by def. of f)</span><br><span class="line">--                    zero ≡ zero            (by def. of g)</span><br><span class="line">-- Inductive case: Hypothesise (g (f n) ≡ n) and prove (g (f (suc n)) ≡ suc n)</span><br><span class="line">--                           g (f (suc n)) ≡ suc n</span><br><span class="line">--                           g (cons empty (f n)) ≡ suc n   (by def. of f)</span><br><span class="line">--                           suc (g (f n)) ≡ suc n                (by def. of g)</span><br><span class="line">--                           suc n ≡ suc n                           (by inductive hypothesis)</span><br><span class="line"></span><br><span class="line">-- Prove: ∀ es ∈ List Unit. f (g es) ≡ es</span><br><span class="line">-- Base case: Prove (f (g nil) ≡ nil)</span><br><span class="line">--                    f (g nil) ≡ nil</span><br><span class="line">--                    f zero ≡ nil         (by def. of g)</span><br><span class="line">--                    nil ≡ nil              (by def. of f)</span><br><span class="line">-- Inductive case: Hypothesise (f (g es) ≡ es) and prove (f (g (cons empty es)) ≡ cons empty es)</span><br><span class="line">--                           f (g (cons unit es)) ≡ es</span><br><span class="line">--                           f (suc (g es)) ≡ cons empty es                (by def. of g)</span><br><span class="line">--                           cons empty (f (g es)) ≡ cons empty es  (by def. of f)</span><br><span class="line">--                           cons empty es ≡ cons empty es             (by inductive hypothesis)</span><br></pre></td></tr></table></figure>
<p><code>Nat ~ Option Nat</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">a : Nat → Option Nat</span><br><span class="line">a zero = None</span><br><span class="line">a (suc n) = Some n</span><br><span class="line"></span><br><span class="line">b : Option Nat → Nat</span><br><span class="line">b None = zero</span><br><span class="line">b (Some n) = suc n</span><br><span class="line"></span><br><span class="line">-- No induction required!</span><br><span class="line"></span><br><span class="line">-- Prove: ∀ n ∈ Nat. b (a n) ≡ n</span><br><span class="line">-- zero case: Prove (b (a zero) ≡ zero)</span><br><span class="line">--                 b (a zero) ≡ zero</span><br><span class="line">--                 b None ≡ zero       (by def. of a)</span><br><span class="line">--                 zero ≡ zero           (by def. of b)</span><br><span class="line">-- suc case: Prove (f (g (suc n)) ≡ suc n</span><br><span class="line">--                 b (a (suc n)) ≡ suc n</span><br><span class="line">--                 b (Some n) ≡ suc n   (by def. of a)</span><br><span class="line">--                 suc n ≡ suc n             (by def. of b)</span><br><span class="line"></span><br><span class="line">-- Prove: ∀ o ∈ Option Nat. a (b o) ≡ o</span><br><span class="line">-- None case: Prove (a (b None) ≡ None)</span><br><span class="line">--                    a (b None) ≡ None</span><br><span class="line">--                    a zero ≡ None            (by def. of b)</span><br><span class="line">--                    None ≡ None             (by def. of a)</span><br><span class="line">-- Some case: Prove ∀ n ∈ Nat. (a (b (Some n)) ≡ Some n)</span><br><span class="line">--                     a (b (Some n)) ≡ Some n</span><br><span class="line">--                     a (suc n) ≡ Some n           (by def. of b)</span><br><span class="line">--                     Some n ≡ Some n             (by def. of a)</span><br></pre></td></tr></table></figure>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/index.md">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-II"><span class="toc-number">1.</span> <span class="toc-text">Part II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming-part-Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">:Programming part Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Computer-Proof-Checking"><span class="toc-number">1.2.</span> <span class="toc-text">Computer Proof Checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types"><span class="toc-number">1.3.</span> <span class="toc-text">Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-amp-pattern-matching（模式匹配）"><span class="toc-number">1.4.</span> <span class="toc-text">Functions &amp; pattern matching（模式匹配）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-checking"><span class="toc-number">1.5.</span> <span class="toc-text">Type checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-inference-推理"><span class="toc-number">1.6.</span> <span class="toc-text">Type inference(推理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CH-correspondence-cont’d"><span class="toc-number">1.7.</span> <span class="toc-text">CH correspondence - cont’d</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inductive-types"><span class="toc-number">1.8.</span> <span class="toc-text">Inductive types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fold-reduce"><span class="toc-number">1.9.</span> <span class="toc-text">Fold(reduce)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#More-on-types"><span class="toc-number">1.10.</span> <span class="toc-text">More on types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Induction"><span class="toc-number">1.11.</span> <span class="toc-text">Induction</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&text=Computation"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&title=Computation"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&is_video=false&description=Computation"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Computation&body=Check out this article: https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&title=Computation"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&title=Computation"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&title=Computation"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&title=Computation"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Logic_part2/&name=Computation&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Wenye Jin
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/index.md">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'jwy';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
