<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Part ILecture1: introPropositional logic（命题逻辑）Natural Deductionno lecture on Tue 22ndweek 3 and 6:  assignmentsOffice hours: Mon 3-4pm, Thu 2-3pm. I am in room 133 Semantics, truth tableProof strategy">
<meta property="og:type" content="article">
<meta property="og:title" content="Log.logic">
<meta property="og:url" content="https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/index.html">
<meta property="og:site_name" content="WY J">
<meta property="og:description" content="Part ILecture1: introPropositional logic（命题逻辑）Natural Deductionno lecture on Tue 22ndweek 3 and 6:  assignmentsOffice hours: Mon 3-4pm, Thu 2-3pm. I am in room 133 Semantics, truth tableProof strategy">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-19T22:48:14.533Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Log.logic">
<meta name="twitter:description" content="Part ILecture1: introPropositional logic（命题逻辑）Natural Deductionno lecture on Tue 22ndweek 3 and 6:  assignmentsOffice hours: Mon 3-4pm, Thu 2-3pm. I am in room 133 Semantics, truth tableProof strategy">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Log.logic</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/jwyhhh123">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/02/19/Log-AI/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/02/18/hello-World/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&text=Log.logic"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&is_video=false&description=Log.logic"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Log.logic&body=Check out this article: https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&name=Log.logic&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-I"><span class="toc-number">1.</span> <span class="toc-text">Part I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture1-intro"><span class="toc-number">1.1.</span> <span class="toc-text">Lecture1: intro</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Propositional-logic（命题逻辑）"><span class="toc-number">1.2.</span> <span class="toc-text">Propositional logic（命题逻辑）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Natural-Deduction"><span class="toc-number">1.3.</span> <span class="toc-text">Natural Deduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semantics-truth-table"><span class="toc-number">1.4.</span> <span class="toc-text">Semantics, truth table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-strategy"><span class="toc-number">1.5.</span> <span class="toc-text">Proof strategy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equivalencies-and-normal-forms"><span class="toc-number">1.6.</span> <span class="toc-text">Equivalencies and normal forms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equivalencies"><span class="toc-number">1.7.</span> <span class="toc-text">Equivalencies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resolution-归结原理"><span class="toc-number">1.8.</span> <span class="toc-text">Resolution(归结原理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Satisfiability"><span class="toc-number">1.9.</span> <span class="toc-text">Satisfiability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-calculus-一阶逻辑"><span class="toc-number">1.10.</span> <span class="toc-text">Predicate calculus(一阶逻辑)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-calculus"><span class="toc-number">1.11.</span> <span class="toc-text">Predicate calculus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-Calculus-Proofs-amp-Identity"><span class="toc-number">1.12.</span> <span class="toc-text">Predicate Calculus: Proofs &amp; Identity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wrapping-Up-Summary"><span class="toc-number">1.13.</span> <span class="toc-text">Wrapping Up; Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-II"><span class="toc-number">2.</span> <span class="toc-text">Part II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming-part-Introduction"><span class="toc-number">2.1.</span> <span class="toc-text">:Programming part Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-Checking"><span class="toc-number">2.2.</span> <span class="toc-text">Proof Checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types"><span class="toc-number">2.3.</span> <span class="toc-text">Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-amp-pattern-matching（模式匹配）"><span class="toc-number">2.4.</span> <span class="toc-text">Functions &amp; pattern matching（模式匹配）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Isomorphisms"><span class="toc-number">2.5.</span> <span class="toc-text">Type Isomorphisms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-calculus-λ演算"><span class="toc-number">2.6.</span> <span class="toc-text">Lambda calculus(λ演算)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Church-encodings-编码"><span class="toc-number">2.7.</span> <span class="toc-text">Church encodings(编码)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-checking"><span class="toc-number">2.8.</span> <span class="toc-text">Type checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-inference-推理-given-a-proof-infer-to-its-type"><span class="toc-number">2.9.</span> <span class="toc-text">Type inference(推理): given a proof, infer to its type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-Prod-A-B"><span class="toc-number">2.10.</span> <span class="toc-text">Γ ⊢ t : Prod A B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-Prod-A-B-1"><span class="toc-number">2.11.</span> <span class="toc-text">Γ ⊢ t : Prod A B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-A-Γ-⊢-u-B"><span class="toc-number">2.12.</span> <span class="toc-text">Γ ⊢ t : A   Γ ⊢ u : B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-Sum-A-B-Γ-⊢-u-A-gt-C-Γ-⊢-v-B-gt-C"><span class="toc-number">2.13.</span> <span class="toc-text">Γ ⊢ t : Sum A B   Γ ⊢ u : A -&gt; C   Γ ⊢ v : B -&gt; C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-A"><span class="toc-number">2.14.</span> <span class="toc-text">Γ ⊢ t : A</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-B"><span class="toc-number">2.15.</span> <span class="toc-text">Γ ⊢ t : B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xs’-filter-zeros-xs"><span class="toc-number">2.16.</span> <span class="toc-text">  xs’ = filter-zeros xs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-false-y-y"><span class="toc-number">2.17.</span> <span class="toc-text">if false _ y = y</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Log.logic
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">WY J</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-02-19T00:05:02.000Z" itemprop="datePublished">2019-02-19</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h1><h2 id="Lecture1-intro"><a href="#Lecture1-intro" class="headerlink" title="Lecture1: intro"></a>Lecture1: intro</h2><h2 id="Propositional-logic（命题逻辑）"><a href="#Propositional-logic（命题逻辑）" class="headerlink" title="Propositional logic（命题逻辑）"></a>Propositional logic（命题逻辑）</h2><h2 id="Natural-Deduction"><a href="#Natural-Deduction" class="headerlink" title="Natural Deduction"></a>Natural Deduction</h2><p>no lecture on Tue 22nd<br>week 3 and 6:  assignments<br>Office hours: Mon 3-4pm, Thu 2-3pm. I am in room 133</p>
<h2 id="Semantics-truth-table"><a href="#Semantics-truth-table" class="headerlink" title="Semantics, truth table"></a>Semantics, truth table</h2><h2 id="Proof-strategy"><a href="#Proof-strategy" class="headerlink" title="Proof strategy"></a>Proof strategy</h2><h2 id="Equivalencies-and-normal-forms"><a href="#Equivalencies-and-normal-forms" class="headerlink" title="Equivalencies and normal forms"></a>Equivalencies and normal forms</h2><h2 id="Equivalencies"><a href="#Equivalencies" class="headerlink" title="Equivalencies"></a>Equivalencies</h2><h2 id="Resolution-归结原理"><a href="#Resolution-归结原理" class="headerlink" title="Resolution(归结原理)"></a>Resolution(归结原理)</h2><p>natural deduction:<br>&nbsp; 8 inference rules; formulas using ¬,∧,∨,→ –<br>resolution:<br>&nbsp; 1 inference rule; formulas all in <strong>CNF (clausal normal form)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &#123;A&#125; ∨ X1     &#123;¬A&#125; ∨ X2   </span><br><span class="line">------------------------ Resolution</span><br><span class="line">     X1 ∨ X2</span><br></pre></td></tr></table></figure></p>
<h2 id="Satisfiability"><a href="#Satisfiability" class="headerlink" title="Satisfiability"></a>Satisfiability</h2><p>“TheScienceofBruteForce”,MarijnJ.H.Heule,OliverKullmann  – <a href="https://cacm.acm.org/magazines/2017/8/219606-the-science-of-brute-force/fulltext" target="_blank" rel="noopener">https://cacm.acm.org/magazines/2017/8/219606-the-science-of-brute-force/fulltext</a> – state-of-the-artSATandautomatedmathematicalproofs  <br>Z3: a theorem prover, including both SAT/SMT solvers – <a href="https://rise4fun.com/z3/tutorial" target="_blank" rel="noopener">https://rise4fun.com/z3/tutorial</a> </p>
<h2 id="Predicate-calculus-一阶逻辑"><a href="#Predicate-calculus-一阶逻辑" class="headerlink" title="Predicate calculus(一阶逻辑)"></a>Predicate calculus(一阶逻辑)</h2><p>∀-elimination<br>∃-introduction</p>
<h2 id="Predicate-calculus"><a href="#Predicate-calculus" class="headerlink" title="Predicate calculus"></a>Predicate calculus</h2><p>∀-introduction<br>∃-elimination</p>
<h2 id="Predicate-Calculus-Proofs-amp-Identity"><a href="#Predicate-Calculus-Proofs-amp-Identity" class="headerlink" title="Predicate Calculus: Proofs &amp; Identity"></a>Predicate Calculus: Proofs &amp; Identity</h2><p>Relations; Equivalence relation<br>Identity<br>Quantities: ∃x: at least 1, ∀x: all, ¬∃x: 0</p>
<h2 id="Wrapping-Up-Summary"><a href="#Wrapping-Up-Summary" class="headerlink" title="Wrapping Up; Summary"></a>Wrapping Up; Summary</h2><p>2 inference rules for Indentity:</p>
<ul>
<li>=-introduction</li>
<li>=-elimination</li>
</ul>
<h1 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h1><h2 id="Programming-part-Introduction"><a href="#Programming-part-Introduction" class="headerlink" title=":Programming part Introduction"></a>:Programming part Introduction</h2><p>paradox(悖论): “what i am saying is wrong”<br>a formal system</p>
<ul>
<li>sound(true then cannot be false)</li>
<li>complete(true or false can be determined)</li>
<li>computable(be computed by machine)<br>Λ演算: <a href="https://zh.wikipedia.org/wiki/Λ演算" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Λ演算</a><br>: <a href="https://blog.csdn.net/zdarks/article/details/46994939" target="_blank" rel="noopener">https://blog.csdn.net/zdarks/article/details/46994939</a></li>
</ul>
<h2 id="Proof-Checking"><a href="#Proof-Checking" class="headerlink" title="Proof Checking"></a>Proof Checking</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p: P     p is a proof of P</span><br><span class="line">p: P -&gt; Q     1) p is a proof of P -&gt; Q  </span><br><span class="line">              2) p is a rule for converting P into Q</span><br><span class="line">¬ p = not P = P -&gt; Falsity = P -&gt; ⊥</span><br></pre></td></tr></table></figure>
<p>and-elimination:</p>
<ul>
<li>andEl : {P Q : Prop}   -&gt; P and Q -&gt; P</li>
<li>andEr : {P Q : Prop}   -&gt; P and Q -&gt; Q</li>
</ul>
<p>and-introduction:</p>
<ul>
<li>andI : {P Q : Prop}   -&gt; P -&gt; Q -&gt; P and Q</li>
</ul>
<p>or-introduction</p>
<ul>
<li>orIl : {P Q : Prop}   -&gt; p -&gt; P or Q</li>
<li>orIr : {P Q : Prop}   -&gt; Q -&gt; P or Q</li>
</ul>
<p>or-elimination</p>
<ul>
<li>orE : {P Q R : Prop}   -&gt; P or Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R</li>
</ul>
<p>falsity-elimination (⊥：any P)</p>
<ul>
<li>ENQ : {P : Prop}   -&gt; Falsity -&gt; P</li>
</ul>
<p>double-negation-elimination</p>
<ul>
<li>DNE : {P : Prop}  -&gt; (not (not P)) -&gt; P</li>
</ul>
<p>Modus ponens<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mp: &#123;P Q : Prop&#125;  -&gt; (P -&gt; Q) -&gt; P -&gt; Q</span><br><span class="line">mp  &#123;P&#125; &#123;Q&#125;          f           p  = q where</span><br><span class="line">   q: Q        //declearation</span><br><span class="line">   q = f p     //operation</span><br></pre></td></tr></table></figure></p>
<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>.basic data types<br>using agda, we are <strong>defining data</strong> types by ourselves.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data unit : Set where</span><br><span class="line">  empty: unit</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>data</code> : introduces the definition</li>
<li><code>Void</code> : the name of the type (can be almost anything, including unicode)</li>
<li><code>Set</code> : it confirms that <code>Void</code> is a type (Agda, confusingly, calls types “sets”)</li>
<li><code>where</code> : introduces the <em>constructors</em>.</li>
<li><code>empty</code> : constructor</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data Void : Set where</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data Boolean : Set where</span><br><span class="line">  true false : Boolean</span><br></pre></td></tr></table></figure>
<p>composite types: given some types, construct new types<br>.product (or tuples)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data Prod (X Y : Set) : Set where</span><br><span class="line">  pair : X -&gt; Y -&gt; Prod X Y</span><br></pre></td></tr></table></figure></p>
<p>.sum or .union<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Sum (A B : Set) : Set where</span><br><span class="line">  left  : A -&gt; Sum A B</span><br><span class="line">  right : B -&gt; Sum A B</span><br></pre></td></tr></table></figure></p>
<p>.algebraic types</p>
<ul>
<li>void       0</li>
<li>unit       1</li>
<li>sum A B    A+B</li>
<li>Pred A B   AxB</li>
<li>void       null</li>
</ul>
<p>&nbsp; If type <code>A</code> has <code>m</code> elements and type <code>B</code> has <code>n</code> elements, then:</p>
<ul>
<li>How many elements has <code>Sum A B</code>?  m+n</li>
<li>How many elements has <code>Prod A B</code>?  mxn</li>
</ul>
<blockquote>
<ul>
<li>can we define any element of <code>Prod A Void</code> for some <code>A</code>?       null</li>
<li>can we define any element of <code>Sum A Void</code> for some <code>A</code>?     A</li>
</ul>
</blockquote>
<h2 id="Functions-amp-pattern-matching（模式匹配）"><a href="#Functions-amp-pattern-matching（模式匹配）" class="headerlink" title="Functions &amp; pattern matching（模式匹配）"></a>Functions &amp; pattern matching（模式匹配）</h2><p>Pattern matching enumerations </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and : Boolean -&gt; Boolean -&gt; Boolean</span><br><span class="line">and true  true  = true</span><br><span class="line">and true  false = false</span><br><span class="line">and false true  = false</span><br><span class="line">and false false = false         //all cases are required to be covered.</span><br></pre></td></tr></table></figure>
<p>Pattern matching <code>prod</code>: so-called “projections”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proj1 : &#123;A B : Set&#125; -&gt; Prod A B -&gt; A</span><br><span class="line">proj1 (pair a _) = a                    ... b is unused ...</span><br><span class="line"></span><br><span class="line">proj2 : &#123;A B : Set&#125; -&gt; Prod A B -&gt; B</span><br><span class="line">proj2 (pair _ b) = b                    ... a is unused ...</span><br></pre></td></tr></table></figure></p>
<p>Pattern matching <code>sum</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f : Sum Unit Unit -&gt; Boolean</span><br><span class="line">f (left x)  = true</span><br><span class="line">f (right y) = false</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g : Boolean -&gt; Sum Unit Unit</span><br><span class="line">g true  = left empty</span><br><span class="line">g false = right empty</span><br></pre></td></tr></table></figure>
<p>A special case<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">impossible : &#123;A : Set&#125; -&gt; void -&gt; A</span><br><span class="line">  impossible ()</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>()</code> matches <code>void</code></li>
</ul>
<p><strong>Example:</strong> Convert between <code>Sum A Void</code> and <code>A</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">j : &#123;A : Set&#125; -&gt; Sum A Void -&gt; A</span><br><span class="line">j (left a)   = a</span><br><span class="line">j (right ())</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Example:</strong> Since in general <code>A + A = 2 * A</code> let’s see how we can convert between <code>Sum A A</code> and <code>Prod Boolean A</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h : &#123;A : Set&#125; -&gt; Sum A A -&gt; Prod Boolean A</span><br><span class="line">h (left a)  = pair true a</span><br><span class="line">h (right a) = pair true a </span><br><span class="line"></span><br><span class="line">i : &#123;A : Set&#125; -&gt; Prod Boolean A -&gt; Sum A A</span><br><span class="line">i (pair true a)  = left a</span><br><span class="line">i (pair false a) = right a</span><br></pre></td></tr></table></figure>
<h2 id="Type-Isomorphisms"><a href="#Type-Isomorphisms" class="headerlink" title="Type Isomorphisms"></a>Type Isomorphisms</h2><p><code>f : A -&gt; B</code> and <code>g : B -&gt; A</code> means that the two types are <strong><em>isomorphic</em></strong>, written <code>A ~ B</code>.</p>
<p>If we write <code>Void</code> as <code>0</code>, <code>Unit</code> as <code>1</code>, <code>Prod A B</code> as <code>A x B</code>,  <code>Sum A B</code> as <code>A + B</code> we can see that many type isomorphisms are consistent with calling these data typs <em>algebraic</em>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* Semi-ring</span><br><span class="line"></span><br><span class="line">A + (B + C) \sim (A + B) + C \\</span><br><span class="line">A + B \sim B + A\\</span><br><span class="line">A + B \sim A\\</span><br><span class="line">A \times (B \times C) \sim (A\times B) \times C\\</span><br><span class="line">A \times B \sim B \times A\\</span><br><span class="line">A \times 1 \sim A\\</span><br><span class="line">A \times (B + C) \sim A \times B + A \times C\\</span><br><span class="line">(A + B) \times C \sim A \times C + B \times C\\</span><br><span class="line">A \times 0 \sim 0</span><br></pre></td></tr></table></figure>
<p>Curry-Howard Correspondence</p>
<ul>
<li><code>Falsity ~ Void</code></li>
<li><code>Truth   ~ Unit</code></li>
<li><code>A and B ~ Prod A B</code> </li>
<li><code>A or B  ~ Sum A B</code></li>
</ul>
<p>&nbsp;<em>postulate</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">andEl  : &#123;P Q : Prop&#125;   -&gt; P and Q -&gt; P</span><br><span class="line">andEr  : &#123;P Q : Prop&#125;   -&gt; P and Q -&gt; Q</span><br><span class="line">andI   : &#123;P Q : Prop&#125;   -&gt; P -&gt; Q -&gt; P and Q</span><br><span class="line">orE    : &#123;P Q R : Prop&#125; -&gt; P or Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R</span><br><span class="line">orIl   : &#123;P Q : Prop&#125;   -&gt; P -&gt; P or Q</span><br><span class="line">orIr   : &#123;P Q : Prop&#125;   -&gt; Q -&gt; Q or P</span><br><span class="line">EFQ    : &#123;P : Prop&#125;     -&gt; Falsity -&gt; P</span><br><span class="line">DNE    : &#123;P : Prop&#125;     -&gt; (not (not P)) -&gt; P</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;<em>funtions</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">andEl&apos; : &#123;P Q : Set&#125; -&gt; Prod P Q -&gt; P</span><br><span class="line">andEl&apos; (pair p _) = p</span><br><span class="line"></span><br><span class="line">andEr&apos; : &#123;P Q : Set&#125; -&gt; Prod P Q -&gt; Q</span><br><span class="line">andEr&apos; (pair _ q) = q</span><br><span class="line"></span><br><span class="line">andI&apos; : &#123;P Q : Set&#125; -&gt; P -&gt; Q -&gt; Prod P Q</span><br><span class="line">andI&apos; p q = pair p q</span><br><span class="line"></span><br><span class="line">orE&apos; : &#123;P Q R : Set&#125; -&gt; Sum P Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R</span><br><span class="line">orE&apos; (left p)  f g = f p</span><br><span class="line">orE&apos; (right q) f g = g q</span><br><span class="line"></span><br><span class="line">orIl&apos; : &#123;P Q : Set&#125; -&gt; P -&gt; Sum P Q</span><br><span class="line">orIl&apos; p = left p</span><br><span class="line"></span><br><span class="line">orIr&apos; : &#123;P Q : Set&#125; -&gt; Q -&gt; Sum P Q</span><br><span class="line">orIr&apos; q = right q</span><br><span class="line"></span><br><span class="line">EFQ&apos; : &#123;P : Set&#125; -&gt; Void -&gt; P</span><br><span class="line">EFQ&apos; ()</span><br></pre></td></tr></table></figure></p>
<p>proof relevance<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">suu-u : Sum Unit Unit -&gt; Unit</span><br><span class="line">suu-u (left empty) = empty</span><br><span class="line">suu-u (right empty) = empty </span><br><span class="line"></span><br><span class="line">u-suu : Unit -&gt; Sum Unit Unit</span><br><span class="line">u-suu empty = left empty</span><br></pre></td></tr></table></figure></p>
<ul>
<li>this is not isomophic</li>
<li>it is not the case that <code>1 + 1 ~ 1</code>.</li>
</ul>
<h2 id="Lambda-calculus-λ演算"><a href="#Lambda-calculus-λ演算" class="headerlink" title="Lambda calculus(λ演算)"></a>Lambda calculus(λ演算)</h2><p><strong>def:</strong> formalise the concept of computability using a simple notion of <em>functions</em>.<br>&nbsp;-One of the ways we can understand functions is as a mapping from some inputs to some outputs.</p>
<ul>
<li>Variable:    <code>x</code>  </li>
<li>Abstraction: <code>λx.F</code>  </li>
<li>Application: <code>f x</code></li>
</ul>
<p>In <strong>Agda</strong> we write <code>\x -&gt; F</code>.<br><code>x</code>: variable binding<br><code>F</code>: term, <em>i.e.</em> an expression formed of variables, function application, and function definition. </p>
<p>&nbsp;<em>Example:</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(\x -&gt; x + 1) 7 </span><br><span class="line">  = 7 + 1 </span><br><span class="line">  = 8</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(\x y -&gt; x + y) 7 8 </span><br><span class="line">  = (\y -&gt; 7 + y) 8 </span><br><span class="line">  = 7 + 8 </span><br><span class="line">  = 15</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(\x -&gt; x + 1) ((\y -&gt; y + 1) 2) </span><br><span class="line">  = (\x -&gt; x + 1) (2 + 1)</span><br><span class="line">  = (\x -&gt; x + 1) 3</span><br><span class="line">  = 3 + 1</span><br><span class="line">  = 4</span><br></pre></td></tr></table></figure>
<p>“higher-order” functions:</p>
<ul>
<li>takes one or more functions as arguments (i.e. procedural parameters),</li>
<li>returns a function as its result.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(\f x -&gt; f (f x)) (\y -&gt; y + 1)</span><br><span class="line">  = \x -&gt; (\y -&gt; y + 1) ((\z -&gt; z + 1) x)</span><br><span class="line">  = \x -&gt; (\y -&gt; y + 1) (x + 1)</span><br><span class="line">  = \x -&gt; (x + 1) + 1</span><br><span class="line">  = \x -&gt; x + 2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Church-encodings-编码"><a href="#Church-encodings-编码" class="headerlink" title="Church encodings(编码)"></a>Church encodings(编码)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true = \a b -&gt; a</span><br><span class="line">false = \a b -&gt; b</span><br><span class="line">and = \p q -&gt; p q p</span><br><span class="line">or = \p q -&gt; p p q</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and true false </span><br><span class="line">  = (\p q -&gt; p q p) true false</span><br><span class="line">  = true false true</span><br><span class="line"></span><br><span class="line">  = (\a b -&gt; a) false true</span><br><span class="line">  = false</span><br></pre></td></tr></table></figure>
<p>The Y combinator: encodes <em>recursion</em><br><code>Y = \f -&gt; (\x -&gt; f(x x)) (\x -&gt; f(x x))</code></p>
<p>For any function <code>g</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Y g = (\x -&gt; g(x x)) (\x g(x x))</span><br><span class="line">  = g(((\x -&gt; g(x x)))((\x -&gt; g(x x))))</span><br><span class="line">  = g(Y g)</span><br><span class="line">  ...</span><br><span class="line">  = g (g (Y g))</span><br><span class="line">  ...</span><br><span class="line">  = g (g (g (Y g)))</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<h2 id="Type-checking"><a href="#Type-checking" class="headerlink" title="Type checking"></a>Type checking</h2><p>Type judgements</p>
<ul>
<li><code>Γ</code> is a list of elements of the form <code>x:A</code> where <code>x</code> is a variable and <code>A</code> is a type</li>
<li><code>t</code> is a lambda calculus term</li>
<li><code>A</code> is a type.</li>
</ul>
<p><strong>rules:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A -&gt; B   Γ ⊢ u : A</span><br><span class="line">---------------------------[App]</span><br><span class="line">Γ ⊢ t u : B</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ, x:A ⊢ t : B</span><br><span class="line">--------------[Abs]</span><br><span class="line">Γ ⊢ t : A -&gt; B</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------[Axi]</span><br><span class="line">Γ, x:A ⊢ x : A</span><br></pre></td></tr></table></figure>
<p>&nbsp; <em>example:</em><br>&nbsp; check: <code>⊢ \x y z -&gt; y (x z) : (A -&gt; B) -&gt; (B -&gt; C) -&gt; (A -&gt; C)</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                        ------------------------------[Axi] ----------------------------[Axi]</span><br><span class="line">                                                     Γ ⊢ x : A-&gt;B                Γ ⊢ Z : A</span><br><span class="line">----------------------------------[Axi] ----------------------------------------------------------------[App]</span><br><span class="line">    Γ ⊢ y : (B -&gt; C)                           Γ ⊢ x z : B</span><br><span class="line">----------------------------------------------------------------------[App]</span><br><span class="line">x:A-&gt;B, y:B-&gt;C, z:A ⊢ y (x z) : C</span><br><span class="line">-----------------------------------------------------[Abs x 3]</span><br><span class="line">⊢ \x y z -&gt; y (x z) : (A -&gt; B) -&gt; (B -&gt; C) -&gt; (A -&gt; C)</span><br></pre></td></tr></table></figure>
<h2 id="Type-inference-推理-given-a-proof-infer-to-its-type"><a href="#Type-inference-推理-given-a-proof-infer-to-its-type" class="headerlink" title="Type inference(推理): given a proof, infer to its type"></a>Type inference(推理): given a proof, infer to its type</h2><p>unification: two sets of terms, find values for the terms such that the terms are equal</p>
<ul>
<li>type reduction: <code>t1 -&gt; t2 = t3 -&gt; t4</code> is broken into <code>t1 = t3</code> and <code>t2 = t4</code></li>
<li>variable elimination: x= A —-&gt; x /A (<em>substitue all x with u</em>)</li>
<li>A set of equations is <em>solved</em> if <ul>
<li>all equations have form <code>x = t</code> with <code>x</code> a variable</li>
<li>every variable on the left occurs only in that place.</li>
</ul>
</li>
</ul>
<p><strong>Basic unification algorithm</strong></p>
<ol>
<li>Change all equations <code>t = x</code> where <code>t</code> is not a variable and <code>x</code> is a variable to <code>x = t</code>.</li>
<li>Remove all equations <code>x = x</code> where <code>x</code> is a variable.</li>
<li>Select an equation <code>u = v</code> where neither is a variable and apply <em>type reduction</em>.<br>If type reduction is impossible, <em>fail</em>.</li>
<li>Select an equation <code>x = t</code> where <code>x</code>, where <code>t ≠ x</code>. If <code>x ∈ t</code> then <em>fail</em> else apply <em>variable elimination</em>. </li>
<li>Repeat until <em>solved</em>.</li>
</ol>
<p><strong>Basic type inference</strong><br>S1. Construct the type derivation tree for the term using variables instead of types.<br>S2. Add constraints as follows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A   Γ ⊢ u : B</span><br><span class="line">---------------------------[A = B -&gt; C]</span><br><span class="line">Γ ⊢ t u : C</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Γ, x:A ⊢ t : B</span><br><span class="line">--------------[C = A -&gt; B]</span><br><span class="line">Γ ⊢ t : C</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>————–[B = A]<br>Γ, x:A ⊢ x : B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S3.  Collect and solve the system of constraints. </span><br><span class="line"></span><br><span class="line">&amp;nbsp; _Example:_ </span><br><span class="line">&amp;nbsp; Let us infer the type of `\x y z -&gt; y (x z)`. The derivation tree is:</span><br></pre></td></tr></table></figure></p>
<pre><code>------------------------------[J = B] ----------------------[K = F]
x:B, y:D, z:F ⊢ x : J                 x:B, y:D, z:F ⊢ Z : K
</code></pre><p>———————[H = D] ————————————————————[J = K -&gt; I]<br>x:B, y:D, z:F ⊢ y : H        x:B, y:D, z:F ⊢ x z : I<br>—————————————————–[H = I -&gt; G]<br>x:B, y:D, z:F ⊢ y (x z) : G<br>—————————-[E = F -&gt; G]<br>x:B, y:D ⊢ \z -&gt; y (x z) : E<br>—————————–[C = D -&gt; E]<br>x:B ⊢ \y z -&gt; y (x z) : C<br>————————–[A = B -&gt; C]<br>⊢ \x y z -&gt; y (x z) : A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We collect the following constraints:</span><br></pre></td></tr></table></figure></p>
<p>A = B -&gt; C<br>C = D -&gt; E<br>E = F -&gt; G<br>H = I -&gt; G<br>H = D<br>J = K -&gt; I<br>B = J<br>F = K<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Applying the unification algorithm we get:</span><br></pre></td></tr></table></figure></p>
<p>A = (K -&gt; I) -&gt; (I -&gt; G) -&gt; K -&gt; G<br>C = D -&gt; F -&gt; G<br>E = F -&gt; G<br>H = I -&gt; G<br>D = I -&gt; G<br>J = K -&gt; I<br>B = K -&gt; I<br>F = K<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* checked: all equations have form `x = t` with `x` a variable</span><br><span class="line">* checked: every variable on the left occurs only in that place.</span><br><span class="line"></span><br><span class="line">Typing non-termination</span><br><span class="line">Terms `Y` and `omega` are non-terminating in **Agda**</span><br><span class="line"></span><br><span class="line">## Curry-Howord correspondence</span><br><span class="line"></span><br><span class="line">isomorphisms</span><br></pre></td></tr></table></figure></p>
<p>cur : {A B C : Set} -&gt; ((Prod C B ) -&gt; A) -&gt; (C -&gt; B -&gt; A)<br>cur f c b = f (pair c b)</p>
<p>uncur : {A B C : Set} -&gt; (C -&gt; B -&gt; A) -&gt; ((Prod C B) -&gt; A)<br>uncur f (pair c b) = f c b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## CH correspondence: props &lt;-&gt; types || proofs &lt;-&gt; terms (programs)</span><br><span class="line">* Product Elimination Left: (**-and eli**)</span><br></pre></td></tr></table></figure>
<h2 id="Γ-⊢-t-Prod-A-B"><a href="#Γ-⊢-t-Prod-A-B" class="headerlink" title="Γ ⊢ t : Prod A B"></a>Γ ⊢ t : Prod A B</h2><p>Γ ⊢ proj1 t : A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Product Elimination Right: (**-and eli**)</span><br></pre></td></tr></table></figure></p>
<h2 id="Γ-⊢-t-Prod-A-B-1"><a href="#Γ-⊢-t-Prod-A-B-1" class="headerlink" title="Γ ⊢ t : Prod A B"></a>Γ ⊢ t : Prod A B</h2><p>Γ ⊢ proj2 t : B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Product Introduction: (**-and intr**)</span><br></pre></td></tr></table></figure></p>
<h2 id="Γ-⊢-t-A-Γ-⊢-u-B"><a href="#Γ-⊢-t-A-Γ-⊢-u-B" class="headerlink" title="Γ ⊢ t : A   Γ ⊢ u : B"></a>Γ ⊢ t : A   Γ ⊢ u : B</h2><p>Γ ⊢ andI t u : Prod A B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Sum Elimination: (**-or eli**)</span><br></pre></td></tr></table></figure></p>
<h2 id="Γ-⊢-t-Sum-A-B-Γ-⊢-u-A-gt-C-Γ-⊢-v-B-gt-C"><a href="#Γ-⊢-t-Sum-A-B-Γ-⊢-u-A-gt-C-Γ-⊢-v-B-gt-C" class="headerlink" title="Γ ⊢ t : Sum A B   Γ ⊢ u : A -&gt; C   Γ ⊢ v : B -&gt; C"></a>Γ ⊢ t : Sum A B   Γ ⊢ u : A -&gt; C   Γ ⊢ v : B -&gt; C</h2><p>Γ ⊢  orE t u v : Sum A B -&gt; (A -&gt; C) -&gt; (B -&gt; C) -&gt; C</p>
<p> pattern match (left a) = f a<br>               (right b) = g b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Sum Introduction Left: (**-or intr**)</span><br></pre></td></tr></table></figure></p>
<h2 id="Γ-⊢-t-A"><a href="#Γ-⊢-t-A" class="headerlink" title="Γ ⊢ t : A"></a>Γ ⊢ t : A</h2><p>Γ ⊢ orIl t : Sum A B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* Sum Introduction Right: (**-or intr**)</span><br></pre></td></tr></table></figure></p>
<h2 id="Γ-⊢-t-B"><a href="#Γ-⊢-t-B" class="headerlink" title="Γ ⊢ t : B"></a>Γ ⊢ t : B</h2><p>Γ ⊢ orIr t : Sum A B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* _Ex Falso Quodlibet_</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Γ ⊢ EFQ : Void -&gt; A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Recursive types and structural recursion</span><br><span class="line">.Peano numbers</span><br><span class="line">* zero</span><br><span class="line">* succ</span><br><span class="line"></span><br><span class="line">.Lists</span><br><span class="line">* empty list</span><br><span class="line">* add one element into emptylist</span><br></pre></td></tr></table></figure></p>
<p>data Nat : Set where<br>  zero : Nat<br>  suc  : Nat -&gt; Nat<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* `data` is a keyword indicating a type definition</span><br><span class="line">* `Nat` is the identifier we choose for the type</span><br><span class="line">* `Set` is the built-in identifier for types  </span><br><span class="line">  (`data Nat : Set` says _we are defining a type called `Nat`_.)</span><br><span class="line">* `where` is introducing the definitions, which need to be indented</span><br><span class="line">* `zero` is the name of one of the **constructors**</span><br><span class="line">* `suc` is a **constructor** that takes a `Nat` as an argument and produces another `Nat`.</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">* `zero` is what you would normally write 0</span><br><span class="line">* `suc zero` is what you would normally write 1</span><br><span class="line">* `suc (suc zero)` is 2</span><br><span class="line">* `suc (suc (suc zero)))` is 3</span><br><span class="line"></span><br><span class="line">.zero test (pattern matching)</span><br></pre></td></tr></table></figure></p>
<p>is-zero : Nat -&gt; Boolean<br>is-zero : zero = true<br>is-zero : (suc _) = false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.Doubling</span><br></pre></td></tr></table></figure></p>
<p>dbl : Nat -&gt; Nat<br>dbl zero = zero<br>dbl (suc n) = suc (suc (dbl n))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*heuristic:* 1+n -&gt; 1+n+1+n = 1+ 1+ dbl n</span><br><span class="line"></span><br><span class="line">.Addition</span><br></pre></td></tr></table></figure></p>
<p>add : Nat -&gt; Nat -&gt; Nat<br>add zero n = n<br>add (suc m) n = suc (add m n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*heuristic:* 1+ m+ 1+ n = 1+ 1+ (m+n) = suc (suc (add m n))</span><br><span class="line"></span><br><span class="line">**Structural recursion:** if arg is getting smaller, it is allowed to find the answer</span><br><span class="line"></span><br><span class="line">.Halving</span><br></pre></td></tr></table></figure></p>
<p>half : Nat -&gt; Nat<br>half zero = zero<br>half (suc zero) =zero<br>half (suc (suc n)) = suc (half n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*heuristic:* (1+1+m)/2 = 1+ half n</span><br><span class="line"></span><br><span class="line">## Lists</span><br></pre></td></tr></table></figure></p>
<p>data : List (A : Set) : Set where<br>  nil  : List A<br>  cons : A -&gt; List A -&gt; List A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* `nil`: empty list constructor</span><br><span class="line">* `cons`: constructor that takes an element of `A` (called _head_) and a list (called _tail_). </span><br><span class="line"></span><br><span class="line">For example: </span><br><span class="line">* `cons 1 nil` is the list [1]</span><br><span class="line">* `cons 1 (cons 2 nil)` is the list [1, 2]</span><br><span class="line">* `cons true (cons false nil)` is the list [true, false]</span><br><span class="line"></span><br><span class="line">Also note that the we can have a list of lists:</span><br></pre></td></tr></table></figure></p>
<p>x = cons 0 nil          … [0]<br>y = cons 1 x            … [1, 0]<br>z = cons x (cons y nil) … [[1, 0], [0]]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.empty-check:</span><br></pre></td></tr></table></figure></p>
<p>empty : {A : Set} -&gt; List A -&gt; Boolean<br>empty nil = true<br>empty _   = false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.length of a list:</span><br></pre></td></tr></table></figure></p>
<p>len : {A : Set} -&gt; List A -&gt; Nat<br>len nil         = zero<br>len (cons _ xs) = suc (len xs)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.Appending two lists:</span><br></pre></td></tr></table></figure></p>
<p>append : {A : Set} -&gt; List A -&gt; List A -&gt; List A<br>append nil ys = ys<br>append (cons x xs) ys = cons x (append xs ys)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.reverse a list:</span><br></pre></td></tr></table></figure></p>
<p>rev : {A : Set} -&gt; List A -&gt; List A<br>rev nil = nil<br>rev (cons x xs) = append (rev xs) (cons x nil)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.filtering a list: return a list leaves out some elements</span><br></pre></td></tr></table></figure></p>
<p>filter-zeros : List Nat -&gt; List Nat<br>filter-zeros nil = nil<br>filter-zeros (cons x xs) = if (is-zero x) xs’ (cons x xs’) where</p>
<h2 id="xs’-filter-zeros-xs"><a href="#xs’-filter-zeros-xs" class="headerlink" title="  xs’ = filter-zeros xs"></a>  xs’ = filter-zeros xs</h2><p>if : {A : Set} -&gt; Boolean -&gt; A -&gt; A -&gt; A<br>if true  x  _ = x</p>
<h2 id="if-false-y-y"><a href="#if-false-y-y" class="headerlink" title="if false _ y = y"></a>if false _ y = y</h2><p>is-zero : Nat -&gt; Bool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deep pattern-matching:</span><br></pre></td></tr></table></figure></p>
<p>filter-zeros : List Nat -&gt; List Nat<br>filter-zeros nil = nil<br>filter-zeros (cons zero xs) = filter-zeros xs<br>filter-zeros (cons (suc n) xs) = cons (suc n) (filter-zeros xs)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">But suppose that we have a function `is-even : Nat -&gt; Boolean` to test for even-ness or `is-prime : Nat -&gt; Boolean` to test for primality. Filtering for some given property has very similar shape:</span><br></pre></td></tr></table></figure></p>
<p>filter-zeros : List Nat -&gt; List Nat<br>filter-zeros nil = nil<br>filter-zeros (cons x xs) = if (is-zero x) xs’ (cons x xs’) where<br>  xs’ = filter-zeros xs</p>
<p>filter-evens : List Nat -&gt; List Nat<br>filter-evens nil = nil<br>filter-evens (cons x xs) = if (is-even x) xs’ (cons x xs’) where<br>  xs’ = filter-evens xs</p>
<p>filter-primes : List Nat -&gt; List Nat<br>filter-primes nil = nil<br>filter-primes (cons x xs) = if (is-prime x) xs’ (cons x xs’) where<br>  xs’ = filter-primes xs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">This means that we can define a _generic_ filter function for any property (predicate) expressed by a function `p : A -&gt; Boolean` where `A` is the type of list elements:</span><br></pre></td></tr></table></figure></p>
<p>filter : {A : Set} -&gt; (A -&gt; Bool) -&gt; List A -&gt; List A<br>filter p nil = nil<br>filter p (cons x xs) = if (p x) xs’ (cons x xs’) where<br>  xs’ = filter p xs<br><code>`</code></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/jwyhhh123">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-I"><span class="toc-number">1.</span> <span class="toc-text">Part I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture1-intro"><span class="toc-number">1.1.</span> <span class="toc-text">Lecture1: intro</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Propositional-logic（命题逻辑）"><span class="toc-number">1.2.</span> <span class="toc-text">Propositional logic（命题逻辑）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Natural-Deduction"><span class="toc-number">1.3.</span> <span class="toc-text">Natural Deduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semantics-truth-table"><span class="toc-number">1.4.</span> <span class="toc-text">Semantics, truth table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-strategy"><span class="toc-number">1.5.</span> <span class="toc-text">Proof strategy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equivalencies-and-normal-forms"><span class="toc-number">1.6.</span> <span class="toc-text">Equivalencies and normal forms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equivalencies"><span class="toc-number">1.7.</span> <span class="toc-text">Equivalencies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resolution-归结原理"><span class="toc-number">1.8.</span> <span class="toc-text">Resolution(归结原理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Satisfiability"><span class="toc-number">1.9.</span> <span class="toc-text">Satisfiability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-calculus-一阶逻辑"><span class="toc-number">1.10.</span> <span class="toc-text">Predicate calculus(一阶逻辑)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-calculus"><span class="toc-number">1.11.</span> <span class="toc-text">Predicate calculus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-Calculus-Proofs-amp-Identity"><span class="toc-number">1.12.</span> <span class="toc-text">Predicate Calculus: Proofs &amp; Identity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wrapping-Up-Summary"><span class="toc-number">1.13.</span> <span class="toc-text">Wrapping Up; Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-II"><span class="toc-number">2.</span> <span class="toc-text">Part II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming-part-Introduction"><span class="toc-number">2.1.</span> <span class="toc-text">:Programming part Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-Checking"><span class="toc-number">2.2.</span> <span class="toc-text">Proof Checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types"><span class="toc-number">2.3.</span> <span class="toc-text">Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-amp-pattern-matching（模式匹配）"><span class="toc-number">2.4.</span> <span class="toc-text">Functions &amp; pattern matching（模式匹配）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Isomorphisms"><span class="toc-number">2.5.</span> <span class="toc-text">Type Isomorphisms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-calculus-λ演算"><span class="toc-number">2.6.</span> <span class="toc-text">Lambda calculus(λ演算)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Church-encodings-编码"><span class="toc-number">2.7.</span> <span class="toc-text">Church encodings(编码)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-checking"><span class="toc-number">2.8.</span> <span class="toc-text">Type checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-inference-推理-given-a-proof-infer-to-its-type"><span class="toc-number">2.9.</span> <span class="toc-text">Type inference(推理): given a proof, infer to its type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-Prod-A-B"><span class="toc-number">2.10.</span> <span class="toc-text">Γ ⊢ t : Prod A B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-Prod-A-B-1"><span class="toc-number">2.11.</span> <span class="toc-text">Γ ⊢ t : Prod A B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-A-Γ-⊢-u-B"><span class="toc-number">2.12.</span> <span class="toc-text">Γ ⊢ t : A   Γ ⊢ u : B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-Sum-A-B-Γ-⊢-u-A-gt-C-Γ-⊢-v-B-gt-C"><span class="toc-number">2.13.</span> <span class="toc-text">Γ ⊢ t : Sum A B   Γ ⊢ u : A -&gt; C   Γ ⊢ v : B -&gt; C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-A"><span class="toc-number">2.14.</span> <span class="toc-text">Γ ⊢ t : A</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Γ-⊢-t-B"><span class="toc-number">2.15.</span> <span class="toc-text">Γ ⊢ t : B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xs’-filter-zeros-xs"><span class="toc-number">2.16.</span> <span class="toc-text">  xs’ = filter-zeros xs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-false-y-y"><span class="toc-number">2.17.</span> <span class="toc-text">if false _ y = y</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&text=Log.logic"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&is_video=false&description=Log.logic"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Log.logic&body=Check out this article: https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&name=Log.logic&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Wenye Jin
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/jwyhhh123">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
