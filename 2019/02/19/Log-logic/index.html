<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Part IPropositional logic（命题逻辑）propositiondef : a sentence which states a fact (true or false)argumentP1, …, Pn : CP1, …, Pn ⊢ C    an argument can have 0 and more premises and 1 conclusion. an argume">
<meta property="og:type" content="article">
<meta property="og:title" content="Log.logic">
<meta property="og:url" content="https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/index.html">
<meta property="og:site_name" content="WY J">
<meta property="og:description" content="Part IPropositional logic（命题逻辑）propositiondef : a sentence which states a fact (true or false)argumentP1, …, Pn : CP1, …, Pn ⊢ C    an argument can have 0 and more premises and 1 conclusion. an argume">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-04-15T10:39:23.685Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Log.logic">
<meta name="twitter:description" content="Part IPropositional logic（命题逻辑）propositiondef : a sentence which states a fact (true or false)argumentP1, …, Pn : CP1, …, Pn ⊢ C    an argument can have 0 and more premises and 1 conclusion. an argume">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Log.logic</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/jwyhhh123">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/02/19/Log-AI/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/02/18/hello-World/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&text=Log.logic"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&is_video=false&description=Log.logic"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Log.logic&body=Check out this article: https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&name=Log.logic&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-I"><span class="toc-number">1.</span> <span class="toc-text">Part I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Propositional-logic（命题逻辑）"><span class="toc-number">1.1.</span> <span class="toc-text">Propositional logic（命题逻辑）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Natural-Deduction"><span class="toc-number">1.2.</span> <span class="toc-text">Natural Deduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semantics-truth-table"><span class="toc-number">1.3.</span> <span class="toc-text">Semantics, truth table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-strategy"><span class="toc-number">1.4.</span> <span class="toc-text">Proof strategy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equivalencies-and-normal-forms"><span class="toc-number">1.5.</span> <span class="toc-text">Equivalencies and normal forms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equivalencies"><span class="toc-number">1.6.</span> <span class="toc-text">Equivalencies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resolution-归结原理"><span class="toc-number">1.7.</span> <span class="toc-text">Resolution(归结原理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Satisfiability"><span class="toc-number">1.8.</span> <span class="toc-text">Satisfiability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-calculus-一阶逻辑"><span class="toc-number">1.9.</span> <span class="toc-text">Predicate calculus(一阶逻辑)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-Calculus-Proofs-amp-Identity"><span class="toc-number">1.10.</span> <span class="toc-text">Predicate Calculus: Proofs &amp; Identity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wrapping-Up-Summary"><span class="toc-number">1.11.</span> <span class="toc-text">Wrapping Up; Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-II"><span class="toc-number">2.</span> <span class="toc-text">Part II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming-part-Introduction"><span class="toc-number">2.1.</span> <span class="toc-text">:Programming part Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-Checking"><span class="toc-number">2.2.</span> <span class="toc-text">Proof Checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types"><span class="toc-number">2.3.</span> <span class="toc-text">Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-amp-pattern-matching（模式匹配）"><span class="toc-number">2.4.</span> <span class="toc-text">Functions &amp; pattern matching（模式匹配）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Isomorphisms"><span class="toc-number">2.5.</span> <span class="toc-text">Type Isomorphisms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-calculus-λ演算"><span class="toc-number">2.6.</span> <span class="toc-text">Lambda calculus(λ演算)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Church-encodings-编码"><span class="toc-number">2.7.</span> <span class="toc-text">Church encodings(编码)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-checking"><span class="toc-number">2.8.</span> <span class="toc-text">Type checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-inference-推理-given-a-proof-infer-to-its-type"><span class="toc-number">2.9.</span> <span class="toc-text">Type inference(推理): given a proof, infer to its type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Curry-Howord-correspondence"><span class="toc-number">2.10.</span> <span class="toc-text">Curry-Howord correspondence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CH-correspondence-props-types-proofs-terms-programs"><span class="toc-number">2.11.</span> <span class="toc-text">CH correspondence: props  types || proofs  terms (programs)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recursive-types-and-structural-recursion"><span class="toc-number">2.12.</span> <span class="toc-text">Recursive types and structural recursion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lists"><span class="toc-number">2.13.</span> <span class="toc-text">Lists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fold-reduce"><span class="toc-number">2.14.</span> <span class="toc-text">Fold(reduce)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#More-on-types"><span class="toc-number">2.15.</span> <span class="toc-text">More on types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Induction-informally"><span class="toc-number">2.16.</span> <span class="toc-text">Induction (informally)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Revisit"><span class="toc-number">2.17.</span> <span class="toc-text">Revisit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#add1-suc-m-n-suc-add1-m-n"><span class="toc-number">2.18.</span> <span class="toc-text">add1 (suc m) n = suc (add1 m n)</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Log.logic
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">WY J</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-02-18T16:05:02.000Z" itemprop="datePublished">2019-02-19</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h1><h2 id="Propositional-logic（命题逻辑）"><a href="#Propositional-logic（命题逻辑）" class="headerlink" title="Propositional logic（命题逻辑）"></a>Propositional logic（命题逻辑）</h2><p><strong>proposition</strong><br>def : a sentence which states a fact (true or false)<br><strong>argument</strong><br>P1, …, Pn : C<br>P1, …, Pn ⊢ C  </p>
<ul>
<li>an argument can have <strong>0 and more</strong> premises and <strong>1</strong> conclusion.</li>
<li>an argument is valid when premises are true and so is the conclusion.<br>&nbsp;<br><strong>syntax</strong><br>def : set of rules to define all possible formulas expressible in propositional logic<br><code>formulas</code> : P1,…,Pn,C</li>
</ul>
<p><strong>semantics</strong><br>def : meaning of a sentence</p>
<p><strong>Connectives</strong><br>conjunction ∧<br>disjunction ∨<br>negation    ¬<br>implication →</p>
<p><strong>Terminology</strong><br>scope of a connective : connective itself and what it connects<br>main connective: connects the whole furmula</p>
<p><strong>Examples</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if John is at home, then his TV is on.</span><br><span class="line">His TV is not on.</span><br><span class="line">Therefore John is not at home.</span><br><span class="line"></span><br><span class="line">H = &quot;John is at home&quot;</span><br><span class="line">O = &quot;John&apos;s TV is on&quot;</span><br><span class="line"></span><br><span class="line">H -&gt; O, ¬O ⊢ ¬H</span><br></pre></td></tr></table></figure></p>
<h2 id="Natural-Deduction"><a href="#Natural-Deduction" class="headerlink" title="Natural Deduction"></a>Natural Deduction</h2><p><strong>∧-introduction</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A   B</span><br><span class="line">-----  ∧ -introduction</span><br><span class="line">A ∧ B</span><br></pre></td></tr></table></figure></p>
<p><strong>∧-elimination</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A ∧ B </span><br><span class="line">-----  ∧ -elimination</span><br><span class="line">  A</span><br><span class="line"></span><br><span class="line">A ∧ B </span><br><span class="line">-----  ∧ -elimination</span><br><span class="line">  B</span><br></pre></td></tr></table></figure></p>
<p><strong>→-introduction</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ⊢ B </span><br><span class="line">-----  → -introduction</span><br><span class="line">A → B</span><br></pre></td></tr></table></figure></p>
<p><strong>→-elimination (modus ponens)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A → B  A </span><br><span class="line">-------- → -elimination</span><br><span class="line">    B</span><br></pre></td></tr></table></figure></p>
<p><strong>¬-introduction</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ⊢ ⊥ </span><br><span class="line">-----  ¬ -introduction</span><br><span class="line"> ¬A</span><br></pre></td></tr></table></figure></p>
<p><strong>¬¬-elimination</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">¬¬A </span><br><span class="line">---  ¬¬ -elimination</span><br><span class="line"> A</span><br></pre></td></tr></table></figure></p>
<p><strong>∨ -introduction</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line">-----  ∨ -introduction</span><br><span class="line">A ∨ B</span><br><span class="line"></span><br><span class="line">  A</span><br><span class="line">-----  ∨ -introduction</span><br><span class="line">B ∨ A</span><br></pre></td></tr></table></figure></p>
<p><strong>∨-elimination</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ∨ B  A ⊢ C  B ⊢ C </span><br><span class="line">--------------------  ∨ -elimination</span><br><span class="line">         C</span><br></pre></td></tr></table></figure></p>
<h2 id="Semantics-truth-table"><a href="#Semantics-truth-table" class="headerlink" title="Semantics, truth table"></a>Semantics, truth table</h2><p>Use <code>truth table</code> to formally define the semantics<br>&nbsp;<br><strong>P ∧ Q</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P     Q    P ∧ Q</span><br><span class="line"></span><br><span class="line">T     T      T</span><br><span class="line">T     F      F</span><br><span class="line">F     T      F</span><br><span class="line">F     F      F</span><br></pre></td></tr></table></figure></p>
<p><strong>P ∨ Q</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P     Q    P ∨ Q</span><br><span class="line">T     T      T</span><br><span class="line">T     F      T</span><br><span class="line">F     T      T</span><br><span class="line">F     F      F</span><br></pre></td></tr></table></figure></p>
<p><strong>¬P</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P    ¬P</span><br><span class="line">T     F</span><br><span class="line">F     T</span><br></pre></td></tr></table></figure></p>
<p><strong>P → Q</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P     Q     P → Q</span><br><span class="line">T     T       T</span><br><span class="line">T     F       F</span><br><span class="line">F     T       T</span><br><span class="line">F     F       T</span><br></pre></td></tr></table></figure></p>
<p><strong>Notations</strong><br>Satisfiable   : iff there exists an interpretation that satisfies φ</p>
<ul>
<li>examples : P, P ∧ Q<br>Falsifiable   : iff there exists an interpretation that makes φ false</li>
<li>examples : P, P ∧ Q<br>Unsatisfiable : iff there is no interpretation I that satisfies φ</li>
<li>examples : P ∧ ¬P, (P ∨ Q) ∧ ¬(P ∨ Q)<br>Valid         : iff is satisfied by every interpretation</li>
<li>examples : P ∨ ¬P, P → P, ¬(P ∧ ¬P)<br>Tautology (赘述) : iff it is valid<br>Contradiction : iff it unsatisfiable<br>Contingent (一组): iff it is both satisfiable and falsifiable</li>
</ul>
<p><strong>Validity of argument</strong><br>Steps :</p>
<ol>
<li>construct a truth table for premise(s) and conclusion.</li>
<li>when all premises are true and so is conclusion, it is valid.</li>
<li>when all premises are true and conclusion is false, it is invalid.</li>
</ol>
<p>NOTE: We can prove anything if there is a contradiction<br>example : P ∧ ¬P : Q</p>
<h2 id="Proof-strategy"><a href="#Proof-strategy" class="headerlink" title="Proof strategy"></a>Proof strategy</h2><h2 id="Equivalencies-and-normal-forms"><a href="#Equivalencies-and-normal-forms" class="headerlink" title="Equivalencies and normal forms"></a>Equivalencies and normal forms</h2><h2 id="Equivalencies"><a href="#Equivalencies" class="headerlink" title="Equivalencies"></a>Equivalencies</h2><h2 id="Resolution-归结原理"><a href="#Resolution-归结原理" class="headerlink" title="Resolution(归结原理)"></a>Resolution(归结原理)</h2><p>natural deduction:<br>&nbsp; 8 inference rules; formulas using ¬,∧,∨,→ –<br>resolution:<br>&nbsp; 1 inference rule; formulas all in <strong>CNF (clausal normal form)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &#123;A&#125; ∨ X1     &#123;¬A&#125; ∨ X2   </span><br><span class="line">------------------------ Resolution</span><br><span class="line">     X1 ∨ X2</span><br></pre></td></tr></table></figure></p>
<h2 id="Satisfiability"><a href="#Satisfiability" class="headerlink" title="Satisfiability"></a>Satisfiability</h2><p>“TheScienceofBruteForce”,MarijnJ.H.Heule,OliverKullmann  – <a href="https://cacm.acm.org/magazines/2017/8/219606-the-science-of-brute-force/fulltext" target="_blank" rel="noopener">https://cacm.acm.org/magazines/2017/8/219606-the-science-of-brute-force/fulltext</a> – state-of-the-artSATandautomatedmathematicalproofs  <br>Z3: a theorem prover, including both SAT/SMT solvers – <a href="https://rise4fun.com/z3/tutorial" target="_blank" rel="noopener">https://rise4fun.com/z3/tutorial</a> </p>
<h2 id="Predicate-calculus-一阶逻辑"><a href="#Predicate-calculus-一阶逻辑" class="headerlink" title="Predicate calculus(一阶逻辑)"></a>Predicate calculus(一阶逻辑)</h2><p>∀-introduction<br>∀-elimination<br>∃-introduction<br>∃-elimination</p>
<h2 id="Predicate-Calculus-Proofs-amp-Identity"><a href="#Predicate-Calculus-Proofs-amp-Identity" class="headerlink" title="Predicate Calculus: Proofs &amp; Identity"></a>Predicate Calculus: Proofs &amp; Identity</h2><p>Relations; Equivalence relation<br>Identity<br>Quantities: ∃x: at least 1, ∀x: all, ¬∃x: 0</p>
<h2 id="Wrapping-Up-Summary"><a href="#Wrapping-Up-Summary" class="headerlink" title="Wrapping Up; Summary"></a>Wrapping Up; Summary</h2><p>2 inference rules for Indentity:</p>
<ul>
<li>=-introduction</li>
<li>=-elimination</li>
</ul>
<h1 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h1><h2 id="Programming-part-Introduction"><a href="#Programming-part-Introduction" class="headerlink" title=":Programming part Introduction"></a>:Programming part Introduction</h2><p>paradox(悖论): “what i am saying is wrong”<br>&nbsp;<br>a formal system:</p>
<ul>
<li>sound(true then cannot be false)</li>
<li>complete(true or false can be determined)</li>
<li>computable(be computed by machine)</li>
</ul>
<h2 id="Proof-Checking"><a href="#Proof-Checking" class="headerlink" title="Proof Checking"></a>Proof Checking</h2><p><strong>Rules</strong><br>and-elimination:</p>
<ul>
<li>andEl : {P Q : Prop}   -&gt; P and Q -&gt; P</li>
<li>andEr : {P Q : Prop}   -&gt; P and Q -&gt; Q</li>
</ul>
<p>and-introduction:</p>
<ul>
<li>andI : {P Q : Prop}   -&gt; P -&gt; Q -&gt; P and Q</li>
</ul>
<p>or-introduction</p>
<ul>
<li>orIl : {P Q : Prop}   -&gt; p -&gt; P or Q</li>
<li>orIr : {P Q : Prop}   -&gt; Q -&gt; P or Q</li>
</ul>
<p>or-elimination</p>
<ul>
<li>orE : {P Q R : Prop}   -&gt; P or Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R</li>
</ul>
<p>falsity-elimination</p>
<ul>
<li>ENQ : {P : Prop}   -&gt; Falsity -&gt; P</li>
</ul>
<p>double-negation-elimination</p>
<ul>
<li>DNE : {P : Prop}  -&gt; (not (not P)) -&gt; P</li>
</ul>
<p>Modus ponens</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mp: &#123;P Q : Prop&#125;  -&gt; (P -&gt; Q) -&gt; P -&gt; Q</span><br><span class="line">mp  &#123;P&#125; &#123;Q&#125;          f           p  = q where</span><br><span class="line"> q: Q        //declearation</span><br><span class="line"> q = f p     //operation</span><br></pre></td></tr></table></figure>
<p>Implication introduction<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">comp : &#123;A B C : Prop&#125; -&gt; (f : A -&gt; B) -&gt; (g : B -&gt; C) -&gt; (A -&gt; C) </span><br><span class="line">comp &#123;A&#125; &#123;B&#125; &#123;C&#125; f g = h where</span><br><span class="line">  h : A -&gt; C</span><br><span class="line">  h a = c where</span><br><span class="line">    b : B</span><br><span class="line">    b = f a</span><br><span class="line">    c : C</span><br><span class="line">    c = g b</span><br></pre></td></tr></table></figure></p>
<p>NOTE: The idea here is still to solve the last proposition.</p>
<p><strong>Negation</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">Falsity</span><br><span class="line">---------</span><br><span class="line">A -&gt; Falsity = not A</span><br></pre></td></tr></table></figure>
<p>Double negation introduction:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DNI : &#123;A : Prop&#125; : A -&gt; (A -&gt; Falsity) -&gt; Falsity</span><br><span class="line">DNI &#123;A&#125; a f = x where</span><br><span class="line">  x : Falsity</span><br><span class="line">  x = f a</span><br></pre></td></tr></table></figure>
<p>Triple negation elimination</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TNE : &#123;A : Prop&#125; -&gt; (f : (not (not A)) -&gt; Falsity) -&gt; (a : A) -&gt; Falsity</span><br><span class="line">TNE &#123;A&#125; f a = x where   // auxiliary clause</span><br><span class="line">  y : not (not A)</span><br><span class="line">  y = DNI a</span><br><span class="line">  x : Falsity</span><br><span class="line">  x = f y</span><br></pre></td></tr></table></figure>
<p><strong>Proof terms</strong><br>def : fully-inlined(完全内联的) proofs with no auxiliary(辅助的) definitions<br>&nbsp;<br>NOTE: all the definitions above can be inlined by removing auxiliary clauses.</p>
<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>Some examples written in Agda:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f : Nat -&gt; Nat</span><br><span class="line">f x = 3 * x +7</span><br><span class="line"></span><br><span class="line">g : Nat -&gt; Nat</span><br><span class="line">g x = 4 * x * x + 9 * x + 10</span><br><span class="line"></span><br><span class="line">m : Nat</span><br><span class="line">m = max (f 9) (g 6)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data unit : Set where</span><br><span class="line">  empty: unit</span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code> : introduces the definition</li>
<li><code>Void</code> : the name of the type (can be almost anything, including unicode)</li>
<li><code>Set</code> : it confirms that <code>Void</code> is a type (Agda, confusingly, calls types “sets”)</li>
<li><code>where</code> : introduces the <em>constructors</em>.</li>
<li><code>empty</code> : constructor</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data Void : Set where</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data Boolean : Set where</span><br><span class="line">  true false : Boolean</span><br></pre></td></tr></table></figure>
<p>composite types: given some types, construct new types<br>.product (or tuples)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data Prod (X Y : Set) : Set where</span><br><span class="line">  pair : X -&gt; Y -&gt; Prod X Y</span><br></pre></td></tr></table></figure>
<p>.sum or .union</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Sum (A B : Set) : Set where</span><br><span class="line">  left  : A -&gt; Sum A B</span><br><span class="line">  right : B -&gt; Sum A B</span><br></pre></td></tr></table></figure>
<p>.algebraic types</p>
<ul>
<li>void       0</li>
<li>unit       1</li>
<li>sum A B    A+B</li>
<li>Pred A B   AxB</li>
<li>void       null</li>
</ul>
<p>&nbsp; If type <code>A</code> has <code>m</code> elements and type <code>B</code> has <code>n</code> elements, then:</p>
<ul>
<li>How many elements has <code>Sum A B</code>?  m+n</li>
<li>How many elements has <code>Prod A B</code>?  mxn</li>
</ul>
<blockquote>
<ul>
<li>can we define any element of <code>Prod A Void</code> for some <code>A</code>?       null</li>
<li>can we define any element of <code>Sum A Void</code> for some <code>A</code>?     A</li>
</ul>
</blockquote>
<h2 id="Functions-amp-pattern-matching（模式匹配）"><a href="#Functions-amp-pattern-matching（模式匹配）" class="headerlink" title="Functions &amp; pattern matching（模式匹配）"></a>Functions &amp; pattern matching（模式匹配）</h2><p>Pattern matching enumerations </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and : Boolean -&gt; Boolean -&gt; Boolean</span><br><span class="line">and true  true  = true</span><br><span class="line">and true  false = false</span><br><span class="line">and false true  = false</span><br><span class="line">and false false = false         //all cases are required to be covered.</span><br></pre></td></tr></table></figure>
<p>Pattern matching <code>prod</code>: so-called “projections”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proj1 : &#123;A B : Set&#125; -&gt; Prod A B -&gt; A</span><br><span class="line">proj1 (pair a _) = a                    ... b is unused ...</span><br><span class="line"></span><br><span class="line">proj2 : &#123;A B : Set&#125; -&gt; Prod A B -&gt; B</span><br><span class="line">proj2 (pair _ b) = b                    ... a is unused ...</span><br></pre></td></tr></table></figure>
<p>Pattern matching <code>sum</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f : Sum Unit Unit -&gt; Boolean</span><br><span class="line">f (left x)  = true</span><br><span class="line">f (right y) = false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g : Boolean -&gt; Sum Unit Unit</span><br><span class="line">g true  = left empty</span><br><span class="line">g false = right empty</span><br></pre></td></tr></table></figure>
<p>A special case</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">impossible : &#123;A : Set&#125; -&gt; void -&gt; A</span><br><span class="line">  impossible ()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>()</code> matches <code>void</code></li>
</ul>
<p><strong>Example:</strong> Convert between <code>Sum A Void</code> and <code>A</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">j : &#123;A : Set&#125; -&gt; Sum A Void -&gt; A</span><br><span class="line">j (left a)   = a</span><br><span class="line">j (right ())</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Example:</strong> Since in general <code>A + A = 2 * A</code> let’s see how we can convert between <code>Sum A A</code> and <code>Prod Boolean A</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h : &#123;A : Set&#125; -&gt; Sum A A -&gt; Prod Boolean A</span><br><span class="line">h (left a)  = pair true a</span><br><span class="line">h (right a) = pair true a </span><br><span class="line"></span><br><span class="line">i : &#123;A : Set&#125; -&gt; Prod Boolean A -&gt; Sum A A</span><br><span class="line">i (pair true a)  = left a</span><br><span class="line">i (pair false a) = right a</span><br></pre></td></tr></table></figure>
<h2 id="Type-Isomorphisms"><a href="#Type-Isomorphisms" class="headerlink" title="Type Isomorphisms"></a>Type Isomorphisms</h2><p><code>f : A -&gt; B</code> and <code>g : B -&gt; A</code> means that the two types are <strong><em>isomorphic</em></strong>, written <code>A ~ B</code>.</p>
<p>If we write <code>Void</code> as <code>0</code>, <code>Unit</code> as <code>1</code>, <code>Prod A B</code> as <code>A x B</code>,  <code>Sum A B</code> as <code>A + B</code> we can see that many type isomorphisms are consistent with calling these data typs <em>algebraic</em>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* Semi-ring</span><br><span class="line"></span><br><span class="line">A + (B + C) \sim (A + B) + C \\</span><br><span class="line">A + B \sim B + A\\</span><br><span class="line">A + B \sim A\\</span><br><span class="line">A \times (B \times C) \sim (A\times B) \times C\\</span><br><span class="line">A \times B \sim B \times A\\</span><br><span class="line">A \times 1 \sim A\\</span><br><span class="line">A \times (B + C) \sim A \times B + A \times C\\</span><br><span class="line">(A + B) \times C \sim A \times C + B \times C\\</span><br><span class="line">A \times 0 \sim 0</span><br></pre></td></tr></table></figure>
<p>Curry-Howard Correspondence</p>
<ul>
<li><code>Falsity ~ Void</code></li>
<li><code>Truth   ~ Unit</code></li>
<li><code>A and B ~ Prod A B</code> </li>
<li><code>A or B  ~ Sum A B</code></li>
</ul>
<p>&nbsp;<em>postulate</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">andEl  : &#123;P Q : Prop&#125;   -&gt; P and Q -&gt; P</span><br><span class="line">andEr  : &#123;P Q : Prop&#125;   -&gt; P and Q -&gt; Q</span><br><span class="line">andI   : &#123;P Q : Prop&#125;   -&gt; P -&gt; Q -&gt; P and Q</span><br><span class="line">orE    : &#123;P Q R : Prop&#125; -&gt; P or Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R</span><br><span class="line">orIl   : &#123;P Q : Prop&#125;   -&gt; P -&gt; P or Q</span><br><span class="line">orIr   : &#123;P Q : Prop&#125;   -&gt; Q -&gt; Q or P</span><br><span class="line">EFQ    : &#123;P : Prop&#125;     -&gt; Falsity -&gt; P</span><br><span class="line">DNE    : &#123;P : Prop&#125;     -&gt; (not (not P)) -&gt; P</span><br></pre></td></tr></table></figure>
<p>&nbsp;<em>funtions</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">andEl&apos; : &#123;P Q : Set&#125; -&gt; Prod P Q -&gt; P</span><br><span class="line">andEl&apos; (pair p _) = p</span><br><span class="line"></span><br><span class="line">andEr&apos; : &#123;P Q : Set&#125; -&gt; Prod P Q -&gt; Q</span><br><span class="line">andEr&apos; (pair _ q) = q</span><br><span class="line"></span><br><span class="line">andI&apos; : &#123;P Q : Set&#125; -&gt; P -&gt; Q -&gt; Prod P Q</span><br><span class="line">andI&apos; p q = pair p q</span><br><span class="line"></span><br><span class="line">orE&apos; : &#123;P Q R : Set&#125; -&gt; Sum P Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R</span><br><span class="line">orE&apos; (left p)  f g = f p</span><br><span class="line">orE&apos; (right q) f g = g q</span><br><span class="line"></span><br><span class="line">orIl&apos; : &#123;P Q : Set&#125; -&gt; P -&gt; Sum P Q</span><br><span class="line">orIl&apos; p = left p</span><br><span class="line"></span><br><span class="line">orIr&apos; : &#123;P Q : Set&#125; -&gt; Q -&gt; Sum P Q</span><br><span class="line">orIr&apos; q = right q</span><br><span class="line"></span><br><span class="line">EFQ&apos; : &#123;P : Set&#125; -&gt; Void -&gt; P</span><br><span class="line">EFQ&apos; ()</span><br></pre></td></tr></table></figure>
<p>proof relevance</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">suu-u : Sum Unit Unit -&gt; Unit</span><br><span class="line">suu-u (left empty) = empty</span><br><span class="line">suu-u (right empty) = empty </span><br><span class="line"></span><br><span class="line">u-suu : Unit -&gt; Sum Unit Unit</span><br><span class="line">u-suu empty = left empty</span><br></pre></td></tr></table></figure>
<ul>
<li>this is not isomophic</li>
<li>it is not the case that <code>1 + 1 ~ 1</code>.</li>
</ul>
<h2 id="Lambda-calculus-λ演算"><a href="#Lambda-calculus-λ演算" class="headerlink" title="Lambda calculus(λ演算)"></a>Lambda calculus(λ演算)</h2><p><strong>def:</strong> formalise the concept of computability using a simple notion of <em>functions</em>.<br>&nbsp;-One of the ways we can understand functions is as a mapping from some inputs to some outputs.</p>
<ul>
<li>Variable:    <code>x</code>  </li>
<li>Abstraction: <code>λx.F</code>  </li>
<li>Application: <code>f x</code></li>
</ul>
<p>In <strong>Agda</strong> we write <code>\x -&gt; F</code>.<br><code>x</code>: variable binding<br><code>F</code>: term, <em>i.e.</em> an expression formed of variables, function application, and function definition. </p>
<p>&nbsp;<em>Example:</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(\x -&gt; x + 1) 7 </span><br><span class="line">  = 7 + 1 </span><br><span class="line">  = 8</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(\x y -&gt; x + y) 7 8 </span><br><span class="line">  = (\y -&gt; 7 + y) 8 </span><br><span class="line">  = 7 + 8 </span><br><span class="line">  = 15</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(\x -&gt; x + 1) ((\y -&gt; y + 1) 2) </span><br><span class="line">  = (\x -&gt; x + 1) (2 + 1)</span><br><span class="line">  = (\x -&gt; x + 1) 3</span><br><span class="line">  = 3 + 1</span><br><span class="line">  = 4</span><br></pre></td></tr></table></figure>
<p>“higher-order” functions:</p>
<ul>
<li>takes one or more functions as arguments (i.e. procedural parameters),</li>
<li>returns a function as its result.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(\f x -&gt; f (f x)) (\y -&gt; y + 1)</span><br><span class="line">  = \x -&gt; (\y -&gt; y + 1) ((\z -&gt; z + 1) x)</span><br><span class="line">  = \x -&gt; (\y -&gt; y + 1) (x + 1)</span><br><span class="line">  = \x -&gt; (x + 1) + 1</span><br><span class="line">  = \x -&gt; x + 2</span><br></pre></td></tr></table></figure>
<h2 id="Church-encodings-编码"><a href="#Church-encodings-编码" class="headerlink" title="Church encodings(编码)"></a>Church encodings(编码)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true = \a b -&gt; a</span><br><span class="line">false = \a b -&gt; b</span><br><span class="line">and = \p q -&gt; p q p</span><br><span class="line">or = \p q -&gt; p p q</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and true false </span><br><span class="line">  = (\p q -&gt; p q p) true false</span><br><span class="line">  = true false true</span><br><span class="line"></span><br><span class="line">  = (\a b -&gt; a) false true</span><br><span class="line">  = false</span><br></pre></td></tr></table></figure>
<p>The Y combinator: encodes <em>recursion</em><br><code>Y = \f -&gt; (\x -&gt; f(x x)) (\x -&gt; f(x x))</code></p>
<p>For any function <code>g</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Y g = (\x -&gt; g(x x)) (\x g(x x))</span><br><span class="line">  = g(((\x -&gt; g(x x)))((\x -&gt; g(x x))))</span><br><span class="line">  = g(Y g)</span><br><span class="line">  ...</span><br><span class="line">  = g (g (Y g))</span><br><span class="line">  ...</span><br><span class="line">  = g (g (g (Y g)))</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h2 id="Type-checking"><a href="#Type-checking" class="headerlink" title="Type checking"></a>Type checking</h2><p>Type judgements</p>
<ul>
<li><code>Γ</code> is a list of elements of the form <code>x:A</code> where <code>x</code> is a variable and <code>A</code> is a type</li>
<li><code>t</code> is a lambda calculus term</li>
<li><code>A</code> is a type.</li>
</ul>
<p><strong>rules:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A -&gt; B   Γ ⊢ u : A</span><br><span class="line">---------------------------[App]</span><br><span class="line">Γ ⊢ t u : B</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ, x:A ⊢ t : B</span><br><span class="line">--------------[Abs]</span><br><span class="line">Γ ⊢ t : A -&gt; B</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------[Axi]</span><br><span class="line">Γ, x:A ⊢ x : A</span><br></pre></td></tr></table></figure>
<p>&nbsp; <em>example:</em><br>&nbsp; check: <code>⊢ \x y z -&gt; y (x z) : (A -&gt; B) -&gt; (B -&gt; C) -&gt; (A -&gt; C)</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                        ------------------------------[Axi] ----------------------------[Axi]</span><br><span class="line">                                                     Γ ⊢ x : A-&gt;B                Γ ⊢ Z : A</span><br><span class="line">----------------------------------[Axi] ----------------------------------------------------------------[App]</span><br><span class="line">    Γ ⊢ y : (B -&gt; C)                           Γ ⊢ x z : B</span><br><span class="line">----------------------------------------------------------------------[App]</span><br><span class="line">x:A-&gt;B, y:B-&gt;C, z:A ⊢ y (x z) : C</span><br><span class="line">-----------------------------------------------------[Abs x 3]</span><br><span class="line">⊢ \x y z -&gt; y (x z) : (A -&gt; B) -&gt; (B -&gt; C) -&gt; (A -&gt; C)</span><br></pre></td></tr></table></figure>
<h2 id="Type-inference-推理-given-a-proof-infer-to-its-type"><a href="#Type-inference-推理-given-a-proof-infer-to-its-type" class="headerlink" title="Type inference(推理): given a proof, infer to its type"></a>Type inference(推理): given a proof, infer to its type</h2><p>unification: two sets of terms, find values for the terms such that the terms are equal</p>
<ul>
<li>type reduction: <code>t1 -&gt; t2 = t3 -&gt; t4</code> is broken into <code>t1 = t3</code> and <code>t2 = t4</code></li>
<li>variable elimination: x= A —-&gt; x /A (<em>substitue all x with u</em>)</li>
<li>A set of equations is <em>solved</em> if <ul>
<li>all equations have form <code>x = t</code> with <code>x</code> a variable</li>
<li>every variable on the left occurs only in that place.</li>
</ul>
</li>
</ul>
<p><strong>Basic unification algorithm</strong></p>
<ol>
<li>Change all equations <code>t = x</code> where <code>t</code> is not a variable and <code>x</code> is a variable to <code>x = t</code>.</li>
<li>Remove all equations <code>x = x</code> where <code>x</code> is a variable.</li>
<li>Select an equation <code>u = v</code> where neither is a variable and apply <em>type reduction</em>.<br>If type reduction is impossible, <em>fail</em>.</li>
<li>Select an equation <code>x = t</code> where <code>x</code>, where <code>t ≠ x</code>. If <code>x ∈ t</code> then <em>fail</em> else apply <em>variable elimination</em>. </li>
<li>Repeat until <em>solved</em>.</li>
</ol>
<p><strong>Basic type inference</strong><br>S1. Construct the type derivation tree for the term using variables instead of types.<br>S2. Add constraints as follows: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A   Γ ⊢ u : B</span><br><span class="line">---------------------------[A = B -&gt; C]</span><br><span class="line">Γ ⊢ t u : C</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ, x:A ⊢ t : B</span><br><span class="line">--------------[C = A -&gt; B]</span><br><span class="line">Γ ⊢ t : C</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------[B = A]</span><br><span class="line">Γ, x:A ⊢ x : B</span><br></pre></td></tr></table></figure>
<p>S3.  Collect and solve the system of constraints. </p>
<p>&nbsp; <em>Example:</em><br>&nbsp; Let us infer the type of <code>\x y z -&gt; y (x z)</code>. The derivation tree is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                             ------------------------------[J = B] ----------------------[K = F]</span><br><span class="line">                             x:B, y:D, z:F ⊢ x : J                 x:B, y:D, z:F ⊢ Z : K</span><br><span class="line">---------------------[H = D] ------------------------------------------------------------[J = K -&gt; I]</span><br><span class="line">x:B, y:D, z:F ⊢ y : H        x:B, y:D, z:F ⊢ x z : I</span><br><span class="line">-----------------------------------------------------[H = I -&gt; G]</span><br><span class="line">x:B, y:D, z:F ⊢ y (x z) : G</span><br><span class="line">----------------------------[E = F -&gt; G]</span><br><span class="line">x:B, y:D ⊢ \z -&gt; y (x z) : E</span><br><span class="line">-----------------------------[C = D -&gt; E]</span><br><span class="line">x:B ⊢ \y z -&gt; y (x z) : C</span><br><span class="line">--------------------------[A = B -&gt; C]</span><br><span class="line">⊢ \x y z -&gt; y (x z) : A</span><br></pre></td></tr></table></figure>
<p>We collect the following constraints:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = B -&gt; C</span><br><span class="line">C = D -&gt; E</span><br><span class="line">E = F -&gt; G</span><br><span class="line">H = I -&gt; G</span><br><span class="line">H = D</span><br><span class="line">J = K -&gt; I</span><br><span class="line">B = J</span><br><span class="line">F = K</span><br></pre></td></tr></table></figure>
<p>Applying the unification algorithm we get:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = (K -&gt; I) -&gt; (I -&gt; G) -&gt; K -&gt; G</span><br><span class="line">C = D -&gt; F -&gt; G</span><br><span class="line">E = F -&gt; G</span><br><span class="line">H = I -&gt; G</span><br><span class="line">D = I -&gt; G</span><br><span class="line">J = K -&gt; I</span><br><span class="line">B = K -&gt; I</span><br><span class="line">F = K</span><br></pre></td></tr></table></figure>
<ul>
<li>checked: all equations have form <code>x = t</code> with <code>x</code> a variable</li>
<li>checked: every variable on the left occurs only in that place.</li>
</ul>
<p>Typing non-termination<br>Terms <code>Y</code> and <code>omega</code> are non-terminating in <strong>Agda</strong></p>
<h2 id="Curry-Howord-correspondence"><a href="#Curry-Howord-correspondence" class="headerlink" title="Curry-Howord correspondence"></a>Curry-Howord correspondence</h2><p>isomorphisms</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cur : &#123;A B C : Set&#125; -&gt; ((Prod C B ) -&gt; A) -&gt; (C -&gt; B -&gt; A)</span><br><span class="line">cur f c b = f (pair c b)</span><br><span class="line"></span><br><span class="line">uncur : &#123;A B C : Set&#125; -&gt; (C -&gt; B -&gt; A) -&gt; ((Prod C B) -&gt; A)</span><br><span class="line">uncur f (pair c b) = f c b</span><br></pre></td></tr></table></figure>
<h2 id="CH-correspondence-props-types-proofs-terms-programs"><a href="#CH-correspondence-props-types-proofs-terms-programs" class="headerlink" title="CH correspondence: props  types || proofs  terms (programs)"></a>CH correspondence: props <-> types || proofs <-> terms (programs)</-></-></h2><ul>
<li>Product Elimination Left: (<strong>-and eli</strong>)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Prod A B</span><br><span class="line">----------------</span><br><span class="line">Γ ⊢ proj1 t : A</span><br></pre></td></tr></table></figure>
<ul>
<li>Product Elimination Right: (<strong>-and eli</strong>)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Prod A B</span><br><span class="line">-----------------</span><br><span class="line">Γ ⊢ proj2 t : B</span><br></pre></td></tr></table></figure>
<ul>
<li>Product Introduction: (<strong>-and intr</strong>)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A   Γ ⊢ u : B</span><br><span class="line">-----------------------</span><br><span class="line">Γ ⊢ andI t u : Prod A B</span><br></pre></td></tr></table></figure>
<ul>
<li>Sum Elimination: (<strong>-or eli</strong>)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Sum A B   Γ ⊢ u : A -&gt; C   Γ ⊢ v : B -&gt; C</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">Γ ⊢  orE t u v : Sum A B -&gt; (A -&gt; C) -&gt; (B -&gt; C) -&gt; C</span><br><span class="line"></span><br><span class="line"> pattern match (left a) = f a</span><br><span class="line">               (right b) = g b</span><br></pre></td></tr></table></figure>
<ul>
<li>Sum Introduction Left: (<strong>-or intr</strong>)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A</span><br><span class="line">---------------------</span><br><span class="line">Γ ⊢ orIl t : Sum A B</span><br></pre></td></tr></table></figure>
<ul>
<li>Sum Introduction Right: (<strong>-or intr</strong>)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : B</span><br><span class="line">--------------------</span><br><span class="line">Γ ⊢ orIr t : Sum A B</span><br></pre></td></tr></table></figure>
<ul>
<li><em>Ex Falso Quodlibet</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-------------------</span><br><span class="line">Γ ⊢ EFQ : Void -&gt; A</span><br></pre></td></tr></table></figure>
<h2 id="Recursive-types-and-structural-recursion"><a href="#Recursive-types-and-structural-recursion" class="headerlink" title="Recursive types and structural recursion"></a>Recursive types and structural recursion</h2><p>.Peano numbers</p>
<ul>
<li>zero</li>
<li>succ</li>
</ul>
<p>.Lists</p>
<ul>
<li>empty list</li>
<li>add one element into emptylist</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Nat : Set where</span><br><span class="line">  zero : Nat</span><br><span class="line">  suc  : Nat -&gt; Nat</span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code> is a keyword indicating a type definition</li>
<li><code>Nat</code> is the identifier we choose for the type</li>
<li><code>Set</code> is the built-in identifier for types<br>(<code>data Nat : Set</code> says <em>we are defining a type called <code>Nat</code></em>.)</li>
<li><code>where</code> is introducing the definitions, which need to be indented</li>
<li><code>zero</code> is the name of one of the <strong>constructors</strong></li>
<li><code>suc</code> is a <strong>constructor</strong> that takes a <code>Nat</code> as an argument and produces another <code>Nat</code>.</li>
</ul>
<p>For example:</p>
<ul>
<li><code>zero</code> is what you would normally write 0</li>
<li><code>suc zero</code> is what you would normally write 1</li>
<li><code>suc (suc zero)</code> is 2</li>
<li><code>suc (suc (suc zero)))</code> is 3</li>
</ul>
<p>.zero test (pattern matching)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is-zero : Nat -&gt; Boolean</span><br><span class="line">is-zero : zero = true</span><br><span class="line">is-zero : (suc _) = false</span><br></pre></td></tr></table></figure>
<p>.Doubling</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbl : Nat -&gt; Nat</span><br><span class="line">dbl zero = zero</span><br><span class="line">dbl (suc n) = suc (suc (dbl n))</span><br></pre></td></tr></table></figure>
<p><em>heuristic:</em> 1+n -&gt; 1+n+1+n = 1+ 1+ dbl n</p>
<p>.Addition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">add zero n = n</span><br><span class="line">add (suc m) n = suc (add m n)</span><br></pre></td></tr></table></figure>
<p><em>heuristic:</em> 1+ m+ 1+ n = 1+ 1+ (m+n) = suc (suc (add m n))</p>
<p><strong>Structural recursion:</strong> if arg is getting smaller, it is allowed to find the answer</p>
<p>.Halving</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half : Nat -&gt; Nat</span><br><span class="line">half zero = zero</span><br><span class="line">half (suc zero) =zero</span><br><span class="line">half (suc (suc n)) = suc (half n)</span><br></pre></td></tr></table></figure>
<p><em>heuristic:</em> (1+1+m)/2 = 1+ half n</p>
<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data : List (A : Set) : Set where</span><br><span class="line">  nil  : List A</span><br><span class="line">  cons : A -&gt; List A -&gt; List A</span><br></pre></td></tr></table></figure>
<ul>
<li><code>nil</code>: empty list constructor</li>
<li><code>cons</code>: constructor that takes an element of <code>A</code> (called <em>head</em>) and a list (called <em>tail</em>). </li>
</ul>
<p>For example: </p>
<ul>
<li><code>cons 1 nil</code> is the list [1]</li>
<li><code>cons 1 (cons 2 nil)</code> is the list [1, 2]</li>
<li><code>cons true (cons false nil)</code> is the list [true, false]</li>
</ul>
<p>Also note that the we can have a list of lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = cons 0 nil          ... [0]</span><br><span class="line">y = cons 1 x            ... [1, 0]</span><br><span class="line">z = cons x (cons y nil) ... [[1, 0], [0]]</span><br></pre></td></tr></table></figure>
<p>.empty-check:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">empty : &#123;A : Set&#125; -&gt; List A -&gt; Boolean</span><br><span class="line">empty nil = true</span><br><span class="line">empty _   = false</span><br></pre></td></tr></table></figure>
<p>.length of a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len : &#123;A : Set&#125; -&gt; List A -&gt; Nat</span><br><span class="line">len nil         = zero</span><br><span class="line">len (cons _ xs) = suc (len xs)</span><br></pre></td></tr></table></figure>
<p>.Appending two lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">append : &#123;A : Set&#125; -&gt; List A -&gt; List A -&gt; List A</span><br><span class="line">append nil ys = ys</span><br><span class="line">append (cons x xs) ys = cons x (append xs ys)</span><br></pre></td></tr></table></figure>
<p>.reverse a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rev : &#123;A : Set&#125; -&gt; List A -&gt; List A </span><br><span class="line">rev nil = nil</span><br><span class="line">rev (cons x xs) = append (rev xs) (cons x nil)</span><br></pre></td></tr></table></figure>
<p>.filtering a list: return a list leaves out some elements</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons x xs) = if (is-zero x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-zeros xs</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">if : &#123;A : Set&#125; -&gt; Boolean -&gt; A -&gt; A -&gt; A</span><br><span class="line">if true  x  _ = x</span><br><span class="line">if false _ y = y</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">is-zero : Nat -&gt; Bool</span><br></pre></td></tr></table></figure>
<p>deep pattern-matching:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons zero xs) = filter-zeros xs</span><br><span class="line">filter-zeros (cons (suc n) xs) = cons (suc n) (filter-zeros xs)</span><br></pre></td></tr></table></figure>
<p>But suppose that we have a function <code>is-even : Nat -&gt; Boolean</code> to test for even-ness or <code>is-prime : Nat -&gt; Boolean</code> to test for primality. Filtering for some given property has very similar shape:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons x xs) = if (is-zero x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-zeros xs</span><br><span class="line"></span><br><span class="line">filter-evens : List Nat -&gt; List Nat</span><br><span class="line">filter-evens nil = nil</span><br><span class="line">filter-evens (cons x xs) = if (is-even x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-evens xs</span><br><span class="line"></span><br><span class="line">filter-primes : List Nat -&gt; List Nat</span><br><span class="line">filter-primes nil = nil</span><br><span class="line">filter-primes (cons x xs) = if (is-prime x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-primes xs</span><br></pre></td></tr></table></figure>
<p>This means that we can define a <em>generic</em> filter function for any property (predicate) expressed by a function <code>p : A -&gt; Boolean</code> where <code>A</code> is the type of list elements:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filter : &#123;A : Set&#125; -&gt; (A -&gt; Bool) -&gt; List A -&gt; List A</span><br><span class="line">filter p nil = nil</span><br><span class="line">filter p (cons x xs) = if (p x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter p xs</span><br></pre></td></tr></table></figure>
<h2 id="Fold-reduce"><a href="#Fold-reduce" class="headerlink" title="Fold(reduce)"></a>Fold(reduce)</h2><p><strong>def:</strong> abstract the structural recursion pattern </p>
<p>.Fold-right:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foldr : &#123;A B : Set&#125; -&gt; (A -&gt; B -&gt; B) -&gt; B -&gt; List A -&gt; B</span><br><span class="line">foldr f y0 nil = y0 </span><br><span class="line">foldr f y0 (cons x xs) = f x y where</span><br><span class="line">  y = foldr f y0 xs</span><br></pre></td></tr></table></figure>
<p>.Fold-left:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foldl : &#123;A B : Set&#125; -&gt; (B -&gt; A -&gt; B) -&gt; B -&gt; List A -&gt; B</span><br><span class="line">foldl f y0 nil         = y0</span><br><span class="line">foldl f y0 (cons x xs) = foldl f y0&apos; xs where</span><br><span class="line">  y0&apos; = f y0 x</span><br></pre></td></tr></table></figure>
<p><em>example</em><br>&nbsp; right recursion</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foldr sum 0 xs </span><br><span class="line">   = sum 0 (foldr sum 0 [1, 2, 3])</span><br><span class="line">   = sum 0 (sum 1 (foldr sum 0 [2, 3]))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (foldr sum 0 [3])))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (sum 3 (foldr sum 0 nil))))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (sum 3 0)))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 3))</span><br><span class="line">   = sum 0 (sum 1 5)</span><br><span class="line">   = sum 0 6</span><br><span class="line">   = 6</span><br></pre></td></tr></table></figure>
<p>&nbsp; left recursion</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foldl sum 0 xs</span><br><span class="line">  = foldl sum (sum 0 0) [1, 2, 3]</span><br><span class="line">  = foldl sum (sum (sum 0 0) 1) [2, 3]</span><br><span class="line">  = foldl sum (sum (sum (sum 0 0) 1) 2) [3]</span><br><span class="line">  = foldl sum (sum (sum (sum (sum 0 0) 1) 2) 3) nil </span><br><span class="line">  = sum (sum (sum (sum 0 0) 1) 2) 3</span><br><span class="line">  = sum (sum (sum 0 1) 2) 3</span><br><span class="line">  = sum (sum 1 2) 3</span><br><span class="line">  = sum 3 3</span><br><span class="line">  = 6</span><br></pre></td></tr></table></figure>
<p>.Map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map : &#123;A B : Set&#125; -&gt; (A -&gt; B) -&gt; List A -&gt; List B</span><br><span class="line">map f nil = nil</span><br><span class="line">map f (cons x xs) = cons (f x) (map f xs)</span><br></pre></td></tr></table></figure>
<p>This function applies <code>f : A -&gt; B</code> to each element of <code>List A</code> to create a <code>List B</code>. </p>
<p>map-reduce</p>
<h2 id="More-on-types"><a href="#More-on-types" class="headerlink" title="More on types"></a>More on types</h2><p>errors</p>
<ol>
<li>agda : no errors allowed</li>
<li>Java : runtime exceptions</li>
<li>C : undefined behaviors</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Option (A : Set) : Set where</span><br><span class="line">  none : Option A</span><br><span class="line">  some : A -&gt; Option A</span><br></pre></td></tr></table></figure>
<ul>
<li><code>none</code> adds a special error value</li>
<li><code>some</code> injects <code>A</code> into the wrapper <code>Option</code></li>
</ul>
<p>return the head of a list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head : &#123;A : Set&#125; -&gt; List A-&gt; Option A</span><br><span class="line">head (cons x _) = some x</span><br><span class="line">head nil        = none</span><br></pre></td></tr></table></figure>
<p>return n.th element</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nth : &#123;A : Set&#125; -&gt; Nat -&gt; List A -&gt; Option A</span><br><span class="line">nth _ nil = none</span><br><span class="line">nth zero (cons x _) = some x</span><br><span class="line">nth (suc n) (cons _ xs) = nth n xs</span><br></pre></td></tr></table></figure>
<p>return the sum of 2nd and 3rd in a list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum23 : List Nat -&gt; Option Nat</span><br><span class="line">sum23 xs = add&apos; x2 x3 where</span><br><span class="line">  x2 = nth two xs</span><br><span class="line">  x3 = nth three xs</span><br><span class="line"></span><br><span class="line">add&apos; : Option Nat -&gt; Option Nat -&gt; Option Nat</span><br><span class="line">add&apos; (some m) (some n) = some (add m n)</span><br><span class="line">add&apos; _ _ = none</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lift2 : (Nat -&gt; Nat -&gt; Nat) -&gt; (Option Nat -&gt; Option Nat -&gt; Option Nat)</span><br><span class="line">lift2 f (some n) (some m) = some (f m n)</span><br><span class="line">lift2 f _ _ = none</span><br><span class="line"></span><br><span class="line">add&apos; = lift2 add</span><br></pre></td></tr></table></figure>
<p>Trees<br>Binary trees as data as leaves</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data BTreeL (A : Set) : Set where</span><br><span class="line">  leaf : A -&gt; BTreeL A</span><br><span class="line">  node : BTreeL A -&gt; BTreeL A -&gt; BTreeL A</span><br></pre></td></tr></table></figure>
<p>S-expreesions<br><strong>def:</strong> used in <em>serialisation</em> of arbitrary data structures is the S-expression. It representes nested paranthetical expressions whose atomic values are (usually) strings.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Sexp (A : Set) : Set where</span><br><span class="line">  atom : A -&gt; Sexp A</span><br><span class="line">  list : List (Sexp A) -&gt; Sexp A</span><br></pre></td></tr></table></figure>
<p><em>example:</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">open import Agda.Builtin.String</span><br><span class="line"></span><br><span class="line">a-this = atom &quot;this&quot;</span><br><span class="line">a-is   = atom &quot;is&quot;</span><br><span class="line">a-an   = atom &quot;an&quot;</span><br><span class="line">a-s    = atom &quot;s&quot;</span><br><span class="line">a-exp  = atom &quot;expression&quot;</span><br><span class="line"></span><br><span class="line">l-is-an = list (cons a-is (cons a-an nil))</span><br><span class="line">l-s-exp = list (cons a-s (cons a-exp nil))</span><br><span class="line">l-ex    = list (cons a-this (cons l-is-an (cons l-s-exp nil)))</span><br></pre></td></tr></table></figure>
<h2 id="Induction-informally"><a href="#Induction-informally" class="headerlink" title="Induction (informally)"></a>Induction (informally)</h2><p>induction on Nat</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ind-nat : (P : Nat -&gt; Set)</span><br><span class="line">        -&gt; P zero</span><br><span class="line">        -&gt; ((n : Nat) -&gt; P n -&gt; P (suc n))</span><br><span class="line">        -&gt; (n : Nat) -&gt; P n</span><br></pre></td></tr></table></figure>
<p>addition</p>
<ul>
<li>0 is a unit of addition</li>
<li>addition is commutative</li>
</ul>
<p>induction on list</p>
<ul>
<li><code>nil</code> is a unit of <code>append</code></li>
<li><code>append</code> is associative</li>
</ul>
<h2 id="Revisit"><a href="#Revisit" class="headerlink" title="Revisit"></a>Revisit</h2><p>Add1 Nat -&gt; Nat -&gt; Nat<br>Add1 zero n = n</p>
<h2 id="add1-suc-m-n-suc-add1-m-n"><a href="#add1-suc-m-n-suc-add1-m-n" class="headerlink" title="add1 (suc m) n = suc (add1 m n)"></a>add1 (suc m) n = suc (add1 m n)</h2><p>add2 zero zero = zero<br>add2 zero (suc n) = suc n<br>add2 (suc n) zero = suc m<br>add2 (suc m) (suc n) = suc (suc (add2 m n))</p>
<p>for all m and n, add1 m n = add2 m n</p>
<p>P(m, n) : for all m , add1 m n = add2 m n</p>
<p>P(0,0) : add1 0 n = add2 0 n = n<br>Assume P(m,n),<br>P(0,suc n) :<br>P(suc m, 0) :</p>
<p>P(suc m, suc n) :</p>
<p>rev (rev xs) = xs : P(xs)</p>
<p>rev nil = nil<br>rev (cons x xs) = append (rev xs) (cons x nil)</p>
<p>P(nil) = rev (rev nil) = nil<br>Assume P(xs),<br>P(cons x xs) : rev (rev (cons x xs)) = cons x xs<br>           &gt;   rev (append (rev xs) (cons x nil))<br>               append (rev (cons x nil)) (rev rev(xs))<br>               append (cons x nil) xs<br>               cons x xs</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/jwyhhh123">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-I"><span class="toc-number">1.</span> <span class="toc-text">Part I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Propositional-logic（命题逻辑）"><span class="toc-number">1.1.</span> <span class="toc-text">Propositional logic（命题逻辑）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Natural-Deduction"><span class="toc-number">1.2.</span> <span class="toc-text">Natural Deduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semantics-truth-table"><span class="toc-number">1.3.</span> <span class="toc-text">Semantics, truth table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-strategy"><span class="toc-number">1.4.</span> <span class="toc-text">Proof strategy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equivalencies-and-normal-forms"><span class="toc-number">1.5.</span> <span class="toc-text">Equivalencies and normal forms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equivalencies"><span class="toc-number">1.6.</span> <span class="toc-text">Equivalencies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resolution-归结原理"><span class="toc-number">1.7.</span> <span class="toc-text">Resolution(归结原理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Satisfiability"><span class="toc-number">1.8.</span> <span class="toc-text">Satisfiability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-calculus-一阶逻辑"><span class="toc-number">1.9.</span> <span class="toc-text">Predicate calculus(一阶逻辑)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-Calculus-Proofs-amp-Identity"><span class="toc-number">1.10.</span> <span class="toc-text">Predicate Calculus: Proofs &amp; Identity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wrapping-Up-Summary"><span class="toc-number">1.11.</span> <span class="toc-text">Wrapping Up; Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-II"><span class="toc-number">2.</span> <span class="toc-text">Part II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming-part-Introduction"><span class="toc-number">2.1.</span> <span class="toc-text">:Programming part Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-Checking"><span class="toc-number">2.2.</span> <span class="toc-text">Proof Checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types"><span class="toc-number">2.3.</span> <span class="toc-text">Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-amp-pattern-matching（模式匹配）"><span class="toc-number">2.4.</span> <span class="toc-text">Functions &amp; pattern matching（模式匹配）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Isomorphisms"><span class="toc-number">2.5.</span> <span class="toc-text">Type Isomorphisms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-calculus-λ演算"><span class="toc-number">2.6.</span> <span class="toc-text">Lambda calculus(λ演算)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Church-encodings-编码"><span class="toc-number">2.7.</span> <span class="toc-text">Church encodings(编码)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-checking"><span class="toc-number">2.8.</span> <span class="toc-text">Type checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-inference-推理-given-a-proof-infer-to-its-type"><span class="toc-number">2.9.</span> <span class="toc-text">Type inference(推理): given a proof, infer to its type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Curry-Howord-correspondence"><span class="toc-number">2.10.</span> <span class="toc-text">Curry-Howord correspondence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CH-correspondence-props-types-proofs-terms-programs"><span class="toc-number">2.11.</span> <span class="toc-text">CH correspondence: props  types || proofs  terms (programs)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recursive-types-and-structural-recursion"><span class="toc-number">2.12.</span> <span class="toc-text">Recursive types and structural recursion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lists"><span class="toc-number">2.13.</span> <span class="toc-text">Lists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fold-reduce"><span class="toc-number">2.14.</span> <span class="toc-text">Fold(reduce)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#More-on-types"><span class="toc-number">2.15.</span> <span class="toc-text">More on types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Induction-informally"><span class="toc-number">2.16.</span> <span class="toc-text">Induction (informally)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Revisit"><span class="toc-number">2.17.</span> <span class="toc-text">Revisit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#add1-suc-m-n-suc-add1-m-n"><span class="toc-number">2.18.</span> <span class="toc-text">add1 (suc m) n = suc (add1 m n)</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&text=Log.logic"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&is_video=false&description=Log.logic"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Log.logic&body=Check out this article: https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&name=Log.logic&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Wenye Jin
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/jwyhhh123">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
