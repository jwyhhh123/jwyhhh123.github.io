<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Part IPropositional logic（命题逻辑）propositiondef : a sentence which states a fact which can be true or false.&amp;nbsp;Atomic propositions(atoms) :  propositions that cannot be broken into smaller parts they">
<meta property="og:type" content="article">
<meta property="og:title" content="Log.logic">
<meta property="og:url" content="https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/index.html">
<meta property="og:site_name" content="WY J">
<meta property="og:description" content="Part IPropositional logic（命题逻辑）propositiondef : a sentence which states a fact which can be true or false.&amp;nbsp;Atomic propositions(atoms) :  propositions that cannot be broken into smaller parts they">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-05-26T16:17:50.833Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Log.logic">
<meta name="twitter:description" content="Part IPropositional logic（命题逻辑）propositiondef : a sentence which states a fact which can be true or false.&amp;nbsp;Atomic propositions(atoms) :  propositions that cannot be broken into smaller parts they">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Log.logic</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/jwyhhh123">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/02/19/Log-AI/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/02/18/hello-World/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&text=Log.logic"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&is_video=false&description=Log.logic"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Log.logic&body=Check out this article: https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&name=Log.logic&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-I"><span class="toc-number">1.</span> <span class="toc-text">Part I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Propositional-logic（命题逻辑）"><span class="toc-number">1.1.</span> <span class="toc-text">Propositional logic（命题逻辑）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Natural-Deduction"><span class="toc-number">1.2.</span> <span class="toc-text">Natural Deduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semantics-truth-table"><span class="toc-number">1.3.</span> <span class="toc-text">Semantics, truth table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-strategies-I"><span class="toc-number">1.4.</span> <span class="toc-text">Proof strategies I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equivalencies"><span class="toc-number">1.5.</span> <span class="toc-text">Equivalencies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Normal-form"><span class="toc-number">1.6.</span> <span class="toc-text">Normal form</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resolution-归结原理"><span class="toc-number">1.7.</span> <span class="toc-text">Resolution(归结原理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-calculus-一阶逻辑"><span class="toc-number">1.8.</span> <span class="toc-text">Predicate calculus(一阶逻辑)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-II"><span class="toc-number">2.</span> <span class="toc-text">Part II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming-part-Introduction"><span class="toc-number">2.1.</span> <span class="toc-text">:Programming part Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-Checking"><span class="toc-number">2.2.</span> <span class="toc-text">Proof Checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types"><span class="toc-number">2.3.</span> <span class="toc-text">Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-amp-pattern-matching（模式匹配）"><span class="toc-number">2.4.</span> <span class="toc-text">Functions &amp; pattern matching（模式匹配）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-checking"><span class="toc-number">2.5.</span> <span class="toc-text">Type checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-inference-推理"><span class="toc-number">2.6.</span> <span class="toc-text">Type inference(推理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Curry-Howord-correspondence-continued"><span class="toc-number">2.7.</span> <span class="toc-text">Curry-Howord correspondence - continued</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inductive-types"><span class="toc-number">2.8.</span> <span class="toc-text">Inductive types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fold-reduce"><span class="toc-number">2.9.</span> <span class="toc-text">Fold(reduce)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#More-on-types"><span class="toc-number">2.10.</span> <span class="toc-text">More on types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Induction"><span class="toc-number">2.11.</span> <span class="toc-text">Induction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Revisit"><span class="toc-number">2.12.</span> <span class="toc-text">Revisit</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Log.logic
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">WY J</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-02-19T00:05:02.000Z" itemprop="datePublished">2019-02-19</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h1><h2 id="Propositional-logic（命题逻辑）"><a href="#Propositional-logic（命题逻辑）" class="headerlink" title="Propositional logic（命题逻辑）"></a>Propositional logic（命题逻辑）</h2><p><strong>proposition</strong><br>def : a sentence which states a fact which can be true or false.<br>&nbsp;<br>Atomic propositions(atoms) :</p>
<ul>
<li>propositions that cannot be broken into smaller parts</li>
<li>they are usually represented by symbols(P, Q, R…)</li>
</ul>
<p><strong>argument</strong><br>def : argument is a collection of propositions<br>&nbsp;<br>an argument can have 0 and more premises and 1 conclusion.<br>&nbsp;<br>Validity : an argument is valid iff its premises are true and its conclusion is true.</p>
<p><strong>Languages</strong><br>Semantics : the meaning of a formula in the language<br>Syntax : rules defining allowable formulas(sentences) in the language<br>&nbsp;<br>formula : </p>
<ul>
<li>Atomic formula   : if P is an atomic proposition, then P is a formula</li>
<li>Compound formula : if P and Q are formulas then so are ¬P, P ∧ Q, P ∨ Q and P -&gt; Q</li>
</ul>
<p>these are all called well-formed formulas.</p>
<p><strong>Connectives</strong><br>conjunction ∧ : and<br>disjunction ∨ : or<br>negation    ¬ : not<br>implication -&gt; : implies<br>&nbsp;<br>Avoid ambiguity using parentheses () : (P ∧ Q) ∨ R<br>&nbsp;<br>Precedence of connectives : (¬) &gt; (∧) &gt; (∨) &gt; (-&gt;)</p>
<p><strong>Parse trees</strong><br>def : we can use a tree to represent the syntactic structure of a sentence. For propositional logic, leaf nodes are atomic propositions and no-leaf nodes are connectives.<br>&nbsp;<br>Terminology :</p>
<ul>
<li>scope of a connective : connective itself and what it connects i.e. P -&gt; Q</li>
<li>main connective: the connective which connects the whole furmula</li>
</ul>
<p>scope = sub-tree<br>main connectice : root node</p>
<p><strong>Formal language</strong><br>Given an argument :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if John is at home, then his TV is on.</span><br><span class="line">His TV is not on.</span><br><span class="line">Therefore John is not at home.</span><br></pre></td></tr></table></figure>
<p>Collect atomic propositions :</p>
<ol>
<li>H = “John is at home”</li>
<li>O = “John’s TV is on”</li>
</ol>
<p>Argument in propositional logic :</p>
<ol>
<li>premise 1 : H -&gt; O</li>
<li>premise 2 : ¬O</li>
<li>conclusion : ¬H</li>
</ol>
<p>Written in sequent : H -&gt; O, ¬O : ¬H<br>&nbsp;<br>If the argument is valid we write : H -&gt; O, ¬O ⊢ ¬H</p>
<p>NOTE : When collecting atomic propositions, we only collect original symbol without any connectives. for example ‘his TV is not on’ we collect ‘his TV is on’. And for ‘Therefore John is not at home’ and ‘John is at home’ we only collect ‘John is at home’.</p>
<h2 id="Natural-Deduction"><a href="#Natural-Deduction" class="headerlink" title="Natural Deduction"></a>Natural Deduction</h2><p>def : In natural deduction, we use syntactic (rather than semantic) proof method<br>&nbsp;<br>Procedure :</p>
<ol>
<li>start with premises (we can assume these are true)</li>
<li>repeatedly apply inference rules (which preserve truth)</li>
<li>until we have inferred(推理) the conclusion</li>
</ol>
<p><strong>∧-introduction</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A   B</span><br><span class="line">-----  ∧ -introduction</span><br><span class="line">A ∧ B</span><br></pre></td></tr></table></figure>
<p><strong>∧-elimination</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A ∧ B </span><br><span class="line">-----  ∧ -elimination</span><br><span class="line">  A</span><br><span class="line"></span><br><span class="line">A ∧ B </span><br><span class="line">-----  ∧ -elimination</span><br><span class="line">  B</span><br></pre></td></tr></table></figure>
<p><strong>→-introduction</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ⊢ B </span><br><span class="line">-----  → -introduction</span><br><span class="line">A → B</span><br></pre></td></tr></table></figure>
<p><strong>→-elimination (modus ponens)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A → B  A </span><br><span class="line">--------  → -elimination</span><br><span class="line">    B</span><br></pre></td></tr></table></figure>
<p><strong>¬-introduction</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ⊢ ⊥ </span><br><span class="line">-----  ¬ -introduction</span><br><span class="line"> ¬A</span><br></pre></td></tr></table></figure>
<p><strong>¬¬-elimination</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">¬¬A </span><br><span class="line">---  ¬¬ -elimination</span><br><span class="line"> A</span><br></pre></td></tr></table></figure>
<p><strong>∨-introduction</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line">-----  ∨ -introduction</span><br><span class="line">A ∨ B</span><br><span class="line"></span><br><span class="line">  A</span><br><span class="line">-----  ∨ -introduction</span><br><span class="line">B ∨ A</span><br></pre></td></tr></table></figure>
<p><strong>∨-elimination</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ∨ B  A ⊢ C  B ⊢ C </span><br><span class="line">--------------------  ∨ -elimination</span><br><span class="line">         C</span><br></pre></td></tr></table></figure>
<h2 id="Semantics-truth-table"><a href="#Semantics-truth-table" class="headerlink" title="Semantics, truth table"></a>Semantics, truth table</h2><p><strong>Semantics of propositional logic</strong><br>An interpretation for a formula is a function I assigning a truth value to its atomic propositions.<br>&nbsp;<br>Semantics of a propositional logic formula φ is a truth value for each interpretation.<br>I ⊨ φ : I satisfies φ, where φ is true for interpretation I</p>
<p><strong>Truth table : semantic proof method</strong><br>Semantics of conjunction :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P     Q    P ∧ Q</span><br><span class="line"></span><br><span class="line">T     T      T</span><br><span class="line">T     F      F</span><br><span class="line">F     T      F</span><br><span class="line">F     F      F</span><br></pre></td></tr></table></figure>
<p>Semantics of disjunction :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P     Q    P ∨ Q</span><br><span class="line">T     T      T</span><br><span class="line">T     F      T</span><br><span class="line">F     T      T</span><br><span class="line">F     F      F</span><br></pre></td></tr></table></figure>
<p>Semantics of negation :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P    ¬P</span><br><span class="line">T     F</span><br><span class="line">F     T</span><br></pre></td></tr></table></figure>
<p>Semantics of implication :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P     Q     P → Q</span><br><span class="line">T     T       T</span><br><span class="line">T     F       F</span><br><span class="line">F     T       T</span><br><span class="line">F     F       T</span><br></pre></td></tr></table></figure>
<p>We can construct a truth table for any propostional formula.<br>example : given formula (P -&gt; Q) ∧ Q</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P   Q   |  P -&gt; Q    ¬Q     (P -&gt; Q) ∧ Q</span><br><span class="line">--------|-------------------------------</span><br><span class="line">T   T   |   T        F          F</span><br><span class="line">T   F   |   F        T          F</span><br><span class="line">F   T   |   T        F          F</span><br><span class="line">F   F   |   T        T          T</span><br></pre></td></tr></table></figure>
<p><strong>Semantic Notations</strong><br>A formula φ is :</p>
<ul>
<li>Satisfiable   : iff there exists one interpretation I ⊨ φ</li>
<li>Falsifiable   : iff there exists an interpretation that makes φ false</li>
<li>Unsatisfiable : iff there is no interpretation that make I ⊨ φ</li>
<li>Valid         : iff for all interpretation that I ⊨ φ</li>
</ul>
<p>NOTE: We are talking about formulas which can be both premises and conclusions<br>&nbsp;<br>Tautology (赘述) : iff it is valid i.e. P∨¬P, P→P, ¬(P∧¬P)<br>Contradiction : iff it unsatisfiable<br>Contingent (一组): iff it is both satisfiable and falsifiable i.e. P, P∧Q<br>&nbsp;<br>A formula is unsatisfiable if its negation is valid :<br>example : ¬(P ∧ ¬P)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P   ¬P  |  (P ∧ ¬P)   ¬(P ∧ ¬P)</span><br><span class="line">--------|----------------------</span><br><span class="line">T   F   |     F          T         </span><br><span class="line">F   T   |     F          T</span><br></pre></td></tr></table></figure>
<p><strong>Validity of argument</strong><br>Informally : whenever the premises are true, then so is the conclusion<br>Formally : the argument P1, .., Pn ⊨ C is valid iff every interpretation that satisfies all of the premises P1, .., Pn also satisfies the conclusion (I ⊨ Pn are true and I ⊨ C is true)</p>
<p>Steps :</p>
<ol>
<li>construct a truth table for premise(s) and conclusion.</li>
<li>when we found one that all premises are true and so is conclusion, it is valid.</li>
<li>when we found one that all premises are true and conclusion is false, it is invalid.</li>
</ol>
<p><strong>Comparison between truth table &amp; natural deduction</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true table                |   natural deduction</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">simple easy to automate   |   difficult to automate</span><br><span class="line">size is exponential       |   problem can be solved in a decent size</span><br><span class="line">invalidity can be checked |   no way to check validity</span><br><span class="line">                          |   can be adopted to predicate calculus</span><br></pre></td></tr></table></figure>
<h2 id="Proof-strategies-I"><a href="#Proof-strategies-I" class="headerlink" title="Proof strategies I"></a>Proof strategies I</h2><p><strong>Proof bt contradiction</strong><br>RAA : we can builf on ¬-introduction to prove non-negated propositions.<br>&nbsp;<br>Procedure :</p>
<ol>
<li>determine what we want to prove</li>
<li>hypothesize the negation of the conclusion C</li>
<li>until we infer to ¬¬ of C</li>
<li>using ¬¬-elimination to prove C</li>
</ol>
<p><strong>Inference rules</strong><br>Strategies :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Inference rule         Premises          Concl.        Annotation numbers           Dependencies</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">∧-intro x,y             A, B              A∧B        Premises are at lines x, y        Dx ∪ Dy</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">∧-elim x                 A∧B               A         Premise is at line x              Dx</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">∨-intro x                 A               A∨B        Premise is at line x              Dx</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">∨-elim x,y1,z1,y2,z2    A∨B, A⊢C, B⊢C      C         Disjunction is at line x,       (Dx ∪ Dz1 ∪ Dz2)</span><br><span class="line">                                                     sub-proofs are lines             \ (Dy1 ∪ Dy2)</span><br><span class="line">                                                     y1-z1 and y2-z2             </span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">→-intro y,z             A⊢B               A→B        Sub-proof is lines y-z           Dz \ Dy</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">→-elim x,y              A→B, A             B         Premises are at lines x, y       Dx ∪ Dy</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">¬-intro y,z              A⊢⊥              ¬A         Sub-proof is lines y-z           Dz \ Dy</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">¬¬-elim x                ¬¬A               A          Premise is at line x             Dx</span><br></pre></td></tr></table></figure>
<p>Hints :</p>
<ol>
<li>negation introduction can prove anything as we can hypothesize something negated, if there is a contradiction can be found, then we can prove the thing we want.</li>
</ol>
<p><strong>Rules of thumb</strong></p>
<ol>
<li>If the main connective in the CONCLUSION is an implication, use implication introduction</li>
<li>If the main connective in any of the PREMISES is a disjunction, try to use disjunction elimination</li>
<li>Otherwise, try negation introduction / proof by contradiction</li>
</ol>
<p><strong>Semantic and syntactic validity</strong><br>We have seen two methods to show validity of an argument :</p>
<ul>
<li>truth table construction [semantic validity]</li>
<li>natural deduction proofs [syntax validity]</li>
</ul>
<p>Semantic validity A1, …, An ⊨ B : an argument is valid iff whenever the premises are true, and so is the conclusion (As are true so is B)<br>&nbsp;<br>Syntactic validity A1, …, An ⊢ B : an argument is valid iff the conclusion can be derived from the premises by using inference rules (B can be proved by As)</p>
<p>NOTE : if there is no premise for an argument, we automatically think the truth values are true for each interpretation of the empty premise. so to check validity of : C we only need to check truth values of C for each interpretation.</p>
<p><strong>Disproving</strong><br>arguments disproving :</p>
<ol>
<li>give a counter-example</li>
<li>this means I(premises) is true and so is I(conclusion)</li>
<li>if all true then is valid </li>
<li>if premises are true and conclusion is false then is invalid.</li>
</ol>
<p><strong>Derived rules and reiterate</strong><br>proof decomposed into parts</p>
<ul>
<li>auxiliary arguments/derived inference rules (“lemmas”)</li>
<li>proved separately</li>
<li>inserted with sequent introduction</li>
</ul>
<p>in some case we may need to use a premise again, we can apply Reiterate<br>&nbsp;<br>Useful derived rules :<br>1) Sequent introduction (LEM) : P ∨ ¬P</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--------</span><br><span class="line">| ¬(P∨¬P)     hypo            &#123;1&#125;</span><br><span class="line">|  ------</span><br><span class="line">|  |  P       hypo            &#123;2&#125;</span><br><span class="line">|  |  P∨¬P    ∨-intro 2       &#123;2&#125;</span><br><span class="line">|  |  ⊥       ∧-intro 3,1    &#123;1,2&#125;</span><br><span class="line">|  ------</span><br><span class="line">|  ¬P         ¬-intro 2,4     &#123;1&#125;</span><br><span class="line">|  P∨¬P       ∨-intro 5       &#123;1&#125;</span><br><span class="line">|  ⊥          ∧-intro 6,1     &#123;&#125;</span><br><span class="line">--------</span><br><span class="line"> ¬¬(P∨¬P)     ¬-intro 1,7     &#123;&#125;</span><br><span class="line"> P∨¬P         ¬¬-elim 8       &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Soundness and Completeness</strong><br>Soundness : any syntactically valid argument is semantically valid<br>A1, …,An ⊢B implies A1, …,An ⊨B<br>&nbsp;<br>NOTE : this means if we can prove an argument then it is valid<br>&nbsp;<br>Completeness : any semantically valid argument is syntactically valid<br>A1, …,An ⊨ B implies A1, …,An ⊢ B<br>&nbsp;<br>NOTE : this means we can construct a proof of any valid argument<br>&nbsp;<br>Natural deduction is sound and complete : we can prove any valid argument.</p>
<h2 id="Equivalencies"><a href="#Equivalencies" class="headerlink" title="Equivalencies"></a>Equivalencies</h2><p>Some formulas are equivalent, written A ≡ B. The equivalence relationship is called semantically equivalent(or, provably equivalent).<br>&nbsp;<br>def : A ≡ B iff the truth values of A and B are the same for all interpretations<br>(A ≡ B iff A ⊨ B and B ⊨ A)</p>
<p><strong>Useful equivalence</strong><br>Commutativity: ∧ and ∨ are commutative </p>
<ul>
<li>A∧B ≡ B∧A</li>
<li>A∨B ≡ B∨A</li>
</ul>
<p>Associativity: ∧ and ∨ are associative </p>
<ul>
<li>A∧(B∧C) ≡ (A∧B)∧C</li>
<li>A∨(B∨C) ≡ (A∨B)∨C</li>
</ul>
<p>Idempotency: ∧ and ∨ are idempotent </p>
<ul>
<li>A∧A ≡ A</li>
<li>A∨A ≡ A</li>
</ul>
<p>Distributivity: ∧ distributes over ∨ (and vice versa) </p>
<ul>
<li>A∧(B∨C) ≡ (A∧B)∨(A∧C)</li>
<li>A∨(B∧C) ≡ (A∨B)∧(A∨C)</li>
</ul>
<p>De Morgan’s laws</p>
<ul>
<li>¬(A∧B) ≡ ¬A∨¬B </li>
<li>A∧B    ≡ ¬(¬A∨¬B) </li>
<li>¬(A∨B) ≡ ¬A∧¬B </li>
<li>A∨B    ≡ ¬(¬A∧¬B)</li>
</ul>
<p>Double negation </p>
<ul>
<li>¬¬A ≡ A</li>
</ul>
<p>Implication</p>
<ul>
<li>A→B ≡ ¬A∨B</li>
</ul>
<p>We can also define other new connectives</p>
<ul>
<li>A <-> B ≡ (A→B)∧(B→A) (bi-implication) </-></li>
<li>A (+) B ≡ (A∧¬B)∨(¬A∧B) (exclusive or)</li>
</ul>
<p><strong>Proving equivalences</strong><br>As given some useful equivalence relations above, we can prove equivalences by working forwards/backwards with a single proof or replacing subformulas with equivalent ones.<br>&nbsp;<br>example : (P ∧ Q) -&gt; S ≡ P -&gt; (Q -&gt; S)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(P ∧ Q) → S ≡ P → (Q → S)</span><br><span class="line">            ≡ ¬ (P ∧ Q) ∨ S    // implication</span><br><span class="line">            ≡ (¬ p ∨ ¬ q)∨ s   // de morgan&apos;s</span><br><span class="line">            ≡ ¬ p ∨ (¬ q ∨ s)  // distributivity</span><br><span class="line">            ≡ ¬ p ∨ (q → s)    // implication</span><br><span class="line">            ≡ p → (q → s)      // implication</span><br></pre></td></tr></table></figure>
<p>we can prove and disprove equivalences i.e. (P→Q)∧¬Q ≡ ¬P<br>&nbsp;<br>NOTE : equivalence is useful to check the (in)validity of argument.<br>&nbsp;<br>Redundancy : when applying equivalence equations, if we remove too many connectives it leads to lots of nesting and complex formulas. (so we introduce normal form)</p>
<h2 id="Normal-form"><a href="#Normal-form" class="headerlink" title="Normal form"></a>Normal form</h2><p>literal : a literal is an atomic proposition or its negation i.e. P or ¬P<br>&nbsp;<br>DNF(disjunction normal form) : a form of A1 ∨ A2 ∨ …∨ An where each clause(分句) Ai is a conjunction of one or more literals<br>i.e. (¬P ∧ Q) ∨ (¬P ∧ R) ∨ (¬P ∧ ¬R ∧ ¬Q)<br>&nbsp;<br>CNF(conjunction normal form) : a form of A1 ∧ A2 ∧ …∧ An where each clause Ai is a disjunction of one or more literals<br>i.e. (R ∨ ¬Q ∨ ¬P) ∧ (Q ∨ ¬R)<br>&nbsp;<br>Often, we write CNF into clausal normal form as a set of sets of literals</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;R, ¬Q, ¬P&#125;, &#123;Q, ¬R&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Conversion to normal form</strong><br>Procedure :</p>
<ol>
<li>eliminate -&gt; connectives</li>
<li>move all negations so they only occur in literals</li>
<li>use distributive laws until the formula is in normal form</li>
</ol>
<p><strong>Using CNF</strong><br>to make a CNF formula true, we need at least onw literal in each clause to be true. Often, we will check satisfiability of a CNF formula. i.e. (R ∨ ¬Q ∨ ¬P) ∧ (Q ∨ ¬R)<br>&nbsp;<br>Simplifications of Clausal normal form :<br>if a clause contains a literal and its negation, the clause can be removed from the CNF as truth always hold </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;R,¬Q,¬R&#125;,&#123;Q,¬P,R&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>if a clause is a subset of another clause, then the other clause can be removed from the CNF as truth is determined by the sub-clause </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;R,Q,¬P&#125;,&#123;Q,¬P&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Special cases :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;P&#125;, &#123;&#125;&#125; is false as the empty disjunction is false</span><br><span class="line">&#123; &#125; this is true as the empty conjunction is true</span><br><span class="line">&#123;&#123;Q&#125;, &#123;¬Q&#125;, &#123;P&#125;&#125; is false as Q and ¬Q is contradiction</span><br></pre></td></tr></table></figure>
<p>empty clauses are written as a square 口.<br>&nbsp;<br>NOTE :</p>
<ul>
<li>empty disjunction is false</li>
<li>empty conjunction is true</li>
</ul>
<h2 id="Resolution-归结原理"><a href="#Resolution-归结原理" class="headerlink" title="Resolution(归结原理)"></a>Resolution(归结原理)</h2><p>def : Unlike natural deduction, resolution has only 1 inference rule :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;A&#125; ∨ X1     &#123;¬A&#125; ∨ X2   </span><br><span class="line">----------------------- Resolution</span><br><span class="line">       X1 ∨ X2</span><br></pre></td></tr></table></figure>
<p>Special cases :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  A     ¬A ∨ B   </span><br><span class="line">--------------- Resolution  // -&gt; -elimination</span><br><span class="line">       B</span><br><span class="line"></span><br><span class="line"> A    ¬A   </span><br><span class="line">--------- Resolution  // contradiction introduction</span><br><span class="line">    ⊥</span><br></pre></td></tr></table></figure>
<p>NOTE : </p>
<ul>
<li>premises and conclusion are all disjunctions. </li>
<li>this works because A ∨ ¬A is always true.</li>
</ul>
<p><strong>Resolution refutation</strong><br>A formula φ is valid iff ¬φ is unsatisfiable. we can prove φ by proving ¬φ is a contradiction<br>&nbsp;<br>Procedure : check validity</p>
<ol>
<li>negate and convert to CNF/ clausal normal form</li>
<li>resolve pairs of formulas until :<ul>
<li>we find an empty clause 口(after we solve A and ¬A we got empty clause) : then φ is valid</li>
<li>we find there are no more new pairs to resolve or find it true : then φ is invalid</li>
</ul>
</li>
</ol>
<p>NOTE : it is sound and complete</p>
<p><strong>Satisfiability</strong><br>Checking validity via satisfiability</p>
<ul>
<li>formula φ is valid iff ¬φ is unsatisfiable </li>
<li>formula φ is invalid iff ¬φ is satisfiable </li>
</ul>
<p>we can then, use these to show whether a argument is valid or not.</p>
<p><strong>Proving arguments’ validity</strong><br>Procedure :</p>
<ol>
<li>A1, …, An ⊢ C is valid iff (A1 ∧ …∧ An) -&gt; C is valid</li>
<li>¬((A1 ∧ …∧ An) -&gt; C) ≡ A1 ∧…∧ An ∧ ¬C</li>
<li>convert to clausal normal form</li>
<li>apply resolution inference rule repeatly</li>
</ol>
<p><strong>SAT solver</strong><br>“TheScienceofBruteForce”,MarijnJ.H.Heule,OliverKullmann  – <a href="https://cacm.acm.org/magazines/2017/8/219606-the-science-of-brute-force/fulltext" target="_blank" rel="noopener">https://cacm.acm.org/magazines/2017/8/219606-the-science-of-brute-force/fulltext</a> – state-of-the-artSATandautomatedmathematicalproofs  <br>Z3: a theorem prover, including both SAT/SMT solvers – <a href="https://rise4fun.com/z3/tutorial" target="_blank" rel="noopener">https://rise4fun.com/z3/tutorial</a> </p>
<h2 id="Predicate-calculus-一阶逻辑"><a href="#Predicate-calculus-一阶逻辑" class="headerlink" title="Predicate calculus(一阶逻辑)"></a>Predicate calculus(一阶逻辑)</h2><p><strong>Key ingredients</strong><br>Domain(universe) : non-empty set of individuals to reason about<br>&nbsp;<br>Constant : specific instances of individual(elements in domain); denoted as a,b,c<br>&nbsp;<br>Variables : symbols to represent individuals, variables x,y,z<br>&nbsp;<br>Quantifiers : (x is variable)</p>
<ul>
<li>∀x[…] = “forallx…” (universal quantifier)</li>
<li>∃x[…] = ”thereexistsxsuchthat…” (existential quantifier)</li>
</ul>
<p>Predicates : a proposition evaluates to true and false</p>
<p><strong>Predicate calculus examples</strong><br>Predicate symbols :<br>F(x) = x is fast<br>R(x) = x is red<br>P(x) = x is purple<br>&nbsp;<br>All cars are fast </p>
<ul>
<li>∀x[F(x)]</li>
</ul>
<p>All red cars are fast </p>
<ul>
<li>∀x[R(x)→F(x)]</li>
</ul>
<p>Some red cars are fast </p>
<ul>
<li>∃x[R(x)∧F(x)]</li>
<li>not:∃x[R(x)→F(x)]</li>
</ul>
<p>There are no red cars </p>
<ul>
<li>¬∃x[R(x)]</li>
<li>or:∀x[¬R(x)]</li>
</ul>
<p>No fast cars are purple</p>
<ul>
<li>¬∃x[F(x)∧P(x)]</li>
<li>or:∀x[F(x)→¬P(x)]</li>
</ul>
<p>NOTE : ∃x[R(x)→F(x)] cannot be applied as we can find a counterexample where R(x) -&gt; F(x) is true but R(x) is false. it means there is some red cars which are fast but it is not red.</p>
<p><strong>Scope</strong><br>def : in predicate calculus, we focus on the scope of a variable which is the scope of the quantifier that it is bound to.<br>&nbsp;<br>example : ∀x[F(x) → ¬P(x)].<br>the scope of x is F(x) → ¬P(x)<br>&nbsp;<br>example : ∀y[F(y) → ¬P(y)].<br>the scope of y is F(y) → ¬P(y)</p>
<p><strong>Syntax</strong><br>term : either a variable x or a constant a<br>&nbsp;<br>well-formed Formula :<br>if P is a predicate symbol and t1, .., tn are terms then P(t1, .., tn) is a formula<br>if φ and ψ are formulas then ¬φ, φ∧ψ, φ∨ψ and φ→ψ are all formulas<br>if x is a variable and φ is a formula then ∀x[φ] and ∃x[φ] are formulas</p>
<p><strong>Natural deduction</strong><br>in predicate calculus, we prove validity by applying natural deduction<br>&nbsp;<br>Inference rules :<br>1) ∀-introduction </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   φ(a)</span><br><span class="line">----------- ∀-introduction</span><br><span class="line"> ∀x [φ(x)]</span><br></pre></td></tr></table></figure>
<p>NOTE : a needs to be a typical example of x. it means we know nothing else about a. to be more precise, φ(a) cannot be a premise.<br>&nbsp;<br>2) ∀-elimination</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ∀x [φ(x)]</span><br><span class="line">----------- ∀-elimination</span><br><span class="line">   φ(a)</span><br></pre></td></tr></table></figure>
<p>3) ∃-introduction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   φ(a) </span><br><span class="line">----------- ∃-introduction</span><br><span class="line"> ∃x [φ(x)]</span><br></pre></td></tr></table></figure>
<p>4) ∃-elimination</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ∃x [φ(x)]   φ(a)⊢C</span><br><span class="line">-------------------- ∃-elimination</span><br><span class="line">          C</span><br></pre></td></tr></table></figure>
<p>NOTE : a needs to be typical example of x. it means a cannot occur in the conclusion C and cannot occur in any dependencies of C. a cannot be a premise.</p>
<p><strong>Semantics</strong><br>an interpretation is a pair (D, I) where :</p>
<ul>
<li>D : domain</li>
<li>I : the meaning of all predicates in terms of D</li>
<li>it defines whether P(a1, .., an) is true or false</li>
</ul>
<p><strong>Validity and Satisfiability</strong><br>argument validity : an argument  A1,…,An : C is valid in predicate logic iff we can find a case where every interpreration of premise is true and so is the conclusion<br>&nbsp;<br>a formula φ is valid in PL iff φ is true for every possible domain/interpretation<br>a formula φ is satisfiable iff φ is true for some domain/interpretation<br>&nbsp;<br>NOTE : we will use natural deduction to check validity a sthe domains can be infinite which make the truth table unable to be set up.<br>&nbsp;<br>Validity check :</p>
<ul>
<li>formula φ is valid iff ¬φ is unsatisfiable </li>
<li>formula φ is invalid iff ¬φ is satisfiable</li>
</ul>
<p>example : ∀x[∀y[P(x)∧¬P(y)]] show the formula’s satisfiability</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) negate : ¬ ∀x[∀y[P(x)∧¬P(y)]]</span><br><span class="line">2) we found when x = a and y = b</span><br><span class="line">    P(a) = true</span><br><span class="line">    P(b) = true</span><br><span class="line">    ¬ ∀x[∀y[P(x)∧¬P(y)]] = true</span><br><span class="line">   it is valid</span><br><span class="line">3) hence ∀x[∀y[P(x)∧¬P(y)]] is unsatisfiable</span><br></pre></td></tr></table></figure>
<p><strong>Disproving</strong><br>to disprove an argument we need to find a counter-example :</p>
<ol>
<li>give the domain of the premises and conclusion</li>
<li>assign truth values for each constant</li>
<li>if there is a case when premises are all true but conclusion is false</li>
<li>then it is invalid</li>
</ol>
<p>example : ∃x[F(x)∨G(x)], ∃x[¬F(x)] : ∃x[G(x)]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">give the domain &#123;a, b&#125;    //as we have two premises</span><br><span class="line">F(a) = true   G(a) = false</span><br><span class="line">F(b) = false  G(b) = false</span><br><span class="line"></span><br><span class="line">assign the values we got F(a) ∨ G(a) = true</span><br><span class="line">assign the values we got ¬F(b) = true</span><br><span class="line"></span><br><span class="line">but the conclusion we got is false (a and b both false)</span><br></pre></td></tr></table></figure>
<p><strong>Equivalence</strong><br>some useful equivalence relations :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">¬∃x[B] ≡ ∀x[¬B] </span><br><span class="line">¬∀x[B] ≡ ∃x[¬B]</span><br><span class="line"> ∃x[B] ≡ ¬∀x[¬B]</span><br><span class="line"> ∀x[B] ≡ ¬∃x[¬B]</span><br></pre></td></tr></table></figure>
<p>De Morgans law also holds :<br>example : no fast cars are purple</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">¬∃x[F(x) ∧ P(x)] ≡ ∀x[F(x) → ¬P(x)]</span><br><span class="line">                 ≡ ∀x[¬(F(x) ∧ P(x))]</span><br><span class="line">                 ≡ ∀x[¬F(x) ∨ ¬P(x))]</span><br><span class="line">                 ≡ ∀x[F(x) → ¬P(x))]</span><br></pre></td></tr></table></figure>
<p><strong>Relations</strong><br>an equivalence relation is :</p>
<ul>
<li>reflexive L(a,a)</li>
<li>summetric L(a,b) -&gt; L(b,a)</li>
<li>transitive L(a,b) L(b,c) -&gt; L(a,c)</li>
</ul>
<p><strong>Identity</strong><br>identity equivalence : x = y<br>non-equivalence : ¬(x = y)<br>&nbsp;<br>example :<br>John is the tallest person<br>given predicate symbol : T(x,y) meaning x is taller than y<br>given constant j = John</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∀x[¬(x = j) -&gt; T(j,x)]</span><br></pre></td></tr></table></figure>
<p>NOTE : ∀x[T(j,x)] is wrong because the domain is people while John cannot be taller than himself when x = j.<br>&nbsp;<br>example : Everybody except John and Chris loves Mary<br>given predicate symbol L(x,y) meaning x loves y<br>given constant j = John, c = Chris and m = Mary</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∀x[¬(x = j, x = c) -&gt; L(x,m)]</span><br></pre></td></tr></table></figure>
<p>Inference rules :<br>1) identity -introduction :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">------- =-introduction</span><br><span class="line"> a = a</span><br></pre></td></tr></table></figure>
<p>2)identity -elimination :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b  φ(a)</span><br><span class="line">----------- =-elmination</span><br><span class="line">   φ(b)</span><br></pre></td></tr></table></figure>
<p><strong>Qunantities</strong><br>quantifiers are able to state quantities :</p>
<ul>
<li>0 : ¬∃x(Q(x))</li>
<li>at least 1 : ∃x[Q(x)]</li>
<li>at most 1 : ∀x[∀y[(Q(x) ∧ Q(y)) -&gt; (x = y)]]</li>
<li>at least 2 : ∃x[∃y[(Q(x) ∧ Q(y)) ∧ ¬(x = y)]] …</li>
<li>exactly 1 : ∃x[Q(X)] ∧ ∀x[∀y[Q(x) ∧ Q(y) -&gt; (x = y)]]</li>
<li>all : ∀x</li>
</ul>
<p><strong>Definite descriptions</strong><br>def: refering to a specific individual without constant symbol<br>&nbsp;<br>example : the person who loves Mary also loves Chris</p>
<h1 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h1><h2 id="Programming-part-Introduction"><a href="#Programming-part-Introduction" class="headerlink" title=":Programming part Introduction"></a>:Programming part Introduction</h2><p>paradox(悖论): “what i am saying is wrong”<br>&nbsp;<br>a formal system:</p>
<ul>
<li>sound(true then cannot be false)</li>
<li>complete(true or false can be determined)</li>
<li>computable(be computed by machine)</li>
</ul>
<h2 id="Proof-Checking"><a href="#Proof-Checking" class="headerlink" title="Proof Checking"></a>Proof Checking</h2><p><strong>Inference rules</strong><br>and-elimination:</p>
<ul>
<li>andEl : {P Q : Prop}   -&gt; P and Q -&gt; P</li>
<li>andEr : {P Q : Prop}   -&gt; P and Q -&gt; Q</li>
</ul>
<p>and-introduction:</p>
<ul>
<li>andI : {P Q : Prop}   -&gt; P -&gt; Q -&gt; P and Q</li>
</ul>
<p>or-introduction</p>
<ul>
<li>orIl : {P Q : Prop}   -&gt; p -&gt; P or Q</li>
<li>orIr : {P Q : Prop}   -&gt; Q -&gt; P or Q</li>
</ul>
<p>or-elimination</p>
<ul>
<li>orE : {P Q R : Prop}   -&gt; P or Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R</li>
</ul>
<p>falsity-elimination</p>
<ul>
<li>ENQ : {P : Prop}   -&gt; Falsity -&gt; P</li>
</ul>
<p>double-negation-elimination</p>
<ul>
<li>DNE : {P : Prop}  -&gt; (not (not P)) -&gt; P</li>
</ul>
<p>Modus ponens</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mp: &#123;P Q : Prop&#125;  -&gt; (P -&gt; Q) -&gt; P -&gt; Q</span><br><span class="line">mp  &#123;P&#125; &#123;Q&#125;          f           p  = q where</span><br><span class="line"> q: Q        </span><br><span class="line"> q = f p</span><br></pre></td></tr></table></figure>
<p>Implication introduction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">comp : &#123;A B C : Prop&#125; -&gt; (f : A -&gt; B) -&gt; (g : B -&gt; C) -&gt; (A -&gt; C) </span><br><span class="line">comp &#123;A&#125; &#123;B&#125; &#123;C&#125; f g = h where</span><br><span class="line">  h : A -&gt; C</span><br><span class="line">  h a = c where</span><br><span class="line">    b : B</span><br><span class="line">    b = f a</span><br><span class="line">    c : C</span><br><span class="line">    c = g b</span><br></pre></td></tr></table></figure>
<p>NOTE : before the last proposition, these are all hypothesis(premises).</p>
<p><strong>Negation</strong><br>we write (not A) as : A -&gt; Falsity</p>
<p>Double negation introduction:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DNI : &#123;A : Prop&#125; : A -&gt; (A -&gt; Falsity) -&gt; Falsity</span><br><span class="line">DNI &#123;A&#125; a f = x where</span><br><span class="line">  x : Falsity</span><br><span class="line">  x = f a</span><br></pre></td></tr></table></figure>
<p>Triple negation elimination</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TNE : &#123;A : Prop&#125; -&gt; (f : (not (not A)) -&gt; Falsity) -&gt; (a : A) -&gt; Falsity</span><br><span class="line">TNE &#123;A&#125; f a = x where</span><br><span class="line">  y : not (not A)</span><br><span class="line">  y = DNI a</span><br><span class="line">  x : Falsity</span><br><span class="line">  x = f y</span><br></pre></td></tr></table></figure>
<p><strong>Proof terms</strong><br>def : fully-inlined(完全内联的) proofs with no auxiliary(辅助的) definitions<br>&nbsp;<br>NOTE: all the definitions above can be inlined by removing auxiliary clauses.</p>
<p><strong>Law of Excluded Middle</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE goal where</span><br><span class="line">  goal : (P or (P -&gt; Falsity) -&gt; Falsity) -&gt; Falsity</span><br><span class="line">  goal z = z u where</span><br><span class="line">    v : P -&gt; Falsity</span><br><span class="line">    v x = z w where</span><br><span class="line">      w : P or (P -&gt; Falsity)</span><br><span class="line">      w = orIl x </span><br><span class="line">    u : P or ( P -&gt; Falsity)</span><br><span class="line">    u = orIr v</span><br></pre></td></tr></table></figure>
<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p><strong>Introduce functions</strong><br>Some functions written in Agda:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f : Nat -&gt; Nat</span><br><span class="line">f x = 3 * x +7</span><br><span class="line"></span><br><span class="line">g : Nat -&gt; Nat</span><br><span class="line">g x = 4 * x * x + 9 * x + 10</span><br><span class="line"></span><br><span class="line">m : Nat</span><br><span class="line">m = max (f 9) (g 6)</span><br></pre></td></tr></table></figure>
<p>NOTE: by using a programming language, we read <code>p : A</code> as a program <code>p</code> has type A, and <code>f : A -&gt; B</code> as <code>f</code> is a function converting A to B.</p>
<p><strong>Basic types or enums</strong><br>Void type :<br>no constructor so this type cannot be instantiated</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data Void : Set where</span><br></pre></td></tr></table></figure>
<p><code>data</code>  : introduces the definition<br><code>Void</code>  : the name of the type<br><code>Set</code>   : it is a type<br><code>where</code> : introduces the constructors</p>
<p>Empty type :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data unit : Set where</span><br><span class="line">  empty : unit</span><br></pre></td></tr></table></figure>
<p>Boolean type :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data Boolean : Set where</span><br><span class="line">  true false : Boolean</span><br></pre></td></tr></table></figure>
<p><strong>Composite(复合的) types</strong><br>def : we can put two existing data types together to form a new data type.<br>&nbsp;<br>Product (tuple) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data Prod (X Y : Set) : Set where</span><br><span class="line">  pair : X -&gt; Y -&gt; Prod X Y</span><br></pre></td></tr></table></figure>
<p><code>data</code>        : we are defining a data type<br><code>Prod</code>        : the name of the data type<br><code>(A B : Set)</code> : A and B are other data types<br><code>: Set</code>       : we are defining a type indeed<br><code>where</code>       : definitions to follow<br><code>pair</code>        : the name of the constructor<br><code>X -&gt; Y -&gt; Prod X Y</code> : the type of the constructor. given <code>X</code> and <code>Y</code> and return their product <code>Prod X Y</code>. </p>
<p>Sum (union) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Sum (A B : Set) : Set where</span><br><span class="line">  left  : A -&gt; Sum A B</span><br><span class="line">  right : B -&gt; Sum A B</span><br></pre></td></tr></table></figure>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x : Sum Boolean (Prod Unit Unit)</span><br><span class="line">x = left true</span><br><span class="line"></span><br><span class="line">y : Sum Boolean (Prod Unit Unit)</span><br><span class="line">y = right (pair empty empty)</span><br></pre></td></tr></table></figure>
<p>NOTE: <code>Sum</code> and <code>Prod</code> are usually called algrebraic types.</p>
<p><strong>The differences between Sum and Prod</strong><br>If type <code>A</code> has <code>m</code> elements and type <code>B</code> has <code>n</code> elements, then:</p>
<ul>
<li>How many elements has <code>Sum A B</code>?  m + n;</li>
<li>How many elements has <code>Prod A B</code>?  m x n;</li>
<li>can we define any element of <code>Prod A Void</code> for some <code>A</code>?     null; because void cannot be instantiated</li>
<li>can we define any element of <code>Sum A Void</code> for some <code>A</code>?   A; because right can be instantiated</li>
</ul>
<h2 id="Functions-amp-pattern-matching（模式匹配）"><a href="#Functions-amp-pattern-matching（模式匹配）" class="headerlink" title="Functions &amp; pattern matching（模式匹配）"></a>Functions &amp; pattern matching（模式匹配）</h2><p>def: As we have constructed some data types before, we want to access the data inside a type in functional languages, so we introduce destructors. These destructors are built into function definitions via a mechanism known as pattern-matching.</p>
<p><strong>Pattern matching enumerations</strong><br>The pattern matching machanism will check all cases are covered. If we lost some cases Agda will throw an error.<br>&nbsp;<br>pattern matching <code>and</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and : Boolean -&gt; Boolean -&gt; Boolean</span><br><span class="line">and true  true  = true</span><br><span class="line">and true  false = false</span><br><span class="line">and false true  = false</span><br><span class="line">and false false = false</span><br></pre></td></tr></table></figure>
<p>In order to avoid missing cases, we can simplify to :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and : Boolean -&gt; Boolean -&gt; Boolean</span><br><span class="line">and true true = true</span><br><span class="line">and x y = false</span><br></pre></td></tr></table></figure>
<p>as we can see the remaining cases are all concluded to false, the truth values can be assigned to x and y. And from top to bottom, each case is covered.<br>&nbsp;<br>If a case is not actually used, we can assign <code>_</code>. for example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and : Boolean -&gt; Boolean -&gt; Boolean</span><br><span class="line">and true true = true</span><br><span class="line">and _ _ = false                  ... if the remaining cases are unused...</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">pattern matched type can be used to define other functions relating to it :</span><br></pre></td></tr></table></figure>
<p>nand : Boolean -&gt; Boolean -&gt; Boolean<br>nand true true = false<br>nand x y = true</p>
<p>negate : Boolean -&gt; Boolean<br>negate x = nand x x<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">where the second Boolean is a result of nand (Boolean -&gt; Boolean).</span><br><span class="line"></span><br><span class="line">**Pattern matching prod**</span><br><span class="line">Sightly different, the function we pattern match here is composite, namely polymorphic(working for more than one types). So we need to specify that types we are using :</span><br></pre></td></tr></table></figure></p>
<p>proj1 : {A B : Set} -&gt; Prod A B -&gt; A<br>proj1 (pair a _) = a                    … b is unused …</p>
<p>proj2 : {A B : Set} -&gt; Prod A B -&gt; B<br>proj2 (pair _ b) = b                    … a is unused …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NOTE : here we have seperate pattern matching functions. As type of A and type of B are elements in `Prod`, whenever we are given an element of that type we match it against `pair a b`.</span><br><span class="line"></span><br><span class="line">**Pattern matching sum**</span><br><span class="line">Important to remember, we need to pattern match all cases appearing in each single type. Example below, as `sum Unit Unit` has as many proof terms as Boolean, so we have :</span><br></pre></td></tr></table></figure></p>
<p>f : Sum Unit Unit -&gt; Boolean<br>f (left x)  = true<br>f (right y) = false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from the opposite we have :</span><br></pre></td></tr></table></figure></p>
<p>g : Boolean -&gt; Sum Unit Unit<br>g true  = left empty<br>g false = right empty<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Example : since `A + A = 2 * A`, we can convert between `Sum A A` and `Prod Boolean A`</span><br></pre></td></tr></table></figure></p>
<p>h : {A : Set} -&gt; Sum A A -&gt; Prod Boolean A<br>h (left a)  = pair true a<br>h (right a) = pair false a</p>
<p>i : {A : Set} -&gt; Prod Boolean A -&gt; Sum A A<br>i (pair true a) = left a<br>i (pair false a) = right a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**A special case**</span><br><span class="line">We can pattern match `Void` using () :</span><br></pre></td></tr></table></figure></p>
<p>impossible : {A : Set} -&gt; void -&gt; A<br>impossible ()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NOTE : there is no = sign as we need no definition</span><br><span class="line">&amp;nbsp;</span><br><span class="line">Example: Convert between `Sum A Void` and `A`.</span><br></pre></td></tr></table></figure></p>
<p>j : {A : Set} -&gt; Sum A Void -&gt; A<br>j left a = a<br>j (right ())<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**Generally**</span><br><span class="line">Note that arbitrary types can be created using the language of type definition, and they are always destructed via pattern matching :</span><br></pre></td></tr></table></figure></p>
<p>data Foo (A : Set) : Set where<br> foo1 : Foo A<br> foo2 : A -&gt; A -&gt; Foo A<br> foo3 : A -&gt; A -&gt; Foo A</p>
<p>ff : {A : Set} -&gt; Foo A -&gt; Foo A<br>ff foo1 = foo1<br>ff (foo2 x y) = foo3 y x<br>ff (foo3 x _) = foo2 x x<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Type Isomorphisms</span><br><span class="line">**A note on syntax**</span><br><span class="line">if we look the examples below, the only difference is in the proj2 we remove &#123;A&#125; and &#123;B&#125;. This is because we did not use them in the definition.</span><br></pre></td></tr></table></figure></p>
<p>proj1 : {A B : Set} -&gt; Prod A B -&gt; A<br>proj1 {A} {B} (pair a b) = a</p>
<p>proj2 : {A B : Set} -&gt; Prod A B -&gt; A<br>proj2 (pair a b) = a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Another example : modus ponens</span><br></pre></td></tr></table></figure></p>
<p>mp : {A B : Set} -&gt; (A -&gt; B) -&gt; A -&gt; B<br>mp {A} {B} f a = b where<br>  b : B                         …we used B here…<br>  b = f a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if we inline the definition and remove optional arguments we have :</span><br></pre></td></tr></table></figure></p>
<p>mp : {A B : Set} -&gt; (A -&gt; B) -&gt; A -&gt; B<br>mp f a = f b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**Type isomorphism**</span><br><span class="line">def : The existence of invertible functions `f : A -&gt; B`, and `g : B -&gt; A` means that the two types are isomorphic (&quot;same shape&quot;), written `A ~ B`. Isomorphism is a very important mathematical and programming concept, indicating that data can be converted between the two without loss of precision.</span><br><span class="line">&amp;nbsp;</span><br><span class="line">Type isomorphisms are consistent in semi-ring :</span><br></pre></td></tr></table></figure></p>
<pre><code>A + (B + C) ~ (A + B) + C
      A + B ~ B + A
      A + B ~ A
A * (B * C) ~ (A * B) * C
      A * B ~ B * A
      A * 1 ~ A
A * (B + C) ~ A * B + A * C
(A + B) * C ~ A * C + B * C
      A * 0 ~ 0 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Example: Show that `A + (B + C) ~ (A + B) + C`.</span><br></pre></td></tr></table></figure>
<p>q1-to : {A B C : Set} -&gt; Sum A (Sum B C) -&gt; Sum (Sum A B) C<br>q1-to (left a) = left (left a)<br>q1-to (right (left b)) = left (right b)<br>q1-to (right (right c)) = right c</p>
<p>q1-from : {A B C : Set} -&gt; Sum (Sum A B) C -&gt; Sum A (Sum B C)<br>q1-from (left (left a)) = left a<br>q1-from (left (right b)) = right (left b)<br>q1-from (right c) = right (right c)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">To check that these are inverse, we want to show q1-to (q1-from x) = x and q1-from (q1-to x) = x :</span><br></pre></td></tr></table></figure></p>
<p>q1-to (q1-from (left (left a))) = q1-to (left a) = left (left a)<br>q1-to (q1-from (left (right b))) = q1-to (right (left b)) = left (right b)<br>q1-to (q1-from (right c)) = q1-to (right (right c)) = right c</p>
<p>q1-from (q1-to (left a)) = q1-from (left (left a)) = left a<br>q1-from (q1-to (right (left b))) = q1-from (left (right b)) = right (lef b)<br>q1-from (q1-to (right (right c))) = q1-from (right c) = right (right c)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Curry-Howard Correspondence</span><br><span class="line">def : the correspondence between logic and types. This correspondence is, in a mathematical sense, an isomorphism.</span><br><span class="line">&amp;nbsp;</span><br><span class="line">1) Propositions correspond to types:</span><br><span class="line">* Falsity ~ Void</span><br><span class="line">* Truth   ~ Unit</span><br><span class="line">* A and B ~ Prod A B</span><br><span class="line">* A or B  ~ Sum A B</span><br><span class="line"></span><br><span class="line">Postulates should be implementable as functions :</span><br></pre></td></tr></table></figure></p>
<p>  andEl  : {P Q : Prop}   -&gt; P and Q -&gt; P<br>  andEr  : {P Q : Prop}   -&gt; P and Q -&gt; Q<br>  andI   : {P Q : Prop}   -&gt; P -&gt; Q -&gt; P and Q<br>  orE    : {P Q R : Prop} -&gt; P or Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R<br>  orIl   : {P Q : Prop}   -&gt; P -&gt; P or Q<br>  orIr   : {P Q : Prop}   -&gt; Q -&gt; Q or P<br>  EFQ    : {P : Prop}     -&gt; Falsity -&gt; P<br>  DNE    : {P : Prop}     -&gt; (not (not P)) -&gt; P<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Due to the isomorphism between types and propositions, we can implement postulates as functions with these types :</span><br></pre></td></tr></table></figure></p>
<p>andEl’ : {P Q : Set} -&gt; Prod P Q -&gt; P<br>andEl’ (pair p _) = p</p>
<p>andEr’ : {P Q : Set} -&gt; Prod P Q -&gt; Q<br>andEr’ (pair _ q) = q</p>
<p>andI’ : {P Q : Set} -&gt; P -&gt; Q -&gt; Prod P Q<br>andI’ p q = pair p q</p>
<p>orE’ : {P Q R : Set} -&gt; Sum P Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R<br>orE’ (left p)  f g = f p<br>orE’ (right q) f g = g q</p>
<p>orIl’ : {P Q : Set} -&gt; P -&gt; Sum P Q<br>orIl’ p = left p</p>
<p>orIr’ : {P Q : Set} -&gt; Q -&gt; Sum P Q<br>orIr’ q = right q</p>
<p>EFQ’ : {P : Set} -&gt; Void -&gt; P<br>EFQ’ ()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">We left Double negation elimination out as this cannot be implemented by Curry-Howard Correspondence :</span><br></pre></td></tr></table></figure></p>
<p>DNE’ : {P : Prop} -&gt; ((P -&gt; Void) -&gt; Void) -&gt; P<br>DNE’ x = ?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If we could implement `DNE`, then we can derive an implementation of Law of Excluded Middle :</span><br></pre></td></tr></table></figure></p>
<p>LEM : {P : Set } -&gt; Sum P (P -&gt; Void)<br>LEM = DNE’ goal where<br>  goal z = z (orIr v) where<br>     v x = z (orIl x)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The reason is as we think P as &quot;termination checker&quot; and P -&gt; Void as &quot;non-termination checker&quot; in a turing machine, the function LEM can compute the solution to the Halting problem.</span><br><span class="line">&amp;nbsp;</span><br><span class="line">NOTE :  CH correspondence provides an idea to construct logic without DNE, LEM which is named as constructive logic. Constructive logic means the logic of computation.</span><br><span class="line"></span><br><span class="line">**Proof relevance**</span><br><span class="line">Constructive logic takes the concept of proof as essential. In contrast, classical logic (constructive logic + DNE) takes the concept of truth as essential. To guid your intuition it is best not to think of a constructive-logic proposition `A` as true but, if there is a `p` such that `p : A` you should think of it as _proved by `p`_. </span><br><span class="line"></span><br><span class="line">In constructive logic, this helps us distinguish between propositions (as types) more carefully. </span><br><span class="line"></span><br><span class="line">We know that &quot;true or true is equivalent to true&quot;. This is the case clasically and constructively. We can prove that by constructing the function-proof-term of the corresponding types:</span><br></pre></td></tr></table></figure></p>
<p>suu-u : Sum Unit Unit -&gt; Unit<br>suu-u (left empty) = empty<br>suu-u (right empty) = empty </p>
<p>u-suu : Unit -&gt; Sum Unit Unit<br>u-suu empty = left empty<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">However, these functions do not set up an isomorphism; `u-suu` is obviously not a bijection, since `Sum Unit Unit` has 2 elements and `Unit` only 1. Indeed, it is not the case that (using the algebraic notation) `1 + 1 ~ 1`.</span><br><span class="line"></span><br><span class="line">This means that proofs matter. Proofs are relevant. `Unit` and `Sum Unit Unit` are both provable, but the former has essentially one proof(-term), and the latter two proof(-term)s. </span><br><span class="line"></span><br><span class="line">## Lambda calculus(λ演算)</span><br><span class="line">**def:** due to CH correspondence, 2) proofs of implication correspond to functions. we use Lambda calculus to formalise the concept of computability by using a simple notion of functions.</span><br><span class="line">&amp;nbsp;</span><br><span class="line">lambda calculus consists of :</span><br><span class="line">1. variables x, y ...</span><br><span class="line">2. function definition `\x -&gt; F`</span><br><span class="line">3. function application `f x`</span><br><span class="line"></span><br><span class="line">In Agda we write `\x -&gt; F`. </span><br><span class="line">`x`: variable binding</span><br><span class="line">`F`: another lambda term formed by variables, function application, and function definition</span><br><span class="line">&amp;nbsp;</span><br><span class="line">NOTE : functions in lambda calculus are called terms.</span><br><span class="line">&amp;nbsp;</span><br><span class="line">examples:</span><br></pre></td></tr></table></figure></p>
<p>\x -&gt; x + 1<br>\x -&gt; \y -&gt; x + y<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">the second can be written more compactly(紧凑地) as:</span><br><span class="line"></span><br><span class="line">```        </span><br><span class="line">\x y -&gt; x + y</span><br><span class="line"></span><br><span class="line">(\x y -&gt; x + y) 7 8</span><br><span class="line">  = (\y -&gt; 7 + y) 8     ...x = 7 and x is replaced and removed from variables list</span><br><span class="line">  = 7 + 8</span><br><span class="line">  = 15</span><br></pre></td></tr></table></figure></p>
<p>more examples : bringing the result of a function to another function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(\x -&gt; x + 1) ((\y -&gt; y + 1) 2) </span><br><span class="line">  = (\x -&gt; x + 1) (2 + 1)</span><br><span class="line">  = (\x -&gt; x + 1) 3</span><br><span class="line">  = 3 + 1</span><br><span class="line">  = 4</span><br></pre></td></tr></table></figure>
<p>“higher-order” functions:</p>
<ul>
<li>takes one or more functions as arguments (i.e. procedural parameters),</li>
<li>returns a function as its result.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(\f x -&gt; f (f x)) (\y -&gt; y + 1)</span><br><span class="line">  = \x -&gt; (\y -&gt; y + 1)((\y -&gt; y + 1) x)</span><br><span class="line">  = \x -&gt; (\y -&gt; y + 1)(x + 1)</span><br><span class="line">  = \x -&gt; (x + 1) + 1</span><br><span class="line">  = \x -&gt; x + 2</span><br></pre></td></tr></table></figure>
<p><strong>Proof terms</strong><br>we can inline a function to get the proof term by using lambda calculus.<br>&nbsp;<br>example LEM :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE g where</span><br><span class="line">  g : ((P or (P -&gt; Falsity)) -&gt; Falsity) -&gt; Falsity</span><br><span class="line">  g z = z orIr x where</span><br><span class="line">    x : P -&gt; Falsity </span><br><span class="line">    x p = z orIl p</span><br></pre></td></tr></table></figure>
<p>inline clause x :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE g where</span><br><span class="line">  g : ((P or (P -&gt; Falsity)) -&gt; Falsity) -&gt; Falsity</span><br><span class="line">  g z = z (orIr (\p -&gt; (z orIl p)))</span><br></pre></td></tr></table></figure>
<p>inline clause g :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE (\z -&gt; (z orIr (\p -&gt; (z orIl p))))</span><br></pre></td></tr></table></figure>
<p><strong>Church encodings(编码)</strong><br>with the help of lambda calculus, we can encode a lot of mathematical expressions into lambda calculus.<br>&nbsp;<br>Encoding boolean :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true = \a b -&gt; a           ...it takes two variables and choose the first...</span><br><span class="line">false = \a b -&gt; b          ...it takes two variables and choose the second...</span><br><span class="line">and = \p q -&gt; p q p   </span><br><span class="line">or = \p q -&gt; p p q</span><br></pre></td></tr></table></figure>
<p>then, an example : true and false = false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">and true false </span><br><span class="line">  = (\p q -&gt; p q p) true false</span><br><span class="line">  = (\q -&gt; true q true) false</span><br><span class="line">  = true false true</span><br><span class="line"></span><br><span class="line">  = (\a b -&gt; a) false true     ...chooose the first variable...</span><br><span class="line">  = false</span><br></pre></td></tr></table></figure>
<p>Encoding negation :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not = \p a b -&gt; p b a</span><br></pre></td></tr></table></figure>
<p>test this : true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">not true</span><br><span class="line">  = (\p a b -&gt; p b a) true</span><br><span class="line">  = \a b -&gt; true b a</span><br><span class="line">  = \a b -&gt; (\a b -&gt; a) b a      ...choose the first variable...</span><br><span class="line">  = \a b -&gt; b</span><br><span class="line">  = false</span><br></pre></td></tr></table></figure>
<p>NOTE : compared to <code>and</code>, difference here is we check argument(true) first.<br>&nbsp;<br>Encoding integers : NOT COVERED.<br>&nbsp;<br>Encoding recursion : Y combinator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = \f -&gt; (\x -&gt; f(x x)) (\x -&gt; f(x x))</span><br></pre></td></tr></table></figure>
<p>where we have two identical functions. the second function substitutes each x in the first function then it produces the two new identical functions again. if we process this recursively we get f(f(f …)).<br>&nbsp;<br>For any function <code>g</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Y g = (\x -&gt; g(x x)) (\x -&gt; g(x x))</span><br><span class="line">  = g(((\x -&gt; g(x x)))((\x -&gt; g(x x))))</span><br><span class="line">  = g(Y g)</span><br><span class="line">  ...</span><br><span class="line">  = g (g (Y g))</span><br><span class="line">  ...</span><br><span class="line">  = g (g (g (Y g)))</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>rsc : <a href="https://www.youtube.com/watch?v=eis11j_iGMs" target="_blank" rel="noopener">https://www.youtube.com/watch?v=eis11j_iGMs</a></p>
<p><strong>Summary</strong><br>The Curry-Howard Correspondence between propositional logic and lambda calculus does not quite work because :</p>
<ul>
<li>DNE is left out as it can be introduced to compute LEM which solves the Halting Problem/ instead we introduce constructive logic)</li>
<li>some lambda terms are inconsistent : we have <code>A -&gt; Void</code> which in propositional logic means <code>A -&gt; Falsity</code></li>
</ul>
<h2 id="Type-checking"><a href="#Type-checking" class="headerlink" title="Type checking"></a>Type checking</h2><p>We will ONLY give rules for types within {Void, Unit, A -&gt; B, type variables}.</p>
<p>each type is determined by inference rules in the style of natural deduction sequents : <code>Γ ⊢ t : A</code><br>where :<br><code>Γ</code> is a list of elements of the form <code>x:A</code> where <code>x</code> is a variable and <code>A</code> is a type<br><code>t</code> is a lambda calculus term<br><code>A</code> is a type.</p>
<p><strong>rules:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A -&gt; B   Γ ⊢ u : A</span><br><span class="line">---------------------------[App]</span><br><span class="line">       Γ ⊢ t u : B</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    Γ, x:A ⊢ t : B</span><br><span class="line">----------------------[Abs]</span><br><span class="line"> Γ ⊢ \x -&gt; t : A -&gt; B</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">----------------[Axi]</span><br><span class="line"> Γ, x:A ⊢ x : A</span><br></pre></td></tr></table></figure>
<p>example: check <code>⊢ \x y z -&gt; y (x z) : (A -&gt; B) -&gt; (B -&gt; C) -&gt; (A -&gt; C)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                        ------------------------------[Axi] ----------------------------[Axi]</span><br><span class="line">                                                     Γ ⊢ x : A-&gt;B                Γ ⊢ Z : A</span><br><span class="line">----------------------------------[Axi] ----------------------------------------------------------------[App]</span><br><span class="line">    Γ ⊢ y : (B -&gt; C)                           Γ ⊢ x z : B</span><br><span class="line">----------------------------------------------------------------------[App]</span><br><span class="line">x:A-&gt;B, y:B-&gt;C, z:A ⊢ y (x z) : C</span><br><span class="line">-----------------------------------------------------[Abs x 3]</span><br><span class="line">⊢ \x y z -&gt; y (x z) : (A -&gt; B) -&gt; (B -&gt; C) -&gt; (A -&gt; C)</span><br></pre></td></tr></table></figure>
<h2 id="Type-inference-推理"><a href="#Type-inference-推理" class="headerlink" title="Type inference(推理)"></a>Type inference(推理)</h2><p><strong>Basic type inference</strong><br>Procedure :<br>1) Construct the type derivation tree for the term using variables instead of types.<br>2) Add constraints as follows: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A   Γ ⊢ u : B</span><br><span class="line">---------------------------[A = B -&gt; C]</span><br><span class="line">Γ ⊢ t u : C</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ, x:A ⊢ t : B</span><br><span class="line">----------------[C = A -&gt; B]</span><br><span class="line">Γ ⊢ \x -&gt; t : C</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------[B = A]</span><br><span class="line">Γ, x:A ⊢ x : B</span><br></pre></td></tr></table></figure>
<p>3) Apply unification algorithm :</p>
<ol>
<li>Change all equations <code>t = x</code> where <code>t</code> is not a variable and <code>x</code> is a variable to <code>x = t</code>.</li>
<li>Remove all equations <code>x = x</code> where <code>x</code> is a variable.</li>
<li>Select an equation <code>u = v</code> where neither is a variable and apply <em>type reduction</em>.<br>If type reduction is impossible, <em>fail</em>.</li>
<li>Select an equation <code>x = t</code> where <code>x</code>, where <code>t ≠ x</code>. If <code>x ∈ t</code> then <em>fail</em> else apply <em>variable elimination</em>. </li>
<li>Repeat until <em>solved</em>.  </li>
</ol>
<p>type reduction : any equation of the form <code>t1 -&gt; t2 = t1&#39; -&gt; t2</code> is broken into <code>t1 = t1&#39;, t2 = t2&#39;</code><br>type elimination : If <code>x = u</code> is an equation where <code>x</code> is a variable and <code>t</code> any type (could be just a variable) the substitution <code>x / u</code> is applied to all other equations.<br>&nbsp;<br>4) a set of equations is solved if :</p>
<ul>
<li>all equations have form x = t with x a variable</li>
<li>every variable on the left occurs only in that place</li>
</ul>
<p>Example : infer the type of <code>\x y z -&gt; y (x z)</code>. The derivation tree is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                             ------------------------------[J = B] ----------------------[K = F]</span><br><span class="line">                             x:B, y:D, z:F ⊢ x : J                 x:B, y:D, z:F ⊢ Z : K</span><br><span class="line">---------------------[H = D] ------------------------------------------------------------[J = K -&gt; I]</span><br><span class="line">x:B, y:D, z:F ⊢ y : H        x:B, y:D, z:F ⊢ x z : I</span><br><span class="line">-----------------------------------------------------[H = I -&gt; G]</span><br><span class="line">x:B, y:D, z:F ⊢ y (x z) : G</span><br><span class="line">----------------------------[E = F -&gt; G]</span><br><span class="line">x:B, y:D ⊢ \z -&gt; y (x z) : E</span><br><span class="line">-----------------------------[C = D -&gt; E]</span><br><span class="line">x:B ⊢ \y z -&gt; y (x z) : C</span><br><span class="line">--------------------------[A = B -&gt; C]</span><br><span class="line">⊢ \x y z -&gt; y (x z) : A</span><br></pre></td></tr></table></figure>
<p>We collect the following constraints:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = B -&gt; C</span><br><span class="line">C = D -&gt; E</span><br><span class="line">E = F -&gt; G</span><br><span class="line">H = I -&gt; G</span><br><span class="line">H = D</span><br><span class="line">J = K -&gt; I</span><br><span class="line">B = J</span><br><span class="line">F = K</span><br></pre></td></tr></table></figure>
<p>Applying the unification algorithm we get:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = (K -&gt; I) -&gt; (I -&gt; G) -&gt; K -&gt; G</span><br><span class="line">C = D -&gt; F -&gt; G</span><br><span class="line">E = F -&gt; G</span><br><span class="line">H = I -&gt; G</span><br><span class="line">D = I -&gt; G</span><br><span class="line">J = K -&gt; I</span><br><span class="line">B = K -&gt; I</span><br><span class="line">F = K</span><br></pre></td></tr></table></figure>
<p>checked: all equations have form <code>x = t</code> with <code>x</code> a variable<br>checked: every variable on the left occurs only in that place.</p>
<p><strong>Typing non-termination</strong><br>Just like DNE violates the Curry-Howard correspondence from the logical side, so do terms like <code>omega</code> and <code>Y</code> violate it from the functional side. The programming language Agda, which is based on the CH correspondence, bans such terms, which lead to errors. </p>
<p>Terms such as <code>Y</code> and <code>omega</code> are non-terminating because somewhere in them you will find sub-terms <code>\x -&gt; x x</code>. Such terms cannot type check:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----------[D = B] ------------[E = B]</span><br><span class="line">x:B ⊢ x : D        x:B ⊢ x : E</span><br><span class="line">-------------------------------[D = C -&gt; E]</span><br><span class="line">x:B ⊢ x x : C</span><br><span class="line">-----------------[A = B -&gt; C]</span><br><span class="line">⊢ (\x -&gt; x x) : A</span><br></pre></td></tr></table></figure>
<p>The constraints </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D = B</span><br><span class="line">E = B</span><br><span class="line">D = C -&gt; E</span><br><span class="line">A = B -&gt; C</span><br></pre></td></tr></table></figure>
<p>after the eliminination of <code>D</code> and <code>E</code> it becomes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = C -&gt; B</span><br><span class="line">A = B -&gt; C</span><br></pre></td></tr></table></figure>
<p>Which <em>fails</em> as variable <code>B</code> occurs on both sides of an equation.<br>The same failure of type inference occurs in attempting to type the <code>Y</code> combinator. </p>
<h2 id="Curry-Howord-correspondence-continued"><a href="#Curry-Howord-correspondence-continued" class="headerlink" title="Curry-Howord correspondence - continued"></a>Curry-Howord correspondence - continued</h2><p><strong>Isomorphisms</strong><br>Currying iso: <code>a^(b^(c)) = a^(b x c)</code> corresponds to <code>C -&gt; B -&gt; A ~ (Prod C B) -&gt; A</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cur : &#123;A B C : Set&#125; -&gt; ((Prod C B ) -&gt; A) -&gt; (C -&gt; B -&gt; A)</span><br><span class="line">cur f c b = f (pair c b)</span><br><span class="line"></span><br><span class="line">uncur : &#123;A B C : Set&#125; -&gt; (C -&gt; B -&gt; A) -&gt; ((Prod C B) -&gt; A)</span><br><span class="line">uncur f (pair c b) = f c b</span><br></pre></td></tr></table></figure>
<p><strong>Propositions as types</strong></p>
<ul>
<li>Product Elimination Left:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Prod A B</span><br><span class="line">----------------</span><br><span class="line">Γ ⊢ proj1 t : A</span><br></pre></td></tr></table></figure>
<ul>
<li>Product Elimination Right:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Prod A B</span><br><span class="line">-----------------</span><br><span class="line">Γ ⊢ proj2 t : B</span><br></pre></td></tr></table></figure>
<ul>
<li>Product Introduction:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A   Γ ⊢ u : B</span><br><span class="line">-----------------------</span><br><span class="line">Γ ⊢ andI t u : Prod A B</span><br></pre></td></tr></table></figure>
<ul>
<li>Sum Elimination:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Sum A B   Γ ⊢ u : A -&gt; C   Γ ⊢ v : B -&gt; C</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">Γ ⊢  orE t u v : Sum A B -&gt; (A -&gt; C) -&gt; (B -&gt; C) -&gt; C</span><br><span class="line"></span><br><span class="line"> pattern match (left a) = f a</span><br><span class="line">               (right b) = g b</span><br></pre></td></tr></table></figure>
<ul>
<li>Sum Introduction Left:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A</span><br><span class="line">---------------------</span><br><span class="line">Γ ⊢ orIl t : Sum A B</span><br></pre></td></tr></table></figure>
<ul>
<li>Sum Introduction Right:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : B</span><br><span class="line">--------------------</span><br><span class="line">Γ ⊢ orIr t : Sum A B</span><br></pre></td></tr></table></figure>
<ul>
<li>Ex Falso Quodlibet</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-------------------</span><br><span class="line">Γ ⊢ EFQ : Void -&gt; A</span><br></pre></td></tr></table></figure>
<h2 id="Inductive-types"><a href="#Inductive-types" class="headerlink" title="Inductive types"></a>Inductive types</h2><p>def : beyond finite types, we can define infinite types by using recursive definition.<br>&nbsp;<br><strong>Natural numbers</strong><br>According to peano’s theorem, we can define natural numbers :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Nat : Set where</span><br><span class="line">  zero : Nat</span><br><span class="line">  suc  : Nat -&gt; Nat</span><br></pre></td></tr></table></figure>
<p>Syntax :<br><code>data</code> is a keyword indicating a type definition<br><code>Nat</code> is the identifier we choose for the type<br><code>Set</code> is the built-in identifier for types<br><code>where</code> is introducing the definitions, which need to be indented<br><code>zero</code> is the name of one of the <strong>constructors</strong><br><code>suc</code> is a <strong>constructor</strong> that takes a <code>Nat</code> as an argument and produces another <code>Nat</code>.<br>&nbsp;<br>Basic functions : pattern matching on Nat’s<br>1) zero test :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is-zero : Nat -&gt; Boolean</span><br><span class="line">is-zero  zero = true</span><br><span class="line">is-zero  _    = false</span><br></pre></td></tr></table></figure>
<p>2) Doubling :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbl : Nat -&gt; Nat</span><br><span class="line">dbl zero = zero</span><br><span class="line">dbl (suc n) = suc (suc (dbl n))</span><br></pre></td></tr></table></figure>
<p>3) Addition :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">add zero n = n</span><br><span class="line">add (suc m) n = suc (add m n)</span><br></pre></td></tr></table></figure>
<p>4) Halving : (taking 1/2 as 0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half : Nat -&gt; Nat</span><br><span class="line">half zero = zero</span><br><span class="line">half (suc zero) =zero</span><br><span class="line">half (suc (suc n)) = suc (half n)</span><br></pre></td></tr></table></figure>
<p>Structural recursion: if arg is getting smaller, it is allowed to find the answer</p>
<p><strong>Lists</strong><br>List is a polymorphic type so we need to specify the elements in List is a type :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data : List (A : Set) : Set where</span><br><span class="line">  nil  : List A</span><br><span class="line">  cons : A -&gt; List A -&gt; List A</span><br></pre></td></tr></table></figure>
<p><code>nil</code>: empty list constructor<br><code>cons</code>: constructor that takes an element of <code>A</code> (called head) and a list (called tail).<br>&nbsp;<br>Also we can have a list of lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = cons 0 nil          ... [0]</span><br><span class="line">y = cons 1 x            ... [1, 0]</span><br><span class="line">z = cons x (cons y nil) ... [[1, 0], [0]]</span><br></pre></td></tr></table></figure>
<p>1) Empty-check:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">empty : &#123;A : Set&#125; -&gt; List A -&gt; Boolean</span><br><span class="line">empty nil = true</span><br><span class="line">empty _   = false</span><br></pre></td></tr></table></figure>
<p>2) length of a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len : &#123;A : Set&#125; -&gt; List A -&gt; Nat</span><br><span class="line">len nil         = zero</span><br><span class="line">len (cons _ xs) = suc (len xs)</span><br></pre></td></tr></table></figure>
<p>3) Appending two lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">append : &#123;A : Set&#125; -&gt; List A -&gt; List A -&gt; List A</span><br><span class="line">append nil ys = ys</span><br><span class="line">append (cons x xs) ys = cons x (append xs ys)</span><br></pre></td></tr></table></figure>
<p>4) Reversing a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rev : &#123;A : Set&#125; -&gt; List A -&gt; List A </span><br><span class="line">rev nil = nil</span><br><span class="line">rev (cons x xs) = append (rev xs) (cons x nil)</span><br></pre></td></tr></table></figure>
<p>5) filtering a list: return a list leaves out some elements</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons x xs) = if (is-zero x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-zeros xs</span><br><span class="line"></span><br><span class="line">if : &#123;A : Set&#125; -&gt; Boolean -&gt; A -&gt; A -&gt; A</span><br><span class="line">if true  x  _ = x</span><br><span class="line">if false _ y = y</span><br><span class="line"></span><br><span class="line">is-zero : Nat -&gt; Bool</span><br></pre></td></tr></table></figure>
<p>deep pattern-matching:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons zero xs) = filter-zeros xs</span><br><span class="line">filter-zeros (cons (suc n) xs) = cons (suc n) (filter-zeros xs)</span><br></pre></td></tr></table></figure>
<p>But suppose that we have a function <code>is-even : Nat -&gt; Boolean</code> to test for even-ness or <code>is-prime : Nat -&gt; Boolean</code> to test for primality. Filtering for some given property has very similar shape:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons x xs) = if (is-zero x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-zeros xs</span><br><span class="line"></span><br><span class="line">filter-evens : List Nat -&gt; List Nat</span><br><span class="line">filter-evens nil = nil</span><br><span class="line">filter-evens (cons x xs) = if (is-even x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-evens xs</span><br><span class="line"></span><br><span class="line">filter-primes : List Nat -&gt; List Nat</span><br><span class="line">filter-primes nil = nil</span><br><span class="line">filter-primes (cons x xs) = if (is-prime x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-primes xs</span><br></pre></td></tr></table></figure>
<p>This means that we can define a <em>generic</em> filter function for any property (predicate) expressed by a function <code>p : A -&gt; Boolean</code> where <code>A</code> is the type of list elements:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filter : &#123;A : Set&#125; -&gt; (A -&gt; Bool) -&gt; List A -&gt; List A</span><br><span class="line">filter p nil = nil</span><br><span class="line">filter p (cons x xs) = if (p x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter p xs</span><br></pre></td></tr></table></figure>
<h2 id="Fold-reduce"><a href="#Fold-reduce" class="headerlink" title="Fold(reduce)"></a>Fold(reduce)</h2><p>def: it is a function that abstracts the structural recursion pattern itself.</p>
<p>Fold-right:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foldr : &#123;A B : Set&#125; -&gt; (A -&gt; B -&gt; B) -&gt; B -&gt; List A -&gt; B</span><br><span class="line">foldr f y0 nil = y0 </span><br><span class="line">foldr f y0 (cons x xs) = f x y where</span><br><span class="line">  y = foldr f y0 xs</span><br></pre></td></tr></table></figure>
<p>Fold-left:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foldl : &#123;A B : Set&#125; -&gt; (B -&gt; A -&gt; B) -&gt; B -&gt; List A -&gt; B</span><br><span class="line">foldl f y0 nil         = y0</span><br><span class="line">foldl f y0 (cons x xs) = foldl f y0&apos; xs where</span><br><span class="line">  y0&apos; = f y0 x</span><br></pre></td></tr></table></figure>
<p>example : right recursion</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foldr sum 0 xs </span><br><span class="line">   = sum 0 (foldr sum 0 [1, 2, 3])</span><br><span class="line">   = sum 0 (sum 1 (foldr sum 0 [2, 3]))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (foldr sum 0 [3])))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (sum 3 (foldr sum 0 nil))))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (sum 3 0)))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 3))</span><br><span class="line">   = sum 0 (sum 1 5)</span><br><span class="line">   = sum 0 6</span><br><span class="line">   = 6</span><br></pre></td></tr></table></figure>
<p>example : left recursion</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foldl sum 0 xs</span><br><span class="line">  = foldl sum (sum 0 0) [1, 2, 3]</span><br><span class="line">  = foldl sum (sum (sum 0 0) 1) [2, 3]</span><br><span class="line">  = foldl sum (sum (sum (sum 0 0) 1) 2) [3]</span><br><span class="line">  = foldl sum (sum (sum (sum (sum 0 0) 1) 2) 3) nil </span><br><span class="line">  = sum (sum (sum (sum 0 0) 1) 2) 3</span><br><span class="line">  = sum (sum (sum 0 1) 2) 3</span><br><span class="line">  = sum (sum 1 2) 3</span><br><span class="line">  = sum 3 3</span><br><span class="line">  = 6</span><br></pre></td></tr></table></figure>
<p><strong>Map</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map : &#123;A B : Set&#125; -&gt; (A -&gt; B) -&gt; List A -&gt; List B</span><br><span class="line">map f nil = nil</span><br><span class="line">map f (cons x xs) = cons (f x) (map f xs)</span><br></pre></td></tr></table></figure>
<p>This function applies <code>f : A -&gt; B</code> to each element of <code>List A</code> to create a <code>List B</code>. </p>
<p>map-reduce</p>
<h2 id="More-on-types"><a href="#More-on-types" class="headerlink" title="More on types"></a>More on types</h2><p><strong>Dealing with errors</strong><br>errors</p>
<ol>
<li>agda : no errors allowed</li>
<li>Java : runtime exceptions</li>
<li>C : undefined behaviors</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Option (A : Set) : Set where</span><br><span class="line">  none : Option A</span><br><span class="line">  some : A -&gt; Option A</span><br></pre></td></tr></table></figure>
<ul>
<li><code>none</code> adds a special error value</li>
<li><code>some</code> injects <code>A</code> into the wrapper <code>Option</code></li>
</ul>
<p>return the head of a list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head : &#123;A : Set&#125; -&gt; List A-&gt; Option A</span><br><span class="line">head (cons x _) = some x</span><br><span class="line">head nil        = none</span><br></pre></td></tr></table></figure>
<p>return n.th element</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nth : &#123;A : Set&#125; -&gt; Nat -&gt; List A -&gt; Option A</span><br><span class="line">nth _ nil = none</span><br><span class="line">nth zero (cons x _) = some x</span><br><span class="line">nth (suc n) (cons _ xs) = nth n xs</span><br></pre></td></tr></table></figure>
<p>return the sum of 2nd and 3rd in a list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum23 : List Nat -&gt; Option Nat</span><br><span class="line">sum23 xs = add&apos; x2 x3 where</span><br><span class="line">  x2 = nth two xs</span><br><span class="line">  x3 = nth three xs</span><br><span class="line"></span><br><span class="line">add&apos; : Option Nat -&gt; Option Nat -&gt; Option Nat</span><br><span class="line">add&apos; (some m) (some n) = some (add m n)</span><br><span class="line">add&apos; _ _ = none</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lift2 : (Nat -&gt; Nat -&gt; Nat) -&gt; (Option Nat -&gt; Option Nat -&gt; Option Nat)</span><br><span class="line">lift2 f (some n) (some m) = some (f m n)</span><br><span class="line">lift2 f _ _ = none</span><br><span class="line"></span><br><span class="line">add&apos; = lift2 add</span><br></pre></td></tr></table></figure>
<p><strong>Trees</strong><br>Binary trees as data as leaves</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data BTreeL (A : Set) : Set where</span><br><span class="line">  leaf : A -&gt; BTreeL A</span><br><span class="line">  node : BTreeL A -&gt; BTreeL A -&gt; BTreeL A</span><br></pre></td></tr></table></figure>
<p><strong>S-expreesions</strong><br>def : used in serialisation of arbitrary data structures is the S-expression. It representes nested paranthetical expressions whose atomic values are (usually) strings.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Sexp (A : Set) : Set where</span><br><span class="line">  atom : A -&gt; Sexp A</span><br><span class="line">  list : List (Sexp A) -&gt; Sexp A</span><br></pre></td></tr></table></figure>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">open import Agda.Builtin.String</span><br><span class="line"></span><br><span class="line">a-this = atom &quot;this&quot;</span><br><span class="line">a-is   = atom &quot;is&quot;</span><br><span class="line">a-an   = atom &quot;an&quot;</span><br><span class="line">a-s    = atom &quot;s&quot;</span><br><span class="line">a-exp  = atom &quot;expression&quot;</span><br><span class="line"></span><br><span class="line">l-is-an = list (cons a-is (cons a-an nil))</span><br><span class="line">l-s-exp = list (cons a-s (cons a-exp nil))</span><br><span class="line">l-ex    = list (cons a-this (cons l-is-an (cons l-s-exp nil)))</span><br></pre></td></tr></table></figure>
<h2 id="Induction"><a href="#Induction" class="headerlink" title="Induction"></a>Induction</h2><p>induction proof :</p>
<ol>
<li>Basis of induction : if P(0) holds</li>
<li>Inductive step : hypothesize P(n), if P(n) -&gt; P(suc n) holds then</li>
<li>Conclusion : P(n) holds</li>
</ol>
<p><strong>induction on Nat</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ind-nat : (P : Nat -&gt; Set)</span><br><span class="line">        -&gt; P zero</span><br><span class="line">        -&gt; ((n : Nat) -&gt; P n -&gt; P (suc n))</span><br><span class="line">        -&gt; (n : Nat) -&gt; P n</span><br></pre></td></tr></table></figure>
<p>addition</p>
<ul>
<li>0 is a unit of addition</li>
<li>addition is commutative</li>
</ul>
<p>induction on list</p>
<ul>
<li><code>nil</code> is a unit of <code>append</code></li>
<li><code>append</code> is associative</li>
</ul>
<h2 id="Revisit"><a href="#Revisit" class="headerlink" title="Revisit"></a>Revisit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Add1 Nat -&gt; Nat -&gt; Nat</span><br><span class="line">Add1 zero n = n</span><br><span class="line">add1 (suc m) n = suc (add1 m n)</span><br><span class="line"></span><br><span class="line">add2 zero zero = zero</span><br><span class="line">add2 zero (suc n) = suc n</span><br><span class="line">add2 (suc n) zero = suc m</span><br><span class="line">add2 (suc m) (suc n) = suc (suc (add2 m n))</span><br></pre></td></tr></table></figure>
<p>for all m and n, add1 m n = add2 m n</p>
<p>P(m, n) : for all m , add1 m n = add2 m n</p>
<p>P(0,0) : add1 0 n = add2 0 n = n<br>Assume P(m,n),<br>P(0,suc n) :<br>P(suc m, 0) :</p>
<p>P(suc m, suc n) :</p>
<p>rev (rev xs) = xs : P(xs)</p>
<p>rev nil = nil<br>rev (cons x xs) = append (rev xs) (cons x nil)</p>
<p>P(nil) = rev (rev nil) = nil<br>Assume P(xs),<br>P(cons x xs) : rev (rev (cons x xs)) = cons x xs<br>               rev (append (rev xs) (cons x nil))<br>               append (rev (cons x nil)) (rev rev(xs))<br>               append (cons x nil) xs<br>               cons x xs</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/jwyhhh123">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-I"><span class="toc-number">1.</span> <span class="toc-text">Part I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Propositional-logic（命题逻辑）"><span class="toc-number">1.1.</span> <span class="toc-text">Propositional logic（命题逻辑）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Natural-Deduction"><span class="toc-number">1.2.</span> <span class="toc-text">Natural Deduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semantics-truth-table"><span class="toc-number">1.3.</span> <span class="toc-text">Semantics, truth table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-strategies-I"><span class="toc-number">1.4.</span> <span class="toc-text">Proof strategies I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equivalencies"><span class="toc-number">1.5.</span> <span class="toc-text">Equivalencies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Normal-form"><span class="toc-number">1.6.</span> <span class="toc-text">Normal form</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resolution-归结原理"><span class="toc-number">1.7.</span> <span class="toc-text">Resolution(归结原理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicate-calculus-一阶逻辑"><span class="toc-number">1.8.</span> <span class="toc-text">Predicate calculus(一阶逻辑)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-II"><span class="toc-number">2.</span> <span class="toc-text">Part II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming-part-Introduction"><span class="toc-number">2.1.</span> <span class="toc-text">:Programming part Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proof-Checking"><span class="toc-number">2.2.</span> <span class="toc-text">Proof Checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types"><span class="toc-number">2.3.</span> <span class="toc-text">Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-amp-pattern-matching（模式匹配）"><span class="toc-number">2.4.</span> <span class="toc-text">Functions &amp; pattern matching（模式匹配）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-checking"><span class="toc-number">2.5.</span> <span class="toc-text">Type checking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-inference-推理"><span class="toc-number">2.6.</span> <span class="toc-text">Type inference(推理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Curry-Howord-correspondence-continued"><span class="toc-number">2.7.</span> <span class="toc-text">Curry-Howord correspondence - continued</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inductive-types"><span class="toc-number">2.8.</span> <span class="toc-text">Inductive types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fold-reduce"><span class="toc-number">2.9.</span> <span class="toc-text">Fold(reduce)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#More-on-types"><span class="toc-number">2.10.</span> <span class="toc-text">More on types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Induction"><span class="toc-number">2.11.</span> <span class="toc-text">Induction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Revisit"><span class="toc-number">2.12.</span> <span class="toc-text">Revisit</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&text=Log.logic"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&is_video=false&description=Log.logic"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Log.logic&body=Check out this article: https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&title=Log.logic"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/19/Log-logic/&name=Log.logic&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Wenye Jin
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/jwyhhh123">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
