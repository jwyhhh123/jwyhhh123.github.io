<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Introduce to functional programming | WY J</title>
  <meta name="author" content="Wenye Jin">
  
  <meta name="description" content="Curry-Howard Correspondencedef : the correspondence between logic and types. This correspondence is, in a mathematical sense, an isomorphism.&amp;nbsp;Pro">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Introduce to functional programming">
  <meta property="og:site_name" content="WY J">

  
    <meta property="og:image" content>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>
</html>
 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">WY J</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Introduce to functional programming</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h2 id="Curry-Howard-Correspondence"><a href="#Curry-Howard-Correspondence" class="headerlink" title="Curry-Howard Correspondence"></a>Curry-Howard Correspondence</h2><p>def : the correspondence between logic and types. This correspondence is, in a mathematical sense, an isomorphism.<br>&nbsp;<br>Propositions correspond to types:<br>Falsity ~ Void<br>Truth   ~ Unit<br>A and B ~ Prod A B<br>A or B  ~ Sum A B</p>
<p>Postulates should be implementable as functions :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">andEl  : &#123;P Q : Prop&#125;   -&gt; P and Q -&gt; P</span><br><span class="line">andEr  : &#123;P Q : Prop&#125;   -&gt; P and Q -&gt; Q</span><br><span class="line">andI   : &#123;P Q : Prop&#125;   -&gt; P -&gt; Q -&gt; P and Q</span><br><span class="line">orE    : &#123;P Q R : Prop&#125; -&gt; P or Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R</span><br><span class="line">orIl   : &#123;P Q : Prop&#125;   -&gt; P -&gt; P or Q</span><br><span class="line">orIr   : &#123;P Q : Prop&#125;   -&gt; Q -&gt; Q or P</span><br><span class="line">EFQ    : &#123;P : Prop&#125;     -&gt; Falsity -&gt; P</span><br><span class="line">DNE    : &#123;P : Prop&#125;     -&gt; (not (not P)) -&gt; P</span><br></pre></td></tr></table></figure>
<p>Due to the isomorphism between types and propositions, we can implement postulates as functions with these types :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">andEl&apos; : &#123;P Q : Set&#125; -&gt; Prod P Q -&gt; P</span><br><span class="line">andEl&apos; (pair p _) = p</span><br><span class="line"></span><br><span class="line">andEr&apos; : &#123;P Q : Set&#125; -&gt; Prod P Q -&gt; Q</span><br><span class="line">andEr&apos; (pair _ q) = q</span><br><span class="line"></span><br><span class="line">andI&apos; : &#123;P Q : Set&#125; -&gt; P -&gt; Q -&gt; Prod P Q</span><br><span class="line">andI&apos; p q = pair p q</span><br><span class="line"></span><br><span class="line">orE&apos; : &#123;P Q R : Set&#125; -&gt; Sum P Q -&gt; (P -&gt; R) -&gt; (Q -&gt; R) -&gt; R</span><br><span class="line">orE&apos; (left p)  f g = f p</span><br><span class="line">orE&apos; (right q) f g = g q</span><br><span class="line"></span><br><span class="line">orIl&apos; : &#123;P Q : Set&#125; -&gt; P -&gt; Sum P Q</span><br><span class="line">orIl&apos; p = left p</span><br><span class="line"></span><br><span class="line">orIr&apos; : &#123;P Q : Set&#125; -&gt; Q -&gt; Sum P Q</span><br><span class="line">orIr&apos; q = right q</span><br><span class="line"></span><br><span class="line">EFQ&apos; : &#123;P : Set&#125; -&gt; Void -&gt; P</span><br><span class="line">EFQ&apos; ()</span><br></pre></td></tr></table></figure>
<p>We left Double negation elimination out as this cannot be implemented by Curry-Howard Correspondence :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DNE&apos; : &#123;P : Prop&#125; -&gt; ((P -&gt; Void) -&gt; Void) -&gt; P</span><br><span class="line">DNE&apos; x = ?</span><br></pre></td></tr></table></figure>
<p>If we could implement <code>DNE</code>, then we can derive an implementation of Law of Excluded Middle :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Set &#125; -&gt; Sum P (P -&gt; Void)</span><br><span class="line">LEM = DNE&apos; goal where</span><br><span class="line">  goal z = z (orIr v) where</span><br><span class="line">     v x = z (orIl x)</span><br></pre></td></tr></table></figure>
<p>The reason is as we think P as “termination checker” and P -&gt; Void as “non-termination checker” in a turing machine, the function LEM can compute the solution to the Halting problem.<br>&nbsp;<br>NOTE :  CH correspondence provides an idea to construct logic without DNE, LEM which is named as constructive logic. Constructive logic means the logic of computation.</p>
<p><strong>Proof relevance</strong><br>Constructive logic takes the concept of proof as essential. In contrast, classical logic (constructive logic + DNE) takes the concept of truth as essential. To guid your intuition it is best not to think of a constructive-logic proposition <code>A</code> as true but, if there is a <code>p</code> such that <code>p : A</code> you should think of it as <em>proved by <code>p</code></em>. </p>
<p>In constructive logic, this helps us distinguish between propositions (as types) more carefully. </p>
<p>We know that “true or true is equivalent to true”. This is the case clasically and constructively. We can prove that by constructing the function-proof-term of the corresponding types:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">suu-u : Sum Unit Unit -&gt; Unit</span><br><span class="line">suu-u (left empty) = empty</span><br><span class="line">suu-u (right empty) = empty </span><br><span class="line"></span><br><span class="line">u-suu : Unit -&gt; Sum Unit Unit</span><br><span class="line">u-suu empty = left empty</span><br></pre></td></tr></table></figure>
<p>However, these functions do not set up an isomorphism; <code>u-suu</code> is obviously not a bijection, since <code>Sum Unit Unit</code> has 2 elements and <code>Unit</code> only 1. Indeed, it is not the case that (using the algebraic notation) <code>1 + 1 ~ 1</code>.</p>
<p>This means that proofs matter. Proofs are relevant. <code>Unit</code> and <code>Sum Unit Unit</code> are both provable, but the former has essentially one proof(-term), and the latter two proof(-term)s. </p>
<p><strong>Summary</strong><br>In conclusion, there is an important correspondence between algebra, logic, types and sets</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Algebra     Logic     Types           Sets</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">  0           ⊥       Void             ∅</span><br><span class="line">  1           ⊤       Unit            &#123;∙&#125;</span><br><span class="line">a x b       A ∧ B     Prod       A×B=&#123;(a,b)∣a∈A,b∈B&#125;</span><br><span class="line">a + b       A ∨ B     Sum        A⊎B=&#123;(a,0),(b,1)∣a∈A,b∈B&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda-calculus-λ演算"><a href="#Lambda-calculus-λ演算" class="headerlink" title="Lambda calculus(λ演算)"></a>Lambda calculus(λ演算)</h2><p><strong>def:</strong> due to CH correspondence, proofs (of implication) correspond to functions. we use Lambda calculus to formalise the concept of computability by using a simple notion of functions.<br>&nbsp;<br>lambda calculus consists of :</p>
<ol>
<li>variables x, y …</li>
<li>function definition <code>\x -&gt; F</code></li>
<li>function application <code>f x</code></li>
</ol>
<p><code>x</code>: variable binding<br><code>F</code>: another lambda term formed by variables, function application, and function definition<br>&nbsp;<br>NOTE : </p>
<ul>
<li>functions in lambda calculus are called terms. </li>
<li>\x y z are variables in order. variables are substituted in order.</li>
</ul>
<p>examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\x -&gt; x + 1</span><br><span class="line">\x -&gt; \y -&gt; x + y</span><br></pre></td></tr></table></figure>
<p>the second can be written more compactly(紧凑地) as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\x y -&gt; x + y</span><br><span class="line"></span><br><span class="line">(\x y -&gt; x + y) 7 8</span><br><span class="line">  = (\y -&gt; 7 + y) 8     ...x = 7 and x is replaced and removed from variables list</span><br><span class="line">  = 7 + 8</span><br><span class="line">  = 15</span><br></pre></td></tr></table></figure>
<p>examples : bringing the result of a function to another function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(\x -&gt; x + 1) ((\y -&gt; y + 1) 2) </span><br><span class="line">  = (\x -&gt; x + 1) (2 + 1)</span><br><span class="line">  = (\x -&gt; x + 1) 3</span><br><span class="line">  = 3 + 1</span><br><span class="line">  = 4</span><br></pre></td></tr></table></figure>
<p>“higher-order” functions:</p>
<ul>
<li>takes one or more functions as arguments (i.e. procedural parameters),</li>
<li>returns a function as its result.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\f x -&gt; f (f x)) (\y -&gt; y + 1)</span><br><span class="line">  = \x -&gt; (\y -&gt; y + 1)((\y -&gt; y + 1) x)</span><br><span class="line">  = \x -&gt; (\y -&gt; y + 1)(x + 1)</span><br><span class="line">  = \x -&gt; (x + 1) + 1</span><br><span class="line">  = \x -&gt; x + 2</span><br></pre></td></tr></table></figure>
<p><strong>Proof terms</strong><br>We can inline a function to get the proof term by using lambda calculus.<br>&nbsp;<br>example LEM :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE g where</span><br><span class="line">  g : ((P or (P -&gt; Falsity)) -&gt; Falsity) -&gt; Falsity</span><br><span class="line">  g z = z orIr x where</span><br><span class="line">    x : P -&gt; Falsity </span><br><span class="line">    x p = z orIl p</span><br></pre></td></tr></table></figure>
<p>inline clause x : as we take a variable called p, we can define the function of x : \p -&gt; z (orIr p)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE g where</span><br><span class="line">  g : ((P or (P -&gt; Falsity)) -&gt; Falsity) -&gt; Falsity</span><br><span class="line">  g z = z (orIr (\p -&gt; (z orIl p)))</span><br></pre></td></tr></table></figure>
<p>inline clause g : similar</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEM : &#123;P : Prop&#125; -&gt; P or (P -&gt; Falsity)</span><br><span class="line">LEM &#123;P&#125; = DNE (\z -&gt; (z orIr (\p -&gt; (z orIl p))))</span><br></pre></td></tr></table></figure>
<p>We can write proof as lambda terms, for example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q1 : &#123;Q R S : Prop&#125; -&gt; R -&gt; (not Q -&gt; S) -&gt; (Q and R -&gt; not R) -&gt; S</span><br><span class="line">q1 r f g = f (\q -&gt; g ((andI q r) r))</span><br></pre></td></tr></table></figure>
<p><strong>Church encodings(编码)</strong><br>with the help of lambda calculus, we can encode a lot of mathematical expressions into lambda calculus.<br>&nbsp;<br>Encoding boolean :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true = \a b -&gt; a           ...it takes two variables and choose the first...</span><br><span class="line">false = \a b -&gt; b          ...it takes two variables and choose the second...</span><br><span class="line">and = \p q -&gt; p q p   </span><br><span class="line">or = \p q -&gt; p p q</span><br></pre></td></tr></table></figure>
<p>then, an example : true and false = false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and true false </span><br><span class="line">  = (\p q -&gt; p q p) true false</span><br><span class="line">  = (\q -&gt; true q true) false</span><br><span class="line">  = true false true</span><br><span class="line">  = (\a b -&gt; a) false true     ...chooose the first variable...</span><br><span class="line">  = false</span><br></pre></td></tr></table></figure>
<p>Encoding negation :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not = \p a b -&gt; p b a</span><br></pre></td></tr></table></figure>
<p>test this : true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">not true</span><br><span class="line">  = (\p a b -&gt; p b a) true</span><br><span class="line">  = \a b -&gt; true b a</span><br><span class="line">  = \a b -&gt; (\a b -&gt; a) b a      ...choose the first variable...</span><br><span class="line">  = \a b -&gt; b</span><br><span class="line">  = false</span><br></pre></td></tr></table></figure>
<p>NOTE : compared to <code>and</code>, difference here is we check argument(true) first.<br>&nbsp;<br>Encoding integers : NOT COVERED.<br>&nbsp;<br>Encoding recursion :<br>1) Omega</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Omega = (\x -&gt; x x) (\x -&gt; x x)</span><br></pre></td></tr></table></figure>
<p>2) Y combinator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = \f -&gt; (\x -&gt; f(x x)) (\x -&gt; f(x x))</span><br></pre></td></tr></table></figure>
<p>where we have two identical functions. the second function substitutes each x in the first function then it produces the two new identical functions again. if we process this recursively we get f(f(f …)).<br>&nbsp;<br>For any function <code>g</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Y g = (\x -&gt; g(x x)) (\x -&gt; g(x x))</span><br><span class="line">  = g(((\x -&gt; g(x x)))((\x -&gt; g(x x))))</span><br><span class="line">  = g(Y g)</span><br><span class="line">  ...</span><br><span class="line">  = g (g (Y g))</span><br><span class="line">  ...</span><br><span class="line">  = g (g (g (Y g)))</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>rsc : <a href="https://www.youtube.com/watch?v=eis11j_iGMs" target="_blank" rel="noopener">https://www.youtube.com/watch?v=eis11j_iGMs</a></p>
<p><strong>Summary</strong><br>The Curry-Howard Correspondence between propositional logic and lambda calculus does not quite work because :</p>
<ul>
<li>DNE is left out as it can be introduced to compute LEM which solves the Halting Problem/ instead we introduce constructive logic)</li>
<li>some lambda terms are inconsistent : we have <code>A -&gt; Void</code> which in propositional logic means <code>A -&gt; Falsity</code></li>
</ul>
<h2 id="Type-checking"><a href="#Type-checking" class="headerlink" title="Type checking"></a>Type checking</h2><p>We will ONLY give rules for types within {Void, Unit, A -&gt; B, type variables}.</p>
<p>each type is determined by inference rules in the style of natural deduction sequents : <code>Γ ⊢ t : A</code><br>where :<br><code>Γ</code> is a list of elements of the form <code>x:A</code> where <code>x</code> is a variable and <code>A</code> is a type<br><code>t</code> is a lambda calculus term<br><code>A</code> is a type.</p>
<p><strong>rules:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A -&gt; B   Γ ⊢ u : A</span><br><span class="line">---------------------------[App]</span><br><span class="line">       Γ ⊢ t u : B</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    Γ, x:A ⊢ t : B</span><br><span class="line">----------------------[Abs]</span><br><span class="line"> Γ ⊢ \x -&gt; t : A -&gt; B</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">----------------[Axi]</span><br><span class="line"> Γ, x:A ⊢ x : A</span><br></pre></td></tr></table></figure>
<p>example: check <code>⊢ \x y z -&gt; y (x z) : (A -&gt; B) -&gt; (B -&gt; C) -&gt; (A -&gt; C)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                        ------------------------------[Axi] ----------------------------[Axi]</span><br><span class="line">                                                     Γ ⊢ x : A-&gt;B                Γ ⊢ Z : A</span><br><span class="line">----------------------------------[Axi] ----------------------------------------------------------------[App]</span><br><span class="line">    Γ ⊢ y : (B -&gt; C)                           Γ ⊢ x z : B</span><br><span class="line">----------------------------------------------------------------------[App]</span><br><span class="line">x:A-&gt;B, y:B-&gt;C, z:A ⊢ y (x z) : C</span><br><span class="line">-----------------------------------------------------[Abs x 3]</span><br><span class="line">⊢ \x y z -&gt; y (x z) : (A -&gt; B) -&gt; (B -&gt; C) -&gt; (A -&gt; C)</span><br></pre></td></tr></table></figure>
<h2 id="Type-inference-推理"><a href="#Type-inference-推理" class="headerlink" title="Type inference(推理)"></a>Type inference(推理)</h2><p><strong>Basic type inference</strong><br>Procedure :<br>1) Construct the type derivation tree for the term using variables instead of types.<br>2) Add constraints as follows: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A   Γ ⊢ u : B</span><br><span class="line">---------------------------[A = B -&gt; C]</span><br><span class="line">Γ ⊢ t u : C</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ, x:A ⊢ t : B</span><br><span class="line">----------------[C = A -&gt; B]</span><br><span class="line">Γ ⊢ \x -&gt; t : C</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------[B = A]</span><br><span class="line">Γ, x:A ⊢ x : B</span><br></pre></td></tr></table></figure>
<p>3) Apply unification algorithm :</p>
<ol>
<li>Change all equations <code>t = x</code> where <code>t</code> is not a variable and <code>x</code> is a variable to <code>x = t</code>.</li>
<li>Remove all equations <code>x = x</code> where <code>x</code> is a variable.</li>
<li>Select an equation <code>u = v</code> where neither is a variable and apply <em>type reduction</em>.<br>If type reduction is impossible, <em>fail</em>.</li>
<li>Select an equation <code>x = t</code> where <code>x</code>, where <code>t ≠ x</code>. If <code>x ∈ t</code> then <em>fail</em> else apply <em>variable elimination</em>. </li>
<li>Repeat until <em>solved</em>.  </li>
</ol>
<p>type reduction : any equation of the form <code>t1 -&gt; t2 = t1&#39; -&gt; t2</code> is broken into <code>t1 = t1&#39;, t2 = t2&#39;</code><br>type elimination : If <code>x = u</code> is an equation where <code>x</code> is a variable and <code>t</code> any type (could be just a variable) the substitution <code>x / u</code> is applied to all other equations.<br>&nbsp;<br>4) a set of equations is solved if :</p>
<ul>
<li>all equations have form x = t with x a variable</li>
<li>every variable on the left occurs only in that place</li>
</ul>
<p>Example : Infer the type (if possible) of <code>\f x -&gt; x (f x)</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                               ———————————————————— [H = B]   ———————————————————— [I = D]</span><br><span class="line">                               f : B, x : D ⊢ f : H           f : B, x : D ⊢ x : I</span><br><span class="line">———————————————————— [F = D]   ——————————————————————————————————————————————————— [H = I → G]</span><br><span class="line">f : B, x : D ⊢ x : F           f : B, x : D ⊢ f x : G</span><br><span class="line">————————————————————————————————————————————————————— [F = G → E]</span><br><span class="line">f : B, x : D ⊢ x (f x) : E</span><br><span class="line">—————————————————————————— [C = D → E]</span><br><span class="line">f : B ⊢ \ x → x (f x) : C</span><br><span class="line">————————————————————————— [A = B → C]</span><br><span class="line">⊢ \ f x → x (f x) : A</span><br></pre></td></tr></table></figure>
<p>We collect the equations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → C</span><br><span class="line">C = D → E</span><br><span class="line">F = G → E</span><br><span class="line">F = D</span><br><span class="line">H = I → G</span><br><span class="line">H = B</span><br><span class="line">I = D</span><br></pre></td></tr></table></figure>
<p>Now apply the type inference algorithm.  We select the second line <code>C = D → E</code> and substitute it in the others, obtaining:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → (D → E)</span><br><span class="line">C = D → E</span><br><span class="line">F = G → E</span><br><span class="line">F = D</span><br><span class="line">H = I → G</span><br><span class="line">H = B</span><br><span class="line">I = D</span><br></pre></td></tr></table></figure>
<p>Now we select the third equation <code>F = G → E</code> and substitute it in the others, obtaining</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → (D → E)</span><br><span class="line">C = D → E</span><br><span class="line">F = G → E</span><br><span class="line">G → E = D</span><br><span class="line">H = I → G</span><br><span class="line">H = B</span><br><span class="line">I = D</span><br></pre></td></tr></table></figure>
<p>We flip the fourth equation, giving us:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → (D → E)</span><br><span class="line">C = D → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = I → G</span><br><span class="line">H = B</span><br><span class="line">I = D</span><br></pre></td></tr></table></figure>
<p>We select the fourth equation:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → ((G → E) → E)</span><br><span class="line">C = (G → E) → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = I → G</span><br><span class="line">H = B</span><br><span class="line">I = G → E</span><br></pre></td></tr></table></figure>
<p>The fifth:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → ((G → E) → E)</span><br><span class="line">C = (G → E) → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = I → G</span><br><span class="line">I → G = B</span><br><span class="line">I = G → E</span><br></pre></td></tr></table></figure>
<p>Flip the sixth:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = B → ((G → E) → E)</span><br><span class="line">C = (G → E) → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = I → G</span><br><span class="line">B = I → G</span><br><span class="line">I = G → E</span><br></pre></td></tr></table></figure>
<p>Substitute the sixth in all the others:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = (I → G) → ((G → E) → E)</span><br><span class="line">C = (G → E) → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = I → G</span><br><span class="line">B = I → G</span><br><span class="line">I = G → E</span><br></pre></td></tr></table></figure>
<p>The seventh:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = ((G → E) → G) → ((G → E) → E)</span><br><span class="line">C = (G → E) → E</span><br><span class="line">F = G → E</span><br><span class="line">D = G → E</span><br><span class="line">H = (G → E) → G</span><br><span class="line">B = (G → E) → G</span><br><span class="line">I = G → E</span><br></pre></td></tr></table></figure>
<p>from now all equations have been solved as :<br>checked: all equations have form <code>x = t</code> with <code>x</code> a variable<br>checked: every variable on the left occurs only in that place.</p>
<p><strong>Typing non-termination</strong><br>Just like DNE violates the Curry-Howard correspondence from the logical side, so do terms like <code>omega</code> and <code>Y</code> violate it from the functional side. The programming language Agda, which is based on the CH correspondence, bans such terms, which lead to errors. </p>
<p>Terms such as <code>Y</code> and <code>omega</code> are non-terminating because somewhere in them you will find sub-terms <code>\x -&gt; x x</code>. Such terms cannot type check:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----------[D = B] ------------[E = B]</span><br><span class="line">x:B ⊢ x : D        x:B ⊢ x : E</span><br><span class="line">-------------------------------[D = C -&gt; E]</span><br><span class="line">x:B ⊢ x x : C</span><br><span class="line">-----------------[A = B -&gt; C]</span><br><span class="line">⊢ (\x -&gt; x x) : A</span><br></pre></td></tr></table></figure>
<p>The constraints </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D = B</span><br><span class="line">E = B</span><br><span class="line">D = C -&gt; E</span><br><span class="line">A = B -&gt; C</span><br></pre></td></tr></table></figure>
<p>after the eliminination of <code>D</code> and <code>E</code> it becomes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = C -&gt; B</span><br><span class="line">A = B -&gt; C</span><br></pre></td></tr></table></figure>
<p>Which <em>fails</em> as variable <code>B</code> occurs on both sides of an equation.<br>The same failure of type inference occurs in attempting to type the <code>Y</code> combinator. </p>
<h2 id="CH-correspondence-cont’d"><a href="#CH-correspondence-cont’d" class="headerlink" title="CH correspondence - cont’d"></a>CH correspondence - cont’d</h2><p><strong>More complicate isomorphisms</strong><br>Currying iso: <code>a^(b^(c)) = a^(b x c)</code> corresponds to <code>C -&gt; B -&gt; A ~ (Prod C B) -&gt; A</code><br>&nbsp;<br>We have conversion function :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cur : &#123;A B C : Set&#125; -&gt; ((Prod C B) -&gt; A) -&gt; (C -&gt; B -&gt; A)</span><br><span class="line">cur f = \c b -&gt; f (pair c b)</span><br><span class="line"></span><br><span class="line">uncur : &#123;A B C : Set&#125; -&gt; (C -&gt; B -&gt; A) -&gt; ((Prod C B) -&gt; A)</span><br><span class="line">uncur f = \ &#123; (pair c b) -&gt; f c b &#125;</span><br></pre></td></tr></table></figure>
<p>Similarly, we can define the function explicitly :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cur : &#123;A B C : Set&#125; -&gt; ((Prod C B) -&gt; A) -&gt; C -&gt; B -&gt; A</span><br><span class="line">cur f c b = f (pair c b)</span><br><span class="line"></span><br><span class="line">uncur : &#123;A B C : Set&#125; -&gt; (C -&gt; B -&gt; A) -&gt; (Prod C B) -&gt; A</span><br><span class="line">uncur f (pair c b) = f c b</span><br></pre></td></tr></table></figure>
<p>Often we may use lambda calculus to help us check isomorphism :<br>example : <code>Prod (B -&gt; A) (C -&gt; A) ~ Sum B C -&gt; A</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">to : &#123;A B : Set&#125; -&gt; Prod (B -&gt; A) (C -&gt; A) -&gt; Sum B C -&gt; A</span><br><span class="line">to (pair f g) left b = f b</span><br><span class="line">to (pair f g) right c = f c</span><br><span class="line"></span><br><span class="line">from : &#123;A B : Set&#125; -&gt; (Sum B C -&gt; A) -&gt; Prod (B -&gt; A) (C -&gt; A)</span><br><span class="line">from fg = pair (\b -&gt; fg (left b) (\c -&gt; fg (right c))</span><br></pre></td></tr></table></figure>
<p>they are isomorphic as they are inverse to each other:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">to (from fg) (left b) = to (pair (\b -&gt; fg (left b)) (\c -&gt; fg (right c))) (left b)</span><br><span class="line">                      = (\b -&gt; fg (left b)) b</span><br><span class="line">                      = fg (left b)</span><br><span class="line"></span><br><span class="line">to (from fg) (right c) = to (pair (\b -&gt; fg (left b)) (\c -&gt; fg (right c))) (rigth c)</span><br><span class="line">                       = (\c -&gt; fg (right c)) c</span><br><span class="line">                       = fg (right c)</span><br><span class="line"></span><br><span class="line">from (to (pair f g)) = pair (\b -&gt; (to pair f g) (left b)) (\c -&gt; (to pair f g) (right c))</span><br><span class="line">                     = pair (\b -&gt; f b) (\c -&gt; g c)</span><br><span class="line">                     = pair f g</span><br></pre></td></tr></table></figure>
<p><strong>Propositions as types</strong><br>we can now extend the STLC with Product and Sum :<br>&nbsp;<br>Product Elimination Left:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Prod A B</span><br><span class="line">----------------</span><br><span class="line">Γ ⊢ proj1 t : A</span><br></pre></td></tr></table></figure>
<p>Product Elimination Right:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Prod A B</span><br><span class="line">-----------------</span><br><span class="line">Γ ⊢ proj2 t : B</span><br></pre></td></tr></table></figure>
<p>Product Introduction:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A   Γ ⊢ u : B</span><br><span class="line">-----------------------</span><br><span class="line">Γ ⊢ andI t u : Prod A B</span><br></pre></td></tr></table></figure>
<p>Sum Elimination:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : Sum A B   Γ ⊢ u : A -&gt; C   Γ ⊢ v : B -&gt; C</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">Γ ⊢  orE t u v : Sum A B -&gt; (A -&gt; C) -&gt; (B -&gt; C) -&gt; C</span><br><span class="line"></span><br><span class="line"> pattern match (left a) = f a</span><br><span class="line">               (right b) = g b</span><br></pre></td></tr></table></figure>
<p>Sum Introduction Left:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : A</span><br><span class="line">---------------------</span><br><span class="line">Γ ⊢ orIl t : Sum A B</span><br></pre></td></tr></table></figure>
<p>Sum Introduction Right:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Γ ⊢ t : B</span><br><span class="line">--------------------</span><br><span class="line">Γ ⊢ orIr t : Sum A B</span><br></pre></td></tr></table></figure>
<p>Ex Falso Quodlibet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-------------------</span><br><span class="line">Γ ⊢ EFQ : Void -&gt; A</span><br></pre></td></tr></table></figure>
<h2 id="Inductive-types"><a href="#Inductive-types" class="headerlink" title="Inductive types"></a>Inductive types</h2><p>def : beyond finite types, we can define infinite types by using recursive definition.<br>&nbsp;<br><strong>Natural numbers</strong><br>According to peano’s theorem, we can define natural numbers :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Nat : Set where</span><br><span class="line">  zero : Nat</span><br><span class="line">  suc  : Nat -&gt; Nat</span><br></pre></td></tr></table></figure>
<p>Syntax :<br><code>data</code> is a keyword indicating a type definition<br><code>Nat</code> is the identifier we choose for the type<br><code>Set</code> is the built-in identifier for types<br><code>where</code> is introducing the definitions, which need to be indented<br><code>zero</code> is the name of one of the <strong>constructors</strong><br><code>suc</code> is a <strong>constructor</strong> that takes a <code>Nat</code> as an argument and produces another <code>Nat</code>.<br>&nbsp;<br>Basic functions : pattern matching on Nat’s<br>1) zero test :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is-zero : Nat -&gt; Boolean</span><br><span class="line">is-zero  zero = true</span><br><span class="line">is-zero  _    = false</span><br></pre></td></tr></table></figure>
<p>2) Doubling :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbl : Nat -&gt; Nat</span><br><span class="line">dbl zero = zero</span><br><span class="line">dbl (suc n) = suc (suc (dbl n))</span><br></pre></td></tr></table></figure>
<p>3) Addition :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">add zero n = n</span><br><span class="line">add (suc m) n = suc (add m n)</span><br></pre></td></tr></table></figure>
<p>4) Minus : if m &lt; n then return zero</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">minus : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">minus (suc m) (suc n) = minus m n</span><br><span class="line">minus m _ = m</span><br></pre></td></tr></table></figure>
<p>5) Multiplication as addition i.e. 3 x 4 = 3 + 3 + 3 + 3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">multi m zero = m</span><br><span class="line">multi m (suc n) = add m (multi m n)</span><br></pre></td></tr></table></figure>
<p>6) Halving : (taking 1/2 as 0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half : Nat -&gt; Nat</span><br><span class="line">half zero = zero</span><br><span class="line">half (suc zero) =zero</span><br><span class="line">half (suc (suc n)) = suc (half n)</span><br></pre></td></tr></table></figure>
<p>Structural recursion: if arg is getting smaller, it is allowed to find the answer</p>
<p><strong>Lists</strong><br>List is a polymorphic type so we need to specify the elements in List is a type :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data : List (A : Set) : Set where</span><br><span class="line">  nil  : List A</span><br><span class="line">  cons : A -&gt; List A -&gt; List A</span><br></pre></td></tr></table></figure>
<p><code>nil</code>: empty list constructor<br><code>cons</code>: constructor that takes an element of <code>A</code> (called head) and a list (called tail).<br>&nbsp;<br>Also we can have a list of lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = cons 0 nil          ... [0]</span><br><span class="line">y = cons 1 x            ... [1, 0]</span><br><span class="line">z = cons x (cons y nil) ... [[1, 0], [0]]</span><br></pre></td></tr></table></figure>
<p>1) Empty-check:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">empty : &#123;A : Set&#125; -&gt; List A -&gt; Boolean</span><br><span class="line">empty nil = true</span><br><span class="line">empty _   = false</span><br></pre></td></tr></table></figure>
<p>2) length of a list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len : &#123;A : Set&#125; -&gt; List A -&gt; Nat</span><br><span class="line">len nil         = zero</span><br><span class="line">len (cons _ xs) = suc (len xs)</span><br></pre></td></tr></table></figure>
<p>3) Sum of elements in a List :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum : list Nat -&gt; Nat</span><br><span class="line">sum nil = zero</span><br><span class="line">sum (cons x xs) = add x (sum xs)</span><br><span class="line"></span><br><span class="line">add : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">add zero n = n</span><br><span class="line">add (suc m) n = suc (add m n)</span><br></pre></td></tr></table></figure>
<p>4) Appending two lists :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">append : &#123;A : Set&#125; -&gt; List A -&gt; List A -&gt; List A</span><br><span class="line">append nil ys = ys</span><br><span class="line">append (cons x xs) ys = cons x (append xs ys)</span><br></pre></td></tr></table></figure>
<p>5) Maximum element in a List :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">maxl : List Nat -&gt; Nat</span><br><span class="line">maxl nil = zero</span><br><span class="line">maxl (cons x xs) = max x (maxl xs)</span><br><span class="line"></span><br><span class="line">max : Nat -&gt; Nat -&gt; Nat</span><br><span class="line">max m zero = m</span><br><span class="line">max zero n = n</span><br><span class="line">max (suc m) (suc n) = suc (max m n)</span><br></pre></td></tr></table></figure>
<p>6) Reversing a list :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rev : &#123;A : Set&#125; -&gt; List A -&gt; List A </span><br><span class="line">rev nil = nil</span><br><span class="line">rev (cons x xs) = append (rev xs) (cons x nil)</span><br></pre></td></tr></table></figure>
<p>7) Filtering a list: return a list leaves out some elements<br>method 1 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons x xs) = if (is-zero x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-zeros xs</span><br><span class="line"></span><br><span class="line">if : &#123;A : Set&#125; -&gt; Boolean -&gt; A -&gt; A -&gt; A</span><br><span class="line">if true  x  _ = x</span><br><span class="line">if false _ y = y</span><br><span class="line"></span><br><span class="line">is-zero : Nat -&gt; Bool</span><br></pre></td></tr></table></figure>
<p>method 2 : deep pattern-matching :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons zero xs) = filter-zeros xs</span><br><span class="line">filter-zeros (cons (suc n) xs) = cons (suc n) (filter-zeros xs)</span><br></pre></td></tr></table></figure>
<p>suppose that we have a function <code>is-even : Nat -&gt; Boolean</code> to test for even-ness or <code>is-prime : Nat -&gt; Boolean</code> to test for primality. Filtering for some given property has very similar shape:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filter-zeros : List Nat -&gt; List Nat</span><br><span class="line">filter-zeros nil = nil</span><br><span class="line">filter-zeros (cons x xs) = if (is-zero x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-zeros xs</span><br><span class="line"></span><br><span class="line">filter-evens : List Nat -&gt; List Nat</span><br><span class="line">filter-evens nil = nil</span><br><span class="line">filter-evens (cons x xs) = if (is-even x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-evens xs</span><br><span class="line"></span><br><span class="line">filter-primes : List Nat -&gt; List Nat</span><br><span class="line">filter-primes nil = nil</span><br><span class="line">filter-primes (cons x xs) = if (is-prime x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter-primes xs</span><br></pre></td></tr></table></figure>
<p>This means that we can define a generic filter function for any property (predicate) expressed by a function <code>p : A -&gt; Boolean</code> where <code>A</code> is the type of list elements:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filter : &#123;A : Set&#125; -&gt; List A -&gt; List A</span><br><span class="line">filter nil = nil</span><br><span class="line">filter (cons x xs) = if (p x) xs&apos; (cons x xs&apos;) where</span><br><span class="line">  xs&apos; = filter xs</span><br><span class="line"></span><br><span class="line">if : &#123;A : Set&#125; -&gt; Boolean -&gt; A -&gt; A -&gt; A</span><br><span class="line">if true x _ = x</span><br><span class="line">if false _ y = y</span><br><span class="line"></span><br><span class="line">p : &#123;A : Set&#125; -&gt; A -&gt; Boolean</span><br></pre></td></tr></table></figure>
<p>8) Interleaving : merge two Lists</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intlv : &#123;A : Set&#125; -&gt; Prod (List A) (List A) -&gt; List A</span><br></pre></td></tr></table></figure>
<p>According to Currying isomorphism, we have </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intlv : &#123;A : Set&#125; -&gt; List A -&gt; List A -&gt; List A</span><br><span class="line">intlv xs nil = xs</span><br><span class="line">intlv nil ys = ys</span><br><span class="line">intlv (cons x xs) (cons y ys) = cons x (cons y (intlv xs ys))</span><br></pre></td></tr></table></figure>
<p>9) Zip : merge two Lists using List (Prod A B); If one of the lists is longer than the other the extra elements are ignored.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zip : &#123;A B : Set&#125; -&gt; List A -&gt; List B -&gt; List (Prod A B)</span><br><span class="line">zip (cons a as) (cons b bs) = cons (pair a b) (zip as bs)</span><br><span class="line">zip _ _ = nil</span><br></pre></td></tr></table></figure>
<h2 id="Fold-reduce"><a href="#Fold-reduce" class="headerlink" title="Fold(reduce)"></a>Fold(reduce)</h2><p>def: it is a recursive function that abstracts the structural recursion pattern itself. we take a function to compute elements in a list. for example add numbers from 0 to 10.</p>
<p>Fold-right:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foldr : &#123;A B : Set&#125; -&gt; (A -&gt; B -&gt; B) -&gt; B -&gt; List A -&gt; B</span><br><span class="line">foldr f y0 nil = y0 </span><br><span class="line">foldr f y0 (cons x xs) = f x y where</span><br><span class="line">  y = foldr f y0 xs</span><br></pre></td></tr></table></figure>
<p>Fold-left:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foldl : &#123;A B : Set&#125; -&gt; (B -&gt; A -&gt; B) -&gt; B -&gt; List A -&gt; B</span><br><span class="line">foldl f y0 nil         = y0</span><br><span class="line">foldl f y0 (cons x xs) = foldl f y0&apos; xs where</span><br><span class="line">  y0&apos; = f y0 x</span><br></pre></td></tr></table></figure>
<p><code>y0</code> a special value for the empty list<br>&nbsp;<br>example : right recursion</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foldr sum 0 xs </span><br><span class="line">   = sum 0 (foldr sum 0 [1, 2, 3])</span><br><span class="line">   = sum 0 (sum 1 (foldr sum 0 [2, 3]))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (foldr sum 0 [3])))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (sum 3 (foldr sum 0 nil))))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 (sum 3 0)))</span><br><span class="line">   = sum 0 (sum 1 (sum 2 3))</span><br><span class="line">   = sum 0 (sum 1 5)</span><br><span class="line">   = sum 0 6</span><br><span class="line">   = 6</span><br></pre></td></tr></table></figure>
<p>example : left recursion</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foldl sum 0 xs</span><br><span class="line">  = foldl sum (sum 0 0) [1, 2, 3]</span><br><span class="line">  = foldl sum (sum (sum 0 0) 1) [2, 3]</span><br><span class="line">  = foldl sum (sum (sum (sum 0 0) 1) 2) [3]</span><br><span class="line">  = foldl sum (sum (sum (sum (sum 0 0) 1) 2) 3) nil </span><br><span class="line">  = sum (sum (sum (sum 0 0) 1) 2) 3</span><br><span class="line">  = sum (sum (sum 0 1) 2) 3</span><br><span class="line">  = sum (sum 1 2) 3</span><br><span class="line">  = sum 3 3</span><br><span class="line">  = 6</span><br></pre></td></tr></table></figure>
<p><strong>Map</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map : &#123;A B : Set&#125; -&gt; (A -&gt; B) -&gt; List A -&gt; List B</span><br><span class="line">map f nil = nil</span><br><span class="line">map f (cons x xs) = cons (f x) (map f xs)</span><br></pre></td></tr></table></figure>
<p>This function applies <code>f : A -&gt; B</code> to each element of <code>List A</code> to create a <code>List B</code>. </p>
<p>map-reduce</p>
<h2 id="More-on-types"><a href="#More-on-types" class="headerlink" title="More on types"></a>More on types</h2><p><strong>Dealing with errors</strong><br>Sometimes when we iterate to the tail of a List, we may not simply assign it to zero, but we want it be an error value. In general when we want to assign a value to a specific element in a data type, we can define :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Option (A : Set) : Set where</span><br><span class="line">  none : Option A</span><br><span class="line">  some : A -&gt; Option A</span><br></pre></td></tr></table></figure>
<p><code>none</code> adds a special error value<br><code>some</code> injects <code>A</code> into the wrapper <code>Option</code></p>
<p>return the head of a list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head : &#123;A : Set&#125; -&gt; List A-&gt; Option A</span><br><span class="line">head (cons x _) = some x</span><br><span class="line">head nil        = none</span><br></pre></td></tr></table></figure>
<p>return nth element</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nth : &#123;A : Set&#125; -&gt; Nat -&gt; List A -&gt; Option A</span><br><span class="line">nth _ nil = none</span><br><span class="line">nth zero (cons x _) = some x</span><br><span class="line">nth (suc n) (cons _ xs) = nth n xs</span><br></pre></td></tr></table></figure>
<p>return the sum of 2nd and 3rd in a list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum23 : List Nat -&gt; Option Nat</span><br><span class="line">sum23 xs = add&apos; x2 x3 where</span><br><span class="line">  x2 = nth two xs</span><br><span class="line">  x3 = nth three xs</span><br><span class="line"></span><br><span class="line">add&apos; : Option Nat -&gt; Option Nat -&gt; Option Nat</span><br><span class="line">add&apos; (some m) (some n) = some (add m n)</span><br><span class="line">add&apos; _ _ = none</span><br></pre></td></tr></table></figure>
<p><strong>Trees</strong><br>Binary tree with data stored at leaves</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data BTreeL (A : Set) : Set where</span><br><span class="line">  leaf : A -&gt; BTreeL A</span><br><span class="line">  node : BTreeL A -&gt; BTreeL A -&gt; BTreeL A</span><br></pre></td></tr></table></figure>
<p>Representation :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   BTreeL</span><br><span class="line">   /    \</span><br><span class="line"> ls     rs</span><br><span class="line"> / \    / \</span><br><span class="line">l   r  l   r</span><br></pre></td></tr></table></figure>
<p><strong>S-expreesions</strong><br>def : S-expression is used in serialisation of arbitrary data structure. It representes nested paranthetical expressions whose atomic values are (usually) strings.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Sexp (A : Set) : Set where</span><br><span class="line">  atom : A -&gt; Sexp A</span><br><span class="line">  list : List (Sexp A) -&gt; Sexp A</span><br></pre></td></tr></table></figure>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">open import Agda.Builtin.String</span><br><span class="line"></span><br><span class="line">a-this = atom &quot;this&quot;</span><br><span class="line">a-is   = atom &quot;is&quot;</span><br><span class="line">a-an   = atom &quot;an&quot;</span><br><span class="line">a-s    = atom &quot;s&quot;</span><br><span class="line">a-exp  = atom &quot;expression&quot;</span><br><span class="line"></span><br><span class="line">l-is-an = list (cons a-is (cons a-an nil))</span><br><span class="line">l-s-exp = list (cons a-s (cons a-exp nil))</span><br><span class="line">l-ex    = list (cons a-this (cons l-is-an (cons l-s-exp nil)))</span><br></pre></td></tr></table></figure>
<h2 id="Induction"><a href="#Induction" class="headerlink" title="Induction"></a>Induction</h2><p>induction proof :</p>
<ol>
<li>Basis of induction : if P(0) holds</li>
<li>Inductive step : hypothesize P(n), if P(n) -&gt; P(suc n) holds then</li>
<li>Conclusion : P(n) holds</li>
</ol>
<p>NOTE : we will prove informally using induction above.</p>
<p><strong>Induction on Nat</strong><br>procedure : prove ∀ n ∈ Nat. P(n) holds</p>
<ol>
<li>Base case : P(zero)</li>
<li>Inductive case : Hypothesize P(n), prove P(suc n)</li>
</ol>
<p><strong>Induction on list</strong><br>Procedure : prove ∀ es ∈ List. P(es) holds</p>
<ol>
<li>Base case : P(nil)</li>
<li>Inductive case : Hypothesize P(xs), prove P(cons x xs)</li>
</ol>
<p><strong>Isomorphism by induction</strong><br>Furthermore, when we are trying to show isomorphism between something and a List, we need to prove from each direction by induction.<br>&nbsp;<br>Example : prove <code>Nat ~ List Unit</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">f : Nat → List Unit</span><br><span class="line">f zero = nil</span><br><span class="line">f (suc n) = cons empty (f n)</span><br><span class="line"></span><br><span class="line">g : List Unit → Nat</span><br><span class="line">g nil = zero</span><br><span class="line">g (cons e es) = suc (g es)</span><br><span class="line"></span><br><span class="line">-- Induction required!</span><br><span class="line"></span><br><span class="line">-- Prove: ∀ n ∈ Nat. g (f n) ≡ n</span><br><span class="line">-- Base case: Prove (g (f zero) ≡ zero)</span><br><span class="line">--                    g (f zero) ≡ zero</span><br><span class="line">--                    g nil ≡ zero            (by def. of f)</span><br><span class="line">--                    zero ≡ zero            (by def. of g)</span><br><span class="line">-- Inductive case: Hypothesise (g (f n) ≡ n) and prove (g (f (suc n)) ≡ suc n)</span><br><span class="line">--                           g (f (suc n)) ≡ suc n</span><br><span class="line">--                           g (cons empty (f n)) ≡ suc n   (by def. of f)</span><br><span class="line">--                           suc (g (f n)) ≡ suc n                (by def. of g)</span><br><span class="line">--                           suc n ≡ suc n                           (by inductive hypothesis)</span><br><span class="line"></span><br><span class="line">-- Prove: ∀ es ∈ List Unit. f (g es) ≡ es</span><br><span class="line">-- Base case: Prove (f (g nil) ≡ nil)</span><br><span class="line">--                    f (g nil) ≡ nil</span><br><span class="line">--                    f zero ≡ nil         (by def. of g)</span><br><span class="line">--                    nil ≡ nil              (by def. of f)</span><br><span class="line">-- Inductive case: Hypothesise (f (g es) ≡ es) and prove (f (g (cons empty es)) ≡ cons empty es)</span><br><span class="line">--                           f (g (cons unit es)) ≡ es</span><br><span class="line">--                           f (suc (g es)) ≡ cons empty es                (by def. of g)</span><br><span class="line">--                           cons empty (f (g es)) ≡ cons empty es  (by def. of f)</span><br><span class="line">--                           cons empty es ≡ cons empty es             (by inductive hypothesis)</span><br></pre></td></tr></table></figure>
<p>Example : prove <code>Nat ~ Option Nat</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">a : Nat → Option Nat</span><br><span class="line">a zero = None</span><br><span class="line">a (suc n) = Some n</span><br><span class="line"></span><br><span class="line">b : Option Nat → Nat</span><br><span class="line">b None = zero</span><br><span class="line">b (Some n) = suc n</span><br><span class="line"></span><br><span class="line">-- No induction required!</span><br><span class="line"></span><br><span class="line">-- Prove: ∀ n ∈ Nat. b (a n) ≡ n</span><br><span class="line">-- zero case: Prove (b (a zero) ≡ zero)</span><br><span class="line">--                 b (a zero) ≡ zero</span><br><span class="line">--                 b None ≡ zero       (by def. of a)</span><br><span class="line">--                 zero ≡ zero           (by def. of b)</span><br><span class="line">-- suc case: Prove (f (g (suc n)) ≡ suc n</span><br><span class="line">--                 b (a (suc n)) ≡ suc n</span><br><span class="line">--                 b (Some n) ≡ suc n   (by def. of a)</span><br><span class="line">--                 suc n ≡ suc n             (by def. of b)</span><br><span class="line"></span><br><span class="line">-- Prove: ∀ o ∈ Option Nat. a (b o) ≡ o</span><br><span class="line">-- None case: Prove (a (b None) ≡ None)</span><br><span class="line">--                    a (b None) ≡ None</span><br><span class="line">--                    a zero ≡ None            (by def. of b)</span><br><span class="line">--                    None ≡ None             (by def. of a)</span><br><span class="line">-- Some case: Prove ∀ n ∈ Nat. (a (b (Some n)) ≡ Some n)</span><br><span class="line">--                     a (b (Some n)) ≡ Some n</span><br><span class="line">--                     a (suc n) ≡ Some n           (by def. of b)</span><br><span class="line">--                     Some n ≡ Some n             (by def. of a)</span><br></pre></td></tr></table></figure>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2019/02/19/[Logic]02_predicateCalculus/" type="button" class="btn btn-default"><i class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a type="button" class="btn btn-default disabled">Next<i class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <h2 class="title">Comments</h2>

    
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = '//jwy.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div>
    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2019-02-19 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    </li><li><a href="/categories/Year1-Logic-and-Computation/">Year1/ Logic and Computation<span>4</span></a></li>
  

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->

<script type="text/javascript">
var disqus_shortname = 'jwy';
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2019 Wenye Jin
  
</p>
 </footer>
</div> <!-- container-narrow -->
  
  <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'ZP2ZSuHgipSZfRyU8uTR','2.0.0');
  </script>



  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
