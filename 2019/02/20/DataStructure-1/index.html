<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Basic Data StructureArraysAn ordered collection of items : a[i]i : the index of item. Loops and invariantsGeneral for-loop structure : 123for(INITIALIZATION; CONDITION; UPDATE) &amp;#123;    REPEATED PROC">
<meta property="og:type" content="article">
<meta property="og:title" content="Theory part">
<meta property="og:url" content="https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/index.html">
<meta property="og:site_name" content="WY J">
<meta property="og:description" content="Basic Data StructureArraysAn ordered collection of items : a[i]i : the index of item. Loops and invariantsGeneral for-loop structure : 123for(INITIALIZATION; CONDITION; UPDATE) &amp;#123;    REPEATED PROC">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-24T22:16:33.455Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Theory part">
<meta name="twitter:description" content="Basic Data StructureArraysAn ordered collection of items : a[i]i : the index of item. Loops and invariantsGeneral for-loop structure : 123for(INITIALIZATION; CONDITION; UPDATE) &amp;#123;    REPEATED PROC">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Theory part</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/02/20/DataStructure-2/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/02/19/[AI]12_lejos/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&text=Theory part"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&title=Theory part"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&is_video=false&description=Theory part"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Theory part&body=Check out this article: https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&title=Theory part"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&title=Theory part"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&title=Theory part"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&title=Theory part"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&name=Theory part&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Data-Structure"><span class="toc-number">1.</span> <span class="toc-text">Basic Data Structure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Efficiency-amp-amp-Complexity"><span class="toc-number">2.</span> <span class="toc-text">Efficiency &amp;&amp; Complexity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trees-general-binary-quad-trees"><span class="toc-number">3.</span> <span class="toc-text">Trees - general, binary, quad trees</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Search-Tree"><span class="toc-number">4.</span> <span class="toc-text">Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Heap-Trees-and-Priority-queues"><span class="toc-number">5.</span> <span class="toc-text">Binary Heap Trees and Priority queues</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorting-strategies-Sorting-algotithem-stability"><span class="toc-number">6.</span> <span class="toc-text">Sorting strategies, Sorting algotithem stability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash-Tables"><span class="toc-number">7.</span> <span class="toc-text">Hash Tables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Graphs"><span class="toc-number">8.</span> <span class="toc-text">Graphs</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#Code-Part"><span class="toc-number"></span> <span class="toc-text">Code Part:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GIT-testing-Set-up-eclipse"><span class="toc-number">1.</span> <span class="toc-text">GIT, testing, Set up eclipse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Assignments"><span class="toc-number">2.</span> <span class="toc-text">Assignments</span></a></li></ol>
    </li></div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Theory part
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">WY J</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-02-20T00:40:49.000Z" itemprop="datePublished">2019-02-20</time>
        
        (Updated: <time datetime="2019-07-24T22:16:33.455Z" itemprop="dateModified">2019-07-24</time>)
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Year1-Data-Structure/">Year1/ Data Structure</a>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="Basic-Data-Structure"><a href="#Basic-Data-Structure" class="headerlink" title="Basic Data Structure"></a>Basic Data Structure</h2><p><strong>Arrays</strong><br>An ordered collection of items : <code>a[i]</code><br><code>i</code> : the index of item.</p>
<p><strong>Loops and invariants</strong><br>General for-loop structure :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(INITIALIZATION; CONDITION; UPDATE) &#123;</span><br><span class="line">    REPEATED PROCESS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Invariant : a condition that does not change during the excution of a given program. i.e. i&lt;20 invariants enable correctness proof and verification. In particular, a loop-invariant is a condition that holds at the beginning and the end of every iteration.</p>
<p>example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mimimum(int n, float a[n]) &#123;</span><br><span class="line">    float min = a[0];</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i != n; i++) &#123;</span><br><span class="line">        if(a[i] &lt; min) min = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Initialization   : invariant is true at the beginning.</li>
<li>loop starting    : invariant preserved.</li>
<li>repeated process : invariant is true at the end.</li>
<li>loop ends        : end condition.</li>
</ol>
<p>NOTE : the example above is a kind of proof by induction.</p>
<p><strong>Lists</strong><br>2-cell Representation of a non-empty list :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt; [3][]-&gt; [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]</span><br></pre></td></tr></table></figure>
<p>Primitive operators<br>1) Constructors</p>
<ul>
<li>emptyList</li>
<li>makeList(element, List) : return a list</li>
</ul>
<p>2) Selectors</p>
<ul>
<li>first(list) : return an item</li>
<li>rest(list)  : return a list</li>
</ul>
<p>3) Condition</p>
<ul>
<li>isEmpty(list)</li>
</ul>
<p>4) mutators</p>
<ul>
<li>replaceFirst(x,list)</li>
<li>replaceRest(rest,list)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">replaceFirst(x, l) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(l)) <span class="keyword">return</span> <span class="string">"Error"</span>;</span><br><span class="line">    <span class="keyword">return</span> makeList(x,rest(l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">replaceRest(r, l) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(l)) <span class="keyword">return</span> <span class="string">"Error"</span>;</span><br><span class="line">    <span class="keyword">return</span> makeList(first(l),r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Recursion</strong><br>When items are stored as linked-list, it is unlike arrays which can use loops with indices to acess each item. we shall use recursion for data structures like lists.<br>&nbsp;<br>def : the idea is to formulate procedures which involve at least one step  that invokes the procedure itself.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">last(list) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(list)) <span class="keyword">return</span> <span class="string">"cannot access the last item"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(isEmpty(rest(list))) </span><br><span class="line">        <span class="keyword">return</span> first(list);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> last(rest(list));</span><br><span class="line">&#125;  <span class="comment">// this is also called : tail recursion where recursion happens at the end.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">append(list1, list2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(list1)) </span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> makeList(first(list1), append(rest(list1),list2));</span><br><span class="line">&#125;  <span class="comment">//time.Compx = length of list1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isMember(x, list) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(list)) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(first(list) == x)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(isEmpty(rest(list)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        isMember(x,rest(list));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Stacks</strong><br>def : data structure to model a First-In-Last-Out (FILO), or Last-In-First-Out (LIFO), strategy in search.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[3][]-&gt; [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]  </span><br><span class="line"></span><br><span class="line">top we got : [3]</span><br><span class="line">pop we got : [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]</span><br><span class="line">push(9, stack) we got : [9][]-&gt; [3][]-&gt; [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]</span><br></pre></td></tr></table></figure>
<p>Primitive operators<br>1) Constructors</p>
<ul>
<li>emptyStack</li>
<li>push(element, stack) : return a stack, push item at the top</li>
</ul>
<p>2) Selectors</p>
<ul>
<li>top(stack) : return the top most element of a stack.</li>
<li>pop(stack) : return the stack without the top most element.</li>
</ul>
<p>3) Condition</p>
<ul>
<li>isEmpty(Stack)</li>
</ul>
<p><strong>Queues</strong><br>def : data structure used to model a First-In-First-Out (FIFO) strategy. Conceptually, we add to the end of a queue and take away elements from its front.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[3][]-&gt; [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]  </span><br><span class="line">top we got : [3]</span><br><span class="line">pop we got : [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][/]</span><br><span class="line">push(9, queue) we got : [3][]-&gt; [1][] -&gt; [4][] -&gt; [2][] -&gt; [5][]-&gt; [9][/]</span><br></pre></td></tr></table></figure>
<p>Primitive operators<br>1) Constructors</p>
<ul>
<li>emptyQuene</li>
<li>push(element, queue) : return a queue, push the item at the tail</li>
</ul>
<p>2) Selectors</p>
<ul>
<li>top(queue) : return the top element of a queue.</li>
<li>pop(queue) : return the queue without the top most element.</li>
</ul>
<p>3) Condition</p>
<ul>
<li>isEmpty(queue)</li>
</ul>
<p>NOTE : as we can see, the only difference between a stack and a queue is the mothod of push.</p>
<p><strong>Doubly linked lists</strong><br>def : a doubly linked list is a list which has two pointers on each cell. Unlike a linked list, we think it as web pages which has each page containing previous page and next page.<br>&nbsp;<br>Primitive operators<br>1) Constructors</p>
<ul>
<li>emptyList</li>
<li>MakeListLeft(element, list) : return a new DLL containing the new element on the left</li>
<li>MakeListRight(element, list) : return a new DLL containing the new element on the right</li>
</ul>
<p>2) Selectors</p>
<ul>
<li>firstLeft(list)</li>
<li>restLeft(list)</li>
<li>firstRight(list)</li>
<li>restRight(list)</li>
</ul>
<p>3) Condition</p>
<ul>
<li>isEmpty(list)</li>
</ul>
<p>Circular doubly linked list : it is a DLL which connects the left-most element to the right-most elements with two pointers.</p>
<h2 id="Efficiency-amp-amp-Complexity"><a href="#Efficiency-amp-amp-Complexity" class="headerlink" title="Efficiency &amp;&amp; Complexity"></a>Efficiency &amp;&amp; Complexity</h2><p><strong>Time and Space complexity</strong><br>time complexity : how much the excution time is required, depending on the size of the data stucture.<br>space complexity : how much the memory space is required, depending on the size of the data structure<br>&nbsp;<br>NOTES:</p>
<ul>
<li>In general, we consider complexity of the psuedocodes or algorithms.</li>
<li>we need to make a balance between time complexity and space complexity.</li>
</ul>
<p><strong>Worst and Average case</strong><br>Average case is more important when saving time overall needs to be guaranteed.<br>Worst case is more important when we are dealing with time-critical problems such as airplane application.<br>&nbsp;<br>NOTE : the most efficient algorithm on average might have a particulaly bad worst case efficiency.</p>
<p><strong>Big-Oh notation</strong><br>def : we ONLY complexity ignoring any constant factors and small arguments. This wll just tell us the principal growth of the complexity function with problem size.<br>&nbsp;<br>Usually, we compute the complexity based on the number of loops and how often the content of those loops are being executed.<br>&nbsp;<br>The most common complexity classes :</p>
<ul>
<li>constant complexity    : O(1)</li>
<li>logarithmic complexity : O(log2(n))</li>
<li>linear complexity      : O(n)</li>
<li>quadratic complexity   : O(n^2)</li>
<li>cubic complexity       : O(n^3)</li>
<li>exponential complexity : O(2^n)</li>
</ul>
<p>It is easier to see the growth of each class of complexity by doubling the size :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f(n)            | If the size of the problem doubles then f(n) will be </span><br><span class="line">----------------|-----------------------------------------------------------</span><br><span class="line">  1             |  the same,                                 f(2n) = f(n)</span><br><span class="line">log2(log2(n))   |  almost the same,                          log2(log2(2n)) = log2 (log2 (n) + 1)</span><br><span class="line">log2(n)         |  more by 1=log2(2),                        f(2n) = f(n)+1</span><br><span class="line">  n             |  twice as big as before,                   f(2n) = 2 * f(n)</span><br><span class="line">nlog2n          |  a bit more than twice as big as before,   2nlog2 (2n) = 2(nlog2 n) + 2n</span><br><span class="line"> n^2            |  four times as big as before,              f(2n) = 4 * f(n)</span><br><span class="line"> n^3            |  eight times as big as before,             f(2n) = 8 * f(n)</span><br><span class="line"> 2^n            |  the square of what it was before,         f(2n) = (f(n))^2</span><br></pre></td></tr></table></figure>
<p>NOTE : computation - exact and approximate</p>
<h2 id="Trees-general-binary-quad-trees"><a href="#Trees-general-binary-quad-trees" class="headerlink" title="Trees - general, binary, quad trees"></a>Trees - general, binary, quad trees</h2><p><strong>General definition of trees</strong><br>def : a tree contains nodes and edges. Nodes are usually labelled by a search keys(int, String…).<br>&nbsp;<br>Terminology: </p>
<ol>
<li>root</li>
<li>parent (ancestor)</li>
<li>children (descendent)</li>
<li>siblings</li>
<li>leaves</li>
<li>path</li>
<li>height of the tree</li>
<li>size of the tree</li>
</ol>
<p>Representation: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    [8]   ......... root (parent of 3 and 11)   - level 0</span><br><span class="line">  /     \</span><br><span class="line">[3]     [11]  ..... children (of 8)             - level 1</span><br><span class="line">   \    /   \</span><br><span class="line">  [6] [9]  [14] ... leaves                      - level 2</span><br><span class="line">        </span><br><span class="line">height = 2</span><br><span class="line">size = 6</span><br></pre></td></tr></table></figure>
<p><strong>Quad-trees</strong><br>def: a quadtree is a tree in which each-leaf is labelled by a value and each non-leaf node has exactly four children.<br>&nbsp;<br>inductive definition :</p>
<ol>
<li>a root node with a value, or</li>
<li>a root node without a value but with four quad tree children : lu,ll,ru,rl</li>
</ol>
<p>NOTE: here we use “root node” because every sub-tree is itself a quadtree<br>&NBSP;<br>Presentation: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> __________________________</span><br><span class="line">|            |             |</span><br><span class="line">|            |             |</span><br><span class="line">|     0      |     10      |</span><br><span class="line">|            |             |</span><br><span class="line">|            |             |</span><br><span class="line">|------------|-------------|</span><br><span class="line">|     | 1| 3 |             |</span><br><span class="line">| 30  |--|---|             |</span><br><span class="line">|-----|------|     12      |</span><br><span class="line">| 40  |  2   |             |</span><br><span class="line">|_____|______|_____________|</span><br></pre></td></tr></table></figure>
<p>Primitive operations:<br>1) Constructors</p>
<ul>
<li>baseQT(value): return a single node with label value</li>
<li>makeQT(luqt,ruqt,llqt,rlqt): return a quadtree with four nodes</li>
</ul>
<p>2) Selectors</p>
<ul>
<li>lu(qt): return the left-upper quadtree</li>
<li>ll(qt): return the left-lower quadtree</li>
<li>ru(qt): return the right-upper quadtree</li>
<li>rl(qt): return the right-lower quadtree</li>
</ul>
<p>3) Condition</p>
<ul>
<li>isValue(qt): return true if quadtree qt is a single node</li>
</ul>
<p>Rotate a quadtree by 180 degrees: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rotate(qt)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isValue(qt))</span><br><span class="line">        <span class="keyword">return</span> qt;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> makeQT(rotate(rl(qt)), rotate(ll(qt)),</span><br><span class="line">                      rotate(ru(qt)), rotate(lu(qt)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NOTE: similar idea arises from averaging the values of qt.</p>
<p><strong>Binary trees</strong><br>def: a binary tree is a tree in which each node has at most two children.<br>&nbsp;<br>inductive def:</p>
<ol>
<li>the empty tree EmptyTree, or</li>
<li>it consists of a node and two binary trees(left subtree and right subtree)</li>
</ol>
<p>Primitive operations:<br>1) Constructors</p>
<ul>
<li>EmptyTree: return an empty tree</li>
<li>makeTree(v,l,r) : return a binary tree with a root node and two sub-trees</li>
</ul>
<p>2) derived Constructor</p>
<ul>
<li>Leaf(v) = MakeTree(v,EmptyTree,EmptyTree)</li>
</ul>
<p>3) Selectors</p>
<ul>
<li>root(t): return the value of the root node of t</li>
<li>left(t): return the left sub-tree</li>
<li>right(t): return the right sub-tree</li>
</ul>
<p>4) Condition</p>
<ul>
<li>isEmpty(t): return true if the binary tree t is the EmptyTree</li>
</ul>
<p>NOTE: This primitive operators are what expected to be covered when we created a tree class.<br>&nbsp;<br>Abstract data types : without focusing on the details of the data or the implementation, it is a general principle of how to construct and destruct the data type.</p>
<p><strong>Height of a binary tree</strong><br>Many tree-based applications, for example searching, take as many steps as the height of the tree, so minimizing the height minimizes the time needed to perform those operations.<br>&nbsp;<br>size   : s(h) = 2^(h+1) - 1<br>height : h(s) = log2(s+1) - 1 = log2(s)<br>&nbsp;<br>NOTE : height is computed as log2(n) when the tree is balanced.</p>
<p><strong>Size of a binary tree</strong><br>size of a tree :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size(t)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(t))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> + size(left(t)) + size(right(t)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h2><p>one possible implementation of a binary tree is binary search tree, which provide an efficient way of sorting data that allows particular items to be found as quickly as possible.<br>&nbsp;<br>def : BST is a binary tree that is either an emptyTree or satisfies the following :</p>
<ol>
<li>all search keys occuring in the left subtree are smaller than that of the root</li>
<li>all search keys occuring in the right subtree are larger than that of the root</li>
<li>the left and right subtrees are themselves binary search trees(1 and 2 still hold)</li>
</ol>
<p>NOTE : As to a BST, it does not matter what the root node is, we simply want to determine, if given a key, where the key is located on the tree.</p>
<p><strong>Building binary search trees</strong><br>one naturally starts with the root and then adds further new nodes as needed. we have two cases :</p>
<ul>
<li>if the given tree is empty then simply assigin the new value v to the root, and leave the left and right subtrees empty</li>
<li>if the given tree is nonempty, then a node is inserted to :<ol>
<li>the left subtree if it is smaller than the root</li>
<li>the right subtree if it is larger than the root</li>
<li>nowhere but we throw exception</li>
</ol>
</li>
</ul>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">insert(v, bst)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(bst))</span><br><span class="line">        <span class="keyword">return</span> MakeTree(v,emptyTree,emptyTree);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v &lt; root(bst))</span><br><span class="line">        <span class="keyword">return</span> MakeTree(v,insert(v,left(bst)),right(bst));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v &gt; root(bst))</span><br><span class="line">        <span class="keyword">return</span> MakeTree(v,left(bst),insert(v,right(bst)));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"violated assumption in procedure insert(v equals :)"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NOTE : this algorithm made a new tree based on bst. the original tree bst is not modified, it is merely inspected(被巡视). When we are dealing with a large database, it is more efficient to modify the given tree, rather than to construct a whole new tree.</p>
<p><strong>Searching a BST</strong><br>Algorithm in pseudocode :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">search(n, bst)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(bst))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; root(bst))</span><br><span class="line">        <span class="keyword">return</span> search(n,left(bst));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; root(bst))</span><br><span class="line">        <span class="keyword">return</span> search(n,right(bst));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>or we can use a while-loop :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">search(n,bst)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(bst) &amp;&amp; n != root(bst))&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; root(bst))</span><br><span class="line">            t = left(bst);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; root(bst))</span><br><span class="line">            t = right(bst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !isEmpty(bst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Time complexity of searching and inserting</strong><br>Searching :</p>
<ul>
<li>average case = O(log2(n))</li>
<li>worst case = O(n)</li>
</ul>
<p>Inserting :</p>
<ul>
<li>average case = O(log2(n))</li>
<li>worst case = O(n)</li>
</ul>
<p>NOTE : if BST is perfectly balanced, the worst cases are both O(log2(n))</p>
<p><strong>Deleting</strong><br>in order to perform better than O(n x log2(n)) or better than O(n), we design the following procedures :</p>
<ol>
<li>if the node in question is a leaf, just remove it</li>
<li>if only one of the node’s subtree is non-empty, move up the remaining subtree</li>
<li>if the node has two non-empty sub-trees, find the left-most leaf on the right subtree(this has the smallest key in the right sub-tree). Use this to overwrite the node we deleted. replace the left-most node by its right subtree, if this exists; otherwise just delete it.</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">delete(value v, tree t)&#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(t))</span><br><span class="line">    error(<span class="string">"error : given item is not in the given tree"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(v &lt; root(t))</span><br><span class="line">      <span class="keyword">return</span> MakeTree(root(t),delete(v,left(t)),right(t));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v &gt; root(t))</span><br><span class="line">      <span class="keyword">return</span> MakeTree(root(t),left(t),delete(v,right(t)));</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// v is the root(t)</span></span><br><span class="line">      <span class="keyword">if</span>(isEmpty(left(t)))</span><br><span class="line">        <span class="keyword">return</span> right(t);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(isEmpty(right(t)))</span><br><span class="line">        <span class="keyword">return</span> left(t);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> MakeTree(smallestNode(right(t))),left(t),removeSmallestNode(right(t));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smallestNode(tree t)&#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(left(t)))</span><br><span class="line">    <span class="keyword">return</span> root(t);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> smallestNode(left(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">removeSmallestNode(tree t)&#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(left(t)))</span><br><span class="line">    <span class="keyword">return</span> right(t);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> MakeTree(root(t),removeSmallestNode(left(t)), right(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Complexity : O(log2(n))</p>
<p><strong>Sorting using binary search tree</strong></p>
<p>print the nodes in order :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printInOrder(tree t)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(t))&#123;</span><br><span class="line">    printInOrder(left(t));</span><br><span class="line">    print(root(t));</span><br><span class="line">    printInOrder(right(t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if there is a collection of items stored in an array with size n, they can be printed in sorted order :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sort(T[] a)&#123;</span><br><span class="line">  t = emptyTree;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">    t = insert(a[i],t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printInOrder(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Balancing BST</strong><br>Reason : more balance the tree is, less time taken to search/insert/delete the tree<br>Tree balance : for each level, the tree is completely filled with as many nodes as possible.<br>Tree rotation : to rebalance the tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     [D]               [B]</span><br><span class="line">    /   \    ----&gt;    /   \</span><br><span class="line">  [B]   [E]  &lt;----  [A]   [D]</span><br><span class="line">  / \                     / \</span><br><span class="line">[A] [C]                 [C] [E]</span><br></pre></td></tr></table></figure>
<p><strong>Exercises</strong><br>Ex1. Qns 6.  (To build all possible trees among {1,2,3,4}<br>Ex2 ,Qns 3 &amp; 4, check whether is a BST or tree</p>
<h2 id="Binary-Heap-Trees-and-Priority-queues"><a href="#Binary-Heap-Trees-and-Priority-queues" class="headerlink" title="Binary Heap Trees and Priority queues"></a>Binary Heap Trees and Priority queues</h2><p>Completeness : A binary tree is complete if every level, except possibly the last, is completely filled, and all the leaves on the last level are placed as far to the left as possible.<br>&nbsp;<br>dif : unlike BST, a binary heap tree is a binary tree with each node labelled by a priority number(the higher number is labelled, the higher priority the node is). So, the root is the biggest number and it holds for left and right heap subtrees. The left and right subtrees are interchangable in binary heap trees.<br>&nbsp;<br>def : a binary heap tree is a complete binary tree which is either empty or satisfies the following :</p>
<ol>
<li>the priority of the root is higher than or equal to that of its children</li>
<li>the left and right subtrees of the root are heap trees themselves</li>
</ol>
<p><strong>Basic operations</strong><br>to construct a heap tree we need :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MAX = <span class="number">100</span>      <span class="comment">// Maximum number of nodes allowed</span></span><br><span class="line"><span class="keyword">int</span> heap[MAX + <span class="number">1</span>]  <span class="comment">// Store priority values of nodes + empty of heap tree;  </span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>          <span class="comment">// Largest position that has been filled so far</span></span><br></pre></td></tr></table></figure>
<p>for heap trees to be a useful representation of priority queues, we need</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">insert(<span class="keyword">int</span> p, array heap, <span class="keyword">int</span> n)</span><br><span class="line">delete(<span class="keyword">int</span> i, array heap, <span class="keyword">int</span> n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(array heap, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heapEmpty(heap,n))</span><br><span class="line">      error(<span class="string">"heap is empty"</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> heap[<span class="number">1</span>];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">heapEmpty</span><span class="params">(array heap, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span>;  <span class="comment">// we use n = 0 to represent an empty heap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastLeaf</span><span class="params">(array heap, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heapEmpty(heap,n))</span><br><span class="line">      <span class="keyword">return</span> error(<span class="string">"heap is empty"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> heap[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Inserting a new heap tree node</strong><br>Procedure :</p>
<ol>
<li>insert the new node into the last position n+1</li>
<li>bubble up the node to the right position by comparing priority with parent node</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">insert(<span class="keyword">int</span> p, array heap, <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == MAX)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"error: heap is full"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      heap[++n] = p;           <span class="comment">// O(1)</span></span><br><span class="line">      bubbleUp(n, heap, n);    <span class="comment">// O(log2(n))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bubbleUp(<span class="keyword">int</span> i, array p, <span class="keyword">int</span> n)&#123;</span><br><span class="line">  <span class="keyword">if</span>(isRoot(i)) <span class="comment">// i has the highest priority</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(heap[i] &gt; heap[parent(i)])&#123;</span><br><span class="line">    swap heap[i] and heap[parent(i)]</span><br><span class="line">    bubbleUp(parent(i),heap,n); </span><br><span class="line">    <span class="comment">// the parent of parent of i is now being the parent of i</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worst case &amp; average case of time Complexity = O(log2(n))</p>
<p><strong>Deleting a heap tree node</strong><br>Procedure :</p>
<ol>
<li>replace the node we want to delete by the last node</li>
<li>bubble up or bubble down the node to achive the correct priority order</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="keyword">int</span> i, array p, <span class="keyword">int</span> n)&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; i)</span><br><span class="line">    error(<span class="string">"empty tree, unable to delete"</span>);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    heap[i] = heap[n];</span><br><span class="line">    bubbleUp(i,heap,n-<span class="number">1</span>);</span><br><span class="line">    bubbleDown(i,heap,n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bubbleDown(<span class="keyword">int</span> i, array heap, <span class="keyword">int</span> n)&#123;</span><br><span class="line">  <span class="keyword">if</span>(left(i) &gt; n)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(right &gt; n)  <span class="comment">// left(i) &lt;= n; only one children</span></span><br><span class="line">    <span class="keyword">if</span>(heap[i] &lt; heap[left(i)])</span><br><span class="line">      swap heap[i] and heap[left(i)];</span><br><span class="line">  <span class="keyword">else</span>                <span class="comment">// two children</span></span><br><span class="line">    <span class="keyword">if</span>(heap[left(i)] &gt; heap[right(i)] &amp;&amp; heap[i] &lt; heap[left(i)])</span><br><span class="line">      swap heap[i] and heap[left(i)]</span><br><span class="line">      bubbleDown(left(i),heap,n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(heap[i] &lt; heap[right])</span><br><span class="line">      swap heap[i] and heap[right(i)]</span><br><span class="line">      bubbleDown(right(i),heap,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worst case &amp; average case of time Complexity = O(log2(n))</p>
<p><strong>Building a new heap tree</strong><br>Sometimes we have a set of items that we wish to heapify. One obvious possibility would be to insert the n items one by one into a heap tree, starting from an empty tree, using the O(log2 n) ‘bubble up’ based insert algorithm discussed earlier. That would clearly have overall time complexity of O(nlog2 n).<br>It turns out, however, that rearranging an array of items into heap tree form can be done more efficiently using “bubble down”. It potentially bubbles down [n/2] items. So the complexity at most is (n/2)log2(n) = nlog2(n).<br>&nbsp;<br>Precisely :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C(h) =  Σ(for each level i) 2^i * (h - i) = 2^h * Σ (h - i)/2^(h-i)</span><br><span class="line">C(h) = 2^h * Σ j/2^j = 2^h * 2 = 2^(h+1) = n</span><br></pre></td></tr></table></figure>
<p>hence, the complexity of heapify is actually O(n), by using bubble down.</p>
<p><strong>Merging binary heap trees</strong><br>Method 1 :<br>Move all the items from the smaller heap tree one at a time into the larger heap tree using the standard insert algorithm. This will involve moving O(n) items, and each of them will need to be bubbled up at cost O(log2 n), giving an overall time complexity of O(nlog2 n).<br>Method 2 :<br>Repeatedly move the last items from one heap tree to the other using the standard insert algorithm, until the new binary tree makeTree(0,t,s) is complete. Then move the last item of the new tree to replace the dummy root “0”, and bubble down that new root. How this is best done will depend on the sizes of the two trees, so this algorithm is not totally straightforward. On average, around half the items in the last level of one tree will need moving and bubbling, so that will be O(n) moves, each with a cost of O(log2 n), again giving an overall time complexity of O(nlog2 n). However, the actual number of operations required will, on average, be a lot less than the previous approach, by something like a factor of four, so this approach is more efficient.<br>Method 3 :<br>Simply concatenate the array forms of the heap trees s and t and use the standard heapify algorithm to convert that array into a new binary heap tree. The heapify algorithm has time complexity O(n), and the concatenation need be no more than that, so this approach has O(n) overall time complexity, making it in the best general approach of all three.<br>&nbsp;<br>NOTE : to decide which one we use, it depends on the sizes of two heap trees. </p>
<p><strong>Binomial heaps</strong><br>def : a binomial heap is more efficient than BHT when inserting and merging.<br>&nbsp;<br>inductive def : a binomial tree is defined recursively as follows :</p>
<ol>
<li>a binomial tree of order 0 is a single node</li>
<li>a binomial tree of order k has a root node with children that are roots of binomial trees of orders k-1, k-2, …, 2, 1, 0 (in that order)</li>
</ol>
<p>Representation :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k    0     1       2             3</span><br><span class="line">    [ ]   [ ]     [ ]         [     ]</span><br><span class="line">           |      / |        /  /   |</span><br><span class="line">          [ ]   [ ] [ ]    [ ] [ ] [ ]</span><br><span class="line">                           / |   |</span><br><span class="line">                        [ ] [ ] [ ]</span><br></pre></td></tr></table></figure>
<p>height : k<br>size   : 2^k</p>
<p>A binomial heap is constructed as a collection of binomial trees with a particular structure and node ordering properties :</p>
<ol>
<li>there can only be zero or one binomial tree of each order</li>
<li>each constituent binomial tree must satisfy the priority ordering property i.e. each node must have priority less than or equal to its parent</li>
</ol>
<p>merging : time complexity = O(log2(n))<br>inserting : time complexity = O(1)<br>heapify : O(n)<br>deleting : time complexity = O(log2(n))</p>
<h2 id="Sorting-strategies-Sorting-algotithem-stability"><a href="#Sorting-strategies-Sorting-algotithem-stability" class="headerlink" title="Sorting strategies, Sorting algotithem stability"></a>Sorting strategies, Sorting algotithem stability</h2><p><strong>General definitions and theoretical limits</strong><br>Comparison-based :</p>
<ul>
<li>enumeration sorting</li>
<li>exchange sorting </li>
<li>selection sorting </li>
<li>insertion sorting</li>
<li>divide and conquer</li>
<li>comparison-based </li>
</ul>
<p>lower bound for comparison-based algorithms : O(nlog2(n))<br>&nbsp;<br>Noncomparison-based</p>
<p><strong>BubbleSort, insertion sort, selection Sort</strong><br>BubbleSort : exchange sorting</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt; n ; i++ )</span><br><span class="line">  <span class="keyword">for</span> ( j = n-<span class="number">1</span> ; j &gt;= i ; j-- ) <span class="comment">// dif with insertion sort</span></span><br><span class="line">    <span class="keyword">if</span> ( a[j] &lt; a[j-<span class="number">1</span>] )</span><br><span class="line">       swap a[j] and a[j-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>time complexity :</p>
<ul>
<li>worst case : O(n^2)</li>
<li>average case : O(n^2)</li>
</ul>
<p>InsertionSort : insertion sorting</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt; n ; i++ ) &#123;</span><br><span class="line">  <span class="keyword">for</span>( j = i ; j &gt; <span class="number">0</span> ; j-- )    <span class="comment">// dif with bubble sort</span></span><br><span class="line">    <span class="keyword">if</span> ( a[j] &lt; a[j-<span class="number">1</span>] )</span><br><span class="line">       swap a[j] and a[j-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time complexity :</p>
<ul>
<li>worst case : O(n^2)</li>
<li>average case : O(n^2)</li>
</ul>
<p>SelectionSort : selection sorting</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; n-<span class="number">1</span> ; i++ ) &#123; </span><br><span class="line"></span><br><span class="line"> k = i</span><br><span class="line"> <span class="keyword">for</span> ( j = i+<span class="number">1</span> ; j &lt; n ; j++ )</span><br><span class="line">    <span class="keyword">if</span> ( a[j] &lt; a[k] )</span><br><span class="line">      k = j</span><br><span class="line">      swap a[i] and a[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time complexity :</p>
<ul>
<li>worst case : O(n^2)</li>
<li>average case : O(n^2)</li>
</ul>
<p>Comparison between bubble, insertion, selection sortings:</p>
<ol>
<li>bubble sorts does a lot of swaps</li>
<li>if there is a few items are misplaced, insertionSort performs very quick</li>
<li>in general selectionSort is better than insertionSort is better than bubbleSort</li>
</ol>
<p>Stability between bubble, insertion, selection sortings: (when considering identical keys [2,1] [2,2])</p>
<ul>
<li>bubbleSort is stable</li>
<li>InsertionSort is stable</li>
<li>SelectionSort is unstable</li>
</ul>
<p><strong>TreeSort, HeapSort</strong><br>TreeSort procedure :</p>
<ol>
<li>build an empty BST, insert each a[i] into it</li>
<li>use a method to fill nodes into an array in order</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">treeSort(array a)&#123;</span><br><span class="line">  t = emptyTree;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">    t = insert(a[i],t);    <span class="comment">// log2(n)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fillArray(t,a,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fillArray(tree t, array a, <span class="keyword">int</span> j)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(t))&#123;</span><br><span class="line">    j = fillArray(left(t),a,j);</span><br><span class="line">    a[j++] = root(t);</span><br><span class="line">    j = fillArray(right(t),a,j);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time complexity :</p>
<ul>
<li>worst case : O(n^2) when the array given is sorted</li>
<li>average case : O(nlog2(n))</li>
</ul>
<p>HeapSort procedure :</p>
<ol>
<li>heapify the array into a BHT.</li>
<li>swap the largest root node and the smallest leaf node for each iteration.(bubble down)</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">heapSort(array a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">  heapify(a,n)</span><br><span class="line">    <span class="keyword">for</span>( j = n ; j &gt; <span class="number">1</span> ; j-- ) &#123;</span><br><span class="line">      swap a[<span class="number">1</span>] and a[j]</span><br><span class="line">      bubbleDown(<span class="number">1</span>,a,j-<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time complexity :</p>
<ul>
<li>worst case : O(nlog2(n))</li>
<li>average case : O(nlog2(n))</li>
<li>best case : O(n)</li>
</ul>
<p>HeapSort is not stable as it can change the order of identical keys.</p>
<p><strong>Devide and conquer sorting</strong><br>Quicksort procedure :</p>
<ol>
<li></li>
<li></li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>time Complexity : </p>
<ul>
<li>worst case O(n^2)</li>
<li>average case O(nlog(n))</li>
<li>best case O(n)</li>
</ul>
<p>Mergesort procedure :</p>
<ol>
<li>2.</li>
</ol>
<p>Algorithm :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>time Complexity : </p>
<ul>
<li>worst case O(nlog(n))</li>
<li>average case O(nlog(n))</li>
</ul>
<p>quickSort代码: <a href="https://blog.51cto.com/flyingcat2013/1281614" target="_blank" rel="noopener">https://blog.51cto.com/flyingcat2013/1281614</a><br>mergeSort代码: <a href="https://blog.csdn.net/javyzheng/article/details/12377585" target="_blank" rel="noopener">https://blog.csdn.net/javyzheng/article/details/12377585</a></p>
<p><strong>Non-comparision : Radix sort</strong></p>
<p><strong>Comparisons</strong></p>
<h2 id="Hash-Tables"><a href="#Hash-Tables" class="headerlink" title="Hash Tables"></a>Hash Tables</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h(KEY) -&gt; position</span><br><span class="line">[K0][K1][K2][K3][K4][K5][K6][K7]</span><br></pre></td></tr></table></figure>
<p>&nbsp; if two keys goes to the same position, it is called <code>collision</code>(散列冲突)</p>
<p>Collision likelihoods and load factors for hash tables<br><code>q(n)= 364·363···(366 - n) / 365^(n-1) = 1 - p(n)</code><br>&nbsp; - prob(not colli 3) = (364*363)/365^2 = 1 - prob(colli)</p>
<p>strategies to deal with collisions<br>&nbsp; Buckets: build a two dimension array<br>&nbsp; Direct chaining: build a linked list<br>&nbsp; open addressing: linear probing &amp; double hashing</p>
<p><code>linear probing</code>: 线性探查法<br>&nbsp; <strong>def:</strong> if there is a collision, reduce index by 1 and insert. As a ring.<br>&nbsp; time.Compx = O(1)</p>
<p><code>double hashing</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( (k/<span class="number">11</span>)%<span class="number">11</span> !=<span class="number">0</span> ) &#123;</span><br><span class="line">    h2(n) = (k/<span class="number">11</span>)%<span class="number">11</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    h2(n) = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp; try every <em>h2(n) steps</em> to the left until a empty location is found<br>&nbsp; time.Compx = o(1)</p>
<h2 id="Graphs"><a href="#Graphs" class="headerlink" title="Graphs"></a>Graphs</h2><p>1.Array-based implementation<br>2.Mixed implementation<br>3.Pointer-based implementation</p>
<p>Relations between graphs</p>
<p>Planarity<br>K5 K3,3<br>&nbsp; planar and non-planar graph</p>
<p>Traversals</p>
<p><strong>Dijkstra’s algorithm:</strong> shortest path from one specific node to all other nodes<br>version I : use <em>boolean array</em> tight<br>version II : <em>priority queue</em> of tight</p>
<p><strong>Floyd’s algorithm:</strong> shortest path between each pair of nodes</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store initial estimates and predecessors.</span></span><br><span class="line">   <span class="keyword">for</span> ( each vertex s ) &#123;</span><br><span class="line">       <span class="keyword">for</span> ( each vertex z ) &#123;</span><br><span class="line">           distance[s][z] = weight[s][z]</span><br><span class="line">           predecessor[s][z] = s</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Improve them by considering all possible shortcuts u.</span></span><br><span class="line">   <span class="keyword">for</span> ( each vertex u ) &#123;</span><br><span class="line">       <span class="keyword">for</span> ( each vertex s ) &#123;</span><br><span class="line">           <span class="keyword">for</span> ( each vertex z ) &#123;</span><br><span class="line">               <span class="keyword">if</span> ( distance[s][u]+distance[u][z] &lt; distance[s][z] ) &#123;</span><br><span class="line">                  distance[s][z] = distance[s][u]+distance[u][z]</span><br><span class="line">                  predecessor[s][z] = predecessor[u][z]</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Greedy algorithms:<br>an algorithm is greedy if it makes its decision based only on what is based on ‘local considerations’ without considering overall result</p>
<p>Minimal spanning trees(最小生成树)<br>prim’s algorithm: A greedy <strong>vertex-based</strong> approach<br>Kruskal’s algorithm: A greedy <strong>edge-based</strong> approach.</p>
<h1 id="Code-Part"><a href="#Code-Part" class="headerlink" title="Code Part:"></a>Code Part:</h1><h2 id="GIT-testing-Set-up-eclipse"><a href="#GIT-testing-Set-up-eclipse" class="headerlink" title="GIT, testing, Set up eclipse"></a>GIT, testing, Set up eclipse</h2><p>log<br>testing<br>junit<br>debug<br>javaDoc<br><a href="http://www.runoob.com/eclipse/eclipse-debug-configuration.html" target="_blank" rel="noopener">http://www.runoob.com/eclipse/eclipse-debug-configuration.html</a>  </p>
<h2 id="Assignments"><a href="#Assignments" class="headerlink" title="Assignments"></a>Assignments</h2><p>ass1:<br>ass2: <em>Stack &amp; Queue</em><br>ass3: <em>Binary Tree</em><br>ass4: <em>Merge Sort</em><br>ass5: <em>Graph</em></p>
<p>##URL<br><a href="http://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-collections.html</a></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Data-Structure"><span class="toc-number">1.</span> <span class="toc-text">Basic Data Structure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Efficiency-amp-amp-Complexity"><span class="toc-number">2.</span> <span class="toc-text">Efficiency &amp;&amp; Complexity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trees-general-binary-quad-trees"><span class="toc-number">3.</span> <span class="toc-text">Trees - general, binary, quad trees</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Search-Tree"><span class="toc-number">4.</span> <span class="toc-text">Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Heap-Trees-and-Priority-queues"><span class="toc-number">5.</span> <span class="toc-text">Binary Heap Trees and Priority queues</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorting-strategies-Sorting-algotithem-stability"><span class="toc-number">6.</span> <span class="toc-text">Sorting strategies, Sorting algotithem stability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash-Tables"><span class="toc-number">7.</span> <span class="toc-text">Hash Tables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Graphs"><span class="toc-number">8.</span> <span class="toc-text">Graphs</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#Code-Part"><span class="toc-number"></span> <span class="toc-text">Code Part:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GIT-testing-Set-up-eclipse"><span class="toc-number">1.</span> <span class="toc-text">GIT, testing, Set up eclipse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Assignments"><span class="toc-number">2.</span> <span class="toc-text">Assignments</span></a></li></ol>
    </li></div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&text=Theory part"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&title=Theory part"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&is_video=false&description=Theory part"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Theory part&body=Check out this article: https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&title=Theory part"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&title=Theory part"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&title=Theory part"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&title=Theory part"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/jwyhhh123/jwyhhh123.github.io.git/2019/02/20/DataStructure-1/&name=Theory part&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Wenye Jin
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'jwy';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
